
--- START FILE: .gitignore ---

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
package-lock.json

--- END FILE: .gitignore ---

--- START FILE: eslint.config.mjs ---

import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;


--- END FILE: eslint.config.mjs ---

--- START FILE: next-env.d.ts ---

/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


--- END FILE: next-env.d.ts ---

--- START FILE: next.config.ts ---

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


--- END FILE: next.config.ts ---

--- START FILE: package.json ---

{
  "name": "big-ai",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@google/genai": "^1.31.0",
    "@types/uuid": "^11.0.0",
    "firebase": "^12.6.0",
    "firebase-admin": "^13.6.0",
    "next": "16.0.7",
    "react": "19.2.1",
    "react-dom": "19.2.1",
    "uuid": "^13.0.0",
    "marked": "^17.0.1",
    "dompurify": "^3.3.0",
    "prismjs": "^1.30.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^24",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/dompurify": "^3.2.0",
    "@types/prismjs": "^1.26.5",
    "eslint": "^9",
    "eslint-config-next": "16.0.7",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}


--- END FILE: package.json ---

--- START FILE: postcss.config.mjs ---

const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;


--- END FILE: postcss.config.mjs ---

--- START FILE: README.md ---

websiet link : https://big-ai-chatbot.netlify.app/

--- END FILE: README.md ---

--- START FILE: tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}


--- END FILE: tsconfig.json ---

--- START FILE: app\globals.css ---

@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
  --bg-chat: #f9fafb; /* Light gray background for chat area */
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
    --bg-chat: #1f2937; /* Dark gray background for chat area */
  }
}

body {
  /* Use the dark-mode ready colors for the main layout */
  background: var(--background); 
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
  height: 100vh; /* Ensure full screen height */
  overflow: hidden; /* Prevent body scroll */
}

/* Optional: Add basic scrollbar styling for better UX */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-thumb {
  background: rgba(156, 163, 175, 0.5); /* gray-400 */
  border-radius: 4px;
}
::-webkit-scrollbar-track {
  background: transparent;
}

--- END FILE: app\globals.css ---

--- START FILE: app\layout.tsx ---

// app/layout.tsx
import type { Metadata } from "next";
import "./globals.css";
import { AuthProvider } from '@/components/providers/AuthProvider';


export const metadata: Metadata = {
  title: "Big AI Chatbot (Production)",
  description: "A large scale Gemini chat application.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={`antialiased`}> 
        <AuthProvider>
          {children}
        </AuthProvider>
      </body>
    </html>
  );
}

--- END FILE: app\layout.tsx ---

--- START FILE: app\page.tsx ---

// app/page.tsx
'use client';

import { useState } from 'react';
import ChatArea from '@/components/ChatArea';
import Sidebar from '@/components/Sidebar';
import { useAuth } from '@/components/providers/AuthProvider';
import AuthGate from '@/components/ui/AuthGate';

export default function HomePage() {
  const { user, loading: authLoading } = useAuth();
  
  const [currentChatId, setCurrentChatId] = useState<string | undefined>(undefined);
  const [refreshSidebarToggle, setRefreshSidebarToggle] = useState(false);

  const handleSelectChat = (chatId: string | undefined) => {
    setCurrentChatId(chatId);
  };
  
  const handleNewMessageSent = () => {
    // Toggle state to force Sidebar to re-fetch history
    setRefreshSidebarToggle(prev => !prev);
  }

  // Show loading state if authentication is in progress
  if (authLoading) {
    return <div className="flex h-screen items-center justify-center text-xl">Loading application...</div>
  }

  // Show AuthGate if user is not logged in
  if (!user) {
    return <AuthGate />;
  }

  // Main application view
  return (
    <div className="flex h-screen bg-gray-50 dark:bg-gray-800">
      {/* 1. Sidebar */}
      <Sidebar 
        onSelectChat={handleSelectChat} 
        currentChatId={currentChatId}
        key={refreshSidebarToggle.toString()} // Force remount/refresh when a new message is sent
      />
      
      {/* 2. Main Chat Area */}
      <main className="flex-1 flex flex-col">
        <ChatArea 
          chatId={currentChatId}
          onChatIdChange={setCurrentChatId}
          onNewMessageSent={handleNewMessageSent}
        />
      </main>
    </div>
  );
}

--- END FILE: app\page.tsx ---

--- START FILE: app\api\chat\route.ts ---

// app/api/chat/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { generateStreamingResponse } from '@/lib/gemini';
import { getConversation, createConversation, updateConversation } from '@/lib/history';
import { getSettings } from '@/lib/settings'; // <-- NEW IMPORT
import { ChatMessage, Conversation, FileAttachment } from '@/types/chat';
import { getAuthId } from '@/lib/firebaseAdmin';

export const runtime = 'nodejs'; 

interface ChatRequest {
    chatId?: string; 
    message: string;
    files?: FileAttachment[]; // NEW: Multimodal files
}

// --- GET: Load existing conversation history ---
export async function GET(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }

    try {
        const { searchParams } = new URL(req.url);
        const chatId = searchParams.get('chatId');

        if (!chatId) {
            return NextResponse.json({ error: 'chatId is required' }, { status: 400 });
        }

        // Use userId in getConversation for authorization check
        const conversation = await getConversation(chatId, userId);

        if (!conversation) {
             return NextResponse.json({ error: 'Conversation not found or unauthorized' }, { status: 404 });
        }

        return NextResponse.json(conversation);

    } catch (error) {
        console.error('API GET Error:', error);
        return NextResponse.json({ error: 'Failed to retrieve chat history' }, { status: 500 });
    }
}


// --- POST: Handle new message/streaming ---
export async function POST(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }

  try {
    const { message, chatId: incomingChatId, files = [] }: ChatRequest = await req.json();

    if (!message || message.trim() === '') {
        // Allow empty text if files are present (e.g., "Analyze this image")
        if (files.length === 0) {
            return NextResponse.json({ error: 'Message cannot be empty.' }, { status: 400 });
        }
    }

    let conversation: Conversation | null = null;
    let chatId = incomingChatId;
    let isFirstExchange = false;

    if (chatId) {
        conversation = await getConversation(chatId, userId);
        if (!conversation) {
            return NextResponse.json({ error: 'Conversation not found or unauthorized.' }, { status: 404 });
        }
    } else {
        // NEW: Fetch global settings for model and system prompt
        const userSettings = await getSettings(userId);
        
        // NEW: Create conversation with global settings context
        conversation = await createConversation(
            userId, 
            message, 
            files,
            userSettings.globalModel, // Pass global model
            userSettings.globalSystemPrompt // Pass global system prompt
        );
        chatId = conversation.id;
        isFirstExchange = true;
    }

    // 1. Prepare history and current prompt (including files)
    const history: ChatMessage[] = conversation?.messages || [];
    
    // The current exchange (user message + files) is added to the history context for Gemini
    const userMessageForContext: ChatMessage = { 
        id: 'temp', 
        text: message, 
        role: 'user', 
        timestamp: Date.now(),
        files: files.length > 0 ? files : undefined,
    } as ChatMessage;

    const fullHistoryContext: ChatMessage[] = [
        ...history,
        userMessageForContext
    ];
    
    // Optional: Pass system prompt from conversation settings
    const systemInstruction = conversation?.systemPrompt;

    // 2. Generate the streaming response
    const stream = await generateStreamingResponse(
        fullHistoryContext,
        systemInstruction
    );
    
    // 3. Read the entire stream response to save it to the database
    let fullBotResponse = '';
    
    // Use .tee() to create two identical streams: one for the client, one for history saving
    const [clientStream, historyStream] = stream.tee();
    
    const reader = historyStream.getReader();
    const decoder = new TextDecoder();
    
    // Asynchronously save history
    (async () => {
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                fullBotResponse += decoder.decode(value);
            }
            
            // 4. Persist the full exchange asynchronously
            if (chatId) {
                await updateConversation(chatId, message, fullBotResponse, userId, files, isFirstExchange);
            }
        } catch (dbError) {
            console.error('CRITICAL: Error saving history to Firestore:', dbError);
        }
    })();
    
    // 5. Send the streaming response back to the client immediately
    const response = new NextResponse(clientStream, {
        headers: {
            'Content-Type': 'text/plain',
            'X-Chat-ID': chatId,
        },
        status: 200,
    });
    
    return response;

  } catch (error) {
    console.error('FATAL API Error:', error);
    return NextResponse.json({ error: 'Failed to process chat request.' }, { status: 500 });
  }
}

--- END FILE: app\api\chat\route.ts ---

--- START FILE: app\api\chats\route.ts ---

// app/api/chats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { db, getAuthId } from '@/lib/firebaseAdmin';
import { Conversation } from '@/types/chat';

export const runtime = 'nodejs';

/**
 * Fetches a list of recent conversations for the current user.
 */
export async function GET(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }
    
    try {
        const snapshot = await db.collection('conversations')
            .where('userId', '==', userId) // Use real User ID
            .orderBy('updatedAt', 'desc')
            .limit(20) // Limit to 20 recent chats
            .get();

        const chats = snapshot.docs.map(doc => {
            const data = doc.data() as Conversation;
            
            // Return only necessary data for the sidebar
            return {
                id: data.id,
                title: data.title,
                updatedAt: data.updatedAt,
            };
        });

        return NextResponse.json(chats);

    } catch (error) {
        console.error('Error fetching chat list:', error);
        return NextResponse.json({ error: 'Failed to retrieve conversation list' }, { status: 500 });
    }
}

--- END FILE: app\api\chats\route.ts ---

--- START FILE: app\api\settings\route.ts ---

// app/api/settings/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getAuthId } from '@/lib/firebaseAdmin';
import { getSettings, saveSettings } from '@/lib/settings';
import { UserSettings } from '@/types/chat';

export const runtime = 'nodejs';

// --- GET: Load user settings ---
export async function GET(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    try {
        const settings = await getSettings(userId);
        return NextResponse.json(settings);
    } catch (error) {
        console.error('API GET Settings Error:', error);
        return NextResponse.json({ error: 'Failed to retrieve settings' }, { status: 500 });
    }
}

// --- POST: Save user settings ---
export async function POST(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    try {
        const body: Partial<UserSettings> = await req.json();
        
        // Use the saveSettings logic from lib/settings
        await saveSettings(userId, body);

        return NextResponse.json({ message: 'Settings saved successfully' });
    } catch (error) {
        console.error('API POST Settings Error:', error);
        return NextResponse.json({ error: 'Failed to save settings' }, { status: 500 });
    }
}

--- END FILE: app\api\settings\route.ts ---

--- START FILE: components\ChatArea.tsx ---

// components/ChatArea.tsx
'use client';

import React, { useState, useCallback, useEffect, useRef, ChangeEvent, DragEvent as ReactDragEvent, KeyboardEvent } from 'react';
import { ChatMessage, Conversation, FileAttachment } from '@/types/chat';
import ChatBubble from './ChatBubble'; // NEW: Dedicated component for message rendering
import { useAuth } from '@/components/providers/AuthProvider';
import { v4 as uuidvv4 } from 'uuid';

const BOT_PENDING_ID = 'bot-pending';

interface ChatAreaProps {
    chatId: string | undefined;
    onChatIdChange: (newChatId: string) => void;
    onNewMessageSent: () => void; // Trigger sidebar refresh
}

// Utility to convert file to Base64 (required for Gemini multimodal input)
const fileToBase64 = (file: File): Promise<FileAttachment> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
            // FIX: Remove unused 'metadata' variable
            const result = reader.result as string;
            const [, base64Data] = result.split(',');
            if (base64Data) {
                resolve({
                    base64Data: base64Data,
                    mimeType: file.type,
                    filename: file.name,
                    size: file.size,
                });
            } else {
                reject(new Error("Failed to read file data."));
            }
        };
        reader.onerror = (error) => reject(error);
    });
};


export default function ChatArea({ chatId, onChatIdChange, onNewMessageSent }: ChatAreaProps) {
  const { user, getIdToken } = useAuth();
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isHistoryLoading, setIsHistoryLoading] = useState(false);
  const [attachments, setAttachments] = useState<File[]>([]); // New: Files selected by user
  
  const chatEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);


  // --- History Loading Effect ---
  useEffect(() => {
    if (!user) return;

    if (chatId) {
      setIsHistoryLoading(true);
      setMessages([]); // Clear old messages
      
      const fetchChatHistory = async () => {
        try {
          const token = await getIdToken();
          const response = await fetch(`/api/chat?chatId=${chatId}`, {
              headers: { 'Authorization': `Bearer ${token}` }
          });
          
          if (response.ok) {
            const conversation: Conversation = await response.json();
            const clientMessages: ChatMessage[] = conversation.messages.map(m => ({
                ...m,
                timestamp: new Date(m.timestamp),
            }));
            setMessages(clientMessages);
          } else {
            console.error("Failed to load conversation:", chatId);
            setMessages([{ id: uuidvv4(), text: 'Failed to load conversation history. Check console for details.', role: 'model', timestamp: new Date() } as ChatMessage]);
          }
        } catch (error) {
          console.error("Error fetching chat history:", error);
        } finally {
          setIsHistoryLoading(false);
        }
      };
      fetchChatHistory();
    } else {
      // New chat state
      setMessages([]);
      setAttachments([]); // Clear attachments for new chat
      setIsHistoryLoading(false);
    }
  }, [chatId, user, getIdToken]);

  // --- Utility Functions ---
  const addMessage = useCallback((msg: ChatMessage) => {
    setMessages((prev) => [...prev, msg]);
  }, []);

  const updateBotStreamingMessage = useCallback((text: string) => {
    setMessages((prev) => {
      const lastMessage = prev[prev.length - 1];
      if (lastMessage && lastMessage.id === BOT_PENDING_ID) {
        return [
          ...prev.slice(0, -1),
          { ...lastMessage, text: lastMessage.text + text },
        ];
      }
      return [...prev, { id: BOT_PENDING_ID, text, role: 'model', timestamp: new Date() } as ChatMessage];
    });
  }, []);

  const finalizeBotMessage = useCallback((finalText: string) => {
    setMessages((prev) => {
      const finalIndex = prev.findIndex(m => m.id === BOT_PENDING_ID);
      if (finalIndex !== -1) {
        const finalBotMessage: ChatMessage = {
            id: uuidvv4(), 
            text: finalText,
            role: 'model',
            timestamp: new Date(),
          };
        return [...prev.slice(0, finalIndex), finalBotMessage];
      }
      return prev;
    });
    onNewMessageSent(); // Notify parent to refresh sidebar
  }, [onNewMessageSent]);

  // --- Input and UI Handlers ---
  
  // Dynamic Input Height Adjustment (requested feature)
  useEffect(() => {
    const textarea = inputRef.current;
    if (textarea) {
      textarea.style.height = 'auto'; 
      textarea.style.height = `${textarea.scrollHeight}px`;
    }
  }, [input]);

  const handleKeyPress = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      // FIX: Cast e to React.FormEvent<HTMLFormElement> for handleSendMessage
      handleSendMessage(e as unknown as React.FormEvent<HTMLFormElement>);
    }
  };

  // FIX: Consolidated and strongly typed the event parameter
  type FileEvent = ChangeEvent<HTMLInputElement> | ReactDragEvent<HTMLDivElement> | React.ClipboardEvent<HTMLTextAreaElement>;
  
  const handleFileSelect = (e: FileEvent) => {
      const selectedFiles: File[] = [];
  
      if ('clipboardData' in e) {
          if (e.clipboardData?.files) {
              selectedFiles.push(...Array.from(e.clipboardData.files));
          }
      } else if ('dataTransfer' in e) { // ReactDragEvent<HTMLDivElement>
          if (e.dataTransfer?.files) {
              selectedFiles.push(...Array.from(e.dataTransfer.files));
          }
      } else if ('target' in e && (e.target as HTMLInputElement).files) { // ChangeEvent<HTMLInputElement>
          const target = e.target as HTMLInputElement;
          if (target.files) {
              selectedFiles.push(...Array.from(target.files));
          }
      }
      
      // FIX: 'file' is of type 'unknown' -> Map selectedFiles (which are File objects) to File type
      const validFiles: File[] = selectedFiles.filter((file) => 
        (file.type.startsWith('image/') || file.type === 'application/pdf' || file.type.startsWith('text/') || file.type.startsWith('audio/') || file.type.startsWith('video/')) && file.size < 20 * 1024 * 1024 // 20MB limit
      );
  
      if (validFiles.length > 0) {
        // FIX: Ensure setState type consistency
        setAttachments(prev => [...prev, ...validFiles]);
      }
  };

  const removeAttachment = (index: number) => {
    setAttachments(prev => prev.filter((_, i) => i !== index));
  };


  // --- Main Send Handler ---

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    const trimmedInput = input.trim();
    
    // Must have text OR attachments
    if ((!trimmedInput && attachments.length === 0) || isLoading || isHistoryLoading) return;

    // 1. Convert attachments to Base64 payload
    const base64Attachments: FileAttachment[] = await Promise.all(
        attachments.map(file => fileToBase64(file))
    );
    
    const userMessage: ChatMessage = {
      id: uuidvv4(),
      text: trimmedInput,
      role: 'user',
      timestamp: new Date(),
      files: base64Attachments.length > 0 ? base64Attachments : undefined,
    };

    addMessage(userMessage);
    addMessage({ 
        id: BOT_PENDING_ID, 
        text: '...', // Use '...' as placeholder for pending message/typing indicator
        role: 'model', 
        timestamp: new Date() 
    } as ChatMessage);
    
    setInput('');
    setAttachments([]); // Clear attachments after sending
    setIsLoading(true);

    try {
      const token = await getIdToken();
      
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`, // Send Auth Token
        },
        body: JSON.stringify({
          message: trimmedInput,
          chatId: chatId, 
          files: base64Attachments, // Pass Base64 files to API
        }),
      });

      if (response.status === 401) {
          finalizeBotMessage('Session expired. Please log out and log back in.');
          return;
      }
      if (!response.ok || !response.body) {
        finalizeBotMessage('Sorry, Big AI ran into an internal error.');
        // FIX: Don't throw, just exit the function after finalizing the message
        return; 
      }
      
      const newChatId = response.headers.get('X-Chat-ID');
      if (newChatId && newChatId !== chatId) {
          onChatIdChange(newChatId); // Update conversation ID in parent state
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let accumulatedText = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        accumulatedText += chunk;
        updateBotStreamingMessage(chunk); 
      }

      finalizeBotMessage(accumulatedText);

    } catch (error) {
      console.error('Error fetching AI response:', error);
      finalizeBotMessage('Sorry, Big AI ran into a communication error.');
    } finally {
      setIsLoading(false);
    }
  };
  
  // Scroll Anchor Effect
  useEffect(() => {
    if (!isHistoryLoading) {
        chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages, isHistoryLoading]);

  // --- Render ---

  if (isHistoryLoading) {
    // ... loading spinner unchanged
    return (
        <div className="flex flex-col h-full items-center justify-center bg-gray-50 dark:bg-gray-800 text-gray-700 dark:text-gray-300">
            <svg className="animate-spin h-8 w-8 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <p className="mt-4">Loading conversation...</p>
        </div>
    );
  }

  return (
    <div className="flex flex-col h-full w-full">
      <header className="p-4 border-b dark:border-gray-700 bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-center font-semibold shadow-sm">
        {chatId ? messages[0]?.text.substring(0, 50) + '...' : 'New Conversation'}
      </header>
      
      {/* Chat Messages Display */}
      <div 
        className="flex-1 overflow-y-auto p-4 space-y-6 bg-white dark:bg-gray-800"
        onDrop={(e) => { e.preventDefault(); handleFileSelect(e); }}
        onDragOver={(e) => e.preventDefault()}
      >
        {messages.length === 0 && (
            <div className='flex flex-col items-center justify-center h-full text-gray-500 dark:text-gray-400'>
                <h1 className='text-3xl font-bold mb-4'>Big AI</h1>
                <p>Start a new conversation or drag files here!</p>
            </div>
        )}
        {messages.map((msg, index) => (
          <ChatBubble 
            key={msg.id + index} 
            message={msg} 
            isPending={msg.id === BOT_PENDING_ID} 
          />
        ))}
        {/* Scroll Anchor */}
        <div ref={chatEndRef} />
      </div>

      {/* Input Form Area */}
      <div className="p-4 border-t dark:border-gray-700 bg-white dark:bg-gray-800 flex flex-col items-center">
        
        {/* File Preview Area */}
        {attachments.length > 0 && (
            <div className='w-full max-w-2xl mb-3 flex flex-wrap gap-2 p-3 border dark:border-gray-700 rounded-lg bg-gray-50 dark:bg-gray-700/50'>
                {attachments.map((file, index) => (
                    <div key={index} className='relative flex items-center bg-gray-200 dark:bg-gray-800 p-2 rounded-md text-sm text-gray-800 dark:text-gray-200'>
                        <span className='truncate max-w-[150px]'>{file.name}</span>
                        <button 
                            type="button" 
                            onClick={() => removeAttachment(index)} 
                            className='ml-2 text-red-500 hover:text-red-700'
                        >
                            &times;
                        </button>
                    </div>
                ))}
            </div>
        )}


        <form onSubmit={handleSendMessage} className="flex w-full max-w-2xl border dark:border-gray-600 rounded-xl shadow-lg">
            
            {/* File Upload Button */}
            <label htmlFor="file-upload" className="p-3 text-gray-500 dark:text-gray-400 hover:text-blue-500 cursor-pointer flex items-center justify-center">
                <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13.5"></path></svg>
                <input 
                    id="file-upload" 
                    type="file" 
                    multiple 
                    onChange={handleFileSelect as (e: ChangeEvent<HTMLInputElement>) => void} // Explicit ChangeEvent typing
                    className="hidden" 
                    disabled={isLoading || isHistoryLoading}
                />
            </label>

            <textarea
                ref={inputRef}
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleKeyPress}
                onPaste={handleFileSelect as (e: React.ClipboardEvent<HTMLTextAreaElement>) => void} // Explicit ClipboardEvent typing
                placeholder={isLoading ? "Please wait..." : (attachments.length > 0 ? `Message Big AI about ${attachments.length} files...` : "Message Big AI...")}
                className="flex-1 p-3 bg-transparent focus:outline-none text-gray-900 dark:text-gray-200 resize-none overflow-y-auto max-h-[200px]"
                disabled={isLoading || isHistoryLoading}
                rows={1}
                style={{ minHeight: '48px' }}
                autoFocus
            />
            
            {/* Send Button */}
            <button
              type="submit"
              className="px-4 py-3 bg-blue-600 text-white rounded-r-xl hover:bg-blue-700 transition disabled:bg-blue-400 disabled:cursor-not-allowed flex items-center justify-center"
              disabled={isLoading || isHistoryLoading || (!input.trim() && attachments.length === 0)}
            >
              <svg className="w-5 h-5 transform rotate-45 -mt-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
            </button>
        </form>
      </div>
    </div>
  );
}

--- END FILE: components\ChatArea.tsx ---

--- START FILE: components\ChatBubble.tsx ---

// components/ChatBubble.tsx
'use client';

import React, { useEffect, useMemo, useRef } from 'react';
import { ChatMessage, FileAttachment } from '@/types/chat';

// External Libraries for Markdown Rendering
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
import 'prismjs/themes/prism-dark.css'; 

interface ChatBubbleProps {
    message: ChatMessage;
    isPending: boolean;
}

// Custom renderer for Marked (to add code block headers and copy button)
const renderer = new marked.Renderer();

// FIX: Explicitly type code and lang parameters to resolve TS errors 7006 and 2322.
renderer.code = ({ text, lang, escaped }: { text: string; lang?: string; escaped?: boolean }): string => {
    const language = lang || 'plaintext';
    const highlightedCode = Prism.highlight(text, Prism.languages[language] || Prism.languages.clike, language);

    // Create the header bar with language and copy button
    const header = `
        <div class="code-block-header flex justify-between items-center bg-gray-700 dark:bg-gray-800 p-2 rounded-t-lg text-xs text-gray-300">
            <span>${language.toUpperCase()}</span>
            <button class="copy-button p-1 rounded hover:bg-gray-600 transition" data-code="${encodeURIComponent(text)}">
                <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5v-2a2 2 0 012-2h2a2 2 0 012 2v2M3 17a1 1 0 100-2 1 1 0 000 2z"/></svg>
            </button>
        </div>
    `;

    // Wrap the code block
    return `
        <div class="code-block my-2">
            ${header}
            <pre class="rounded-b-lg p-3 bg-gray-900 overflow-x-auto"><code class="language-${language}">${highlightedCode}</code></pre>
        </div>
    `;
};


// Configure marked
marked.setOptions({
    breaks: true, // Allow GFM line breaks
    renderer: renderer,
    gfm: true,
});


// Handler for copying code blocks
const setupCopyListeners = (container: HTMLElement) => {
    container.querySelectorAll('.copy-button').forEach(button => {
        const code = decodeURIComponent(button.getAttribute('data-code') || '');
        button.addEventListener('click', () => {
            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.innerHTML;
                button.innerHTML = `<span class="text-green-400">Copied!</span>`;
                setTimeout(() => {
                    button.innerHTML = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        });
    });
};


const ChatBubble: React.FC<ChatBubbleProps> = ({ message, isPending }) => {
    const contentRef = useRef<HTMLDivElement>(null);
    const isUser = message.role === 'user';

    // Parse and sanitize markdown content
    const sanitizedHtml = useMemo(() => {
        if (isUser) return message.text; // Don't parse user input as full markdown by default
        
        // Use marked to convert markdown to HTML, then sanitize it
        const html = marked.parse(message.text);
        return DOMPurify.sanitize(html as string);

    }, [message.text, isUser]);

    // Apply syntax highlighting and copy listeners after rendering
    useEffect(() => {
        if (contentRef.current && !isUser) {
            Prism.highlightAllUnder(contentRef.current);
            setupCopyListeners(contentRef.current);
        }
    }, [sanitizedHtml, isUser]);


    const renderAttachments = (files: FileAttachment[]) => (
        <div className="flex flex-wrap gap-2 mt-2">
            {files.map((file, index) => {
                const isImage = file.mimeType.startsWith('image/');
                const isTooLarge = file.size > 1024 * 1024 * 5; // 5MB heuristic
                
                return (
                    <div key={index} className="flex flex-col items-center p-2 border border-gray-300 dark:border-gray-600 rounded-lg max-w-[150px]">
                        {isImage && !isTooLarge ? (
                            // FIX: Use Next.js Image component in a production app, but keeping img for module-free structure as requested. 
                            // ESLint warning disabled for this file as a trade-off.
                            <img 
                                src={`data:${file.mimeType};base64,${file.base64Data}`}
                                alt={file.filename}
                                className="w-full h-auto object-cover rounded-md max-h-24"
                            />
                        ) : (
                            <svg className="w-8 h-8 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M11 5H6a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2V7a2 2 0 00-2-2zM11 5V3a2 2 0 00-2-2H4a2 2 0 00-2 2v10a2 2 0 002 2h2"></path></svg>
                        )}
                        <span className="text-xs truncate w-full text-center mt-1 text-gray-600 dark:text-gray-300">
                            {file.filename}
                        </span>
                    </div>
                );
            })}
        </div>
    );

    return (
        <div
            className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}
        >
            <div className="flex items-start max-w-[75%]">
                {/* Avatar / Role Indicator */}
                <div className={`p-2 rounded-full text-white mr-3 shrink-0 ${isUser ? 'hidden' : 'bg-blue-600'}`}>
                    {isUser ? '' : 'AI'}
                </div>
                
                {/* Bubble Content */}
                <div
                    className={`p-3 rounded-lg shadow-md transition duration-300 ease-in-out break-words ${
                        isUser
                            ? 'bg-blue-600 text-white rounded-bl-none'
                            : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-tr-none border dark:border-gray-600'
                    } ${isPending ? 'animate-pulse' : ''}`}
                >
                    {/* Render Multimodal Attachments first */}
                    {message.files && renderAttachments(message.files)}

                    {/* Render Text Content */}
                    <div 
                        ref={contentRef}
                        className={`message-content ${isUser ? '' : 'prose dark:prose-invert max-w-none'}`} 
                        // dangerouslySetInnerHTML is required for rendering marked HTML
                        dangerouslySetInnerHTML={{ __html: isUser ? `<p>${message.text}</p>` : sanitizedHtml }}
                    />
                </div>
                
                {/* User Avatar / Role Indicator */}
                <div className={`p-2 rounded-full text-white ml-3 shrink-0 ${isUser ? 'bg-gray-500' : 'hidden'}`}>
                    {isUser ? 'You' : ''}
                </div>
            </div>
        </div>
    );
}

export default ChatBubble;

--- END FILE: components\ChatBubble.tsx ---

--- START FILE: components\SettingsPanel.tsx ---

// components/SettingsPanel.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { UserSettings } from '@/types/chat';

interface SettingsPanelProps {
    onClose: () => void;
}

const MODELS = [
    { name: 'Gemini 2.5 Flash (Preview 09-2025)', id: 'gemini-2.5-flash-preview-09-2025', description: 'The recommended default model, stable and powerful.' }, // <-- NEW DEFAULT
    { name: 'Gemini 2.5 Flash (Stable)', id: 'gemini-2.5-flash', description: 'Fast and versatile, ideal for chat.' },
    { name: 'Gemini 2.5 Pro', id: 'gemini-2.5-pro', description: 'Most capable model for complex tasks.' },
    { name: 'Gemini 3.0 Pro', id: 'gemini-3-pro-preview', description: 'Experimental, highest reasoning capability.' },
];

export default function SettingsPanel({ onClose }: SettingsPanelProps) {
    const { user, getIdToken } = useAuth();
    const [settings, setSettings] = useState<UserSettings | null>(null);
    const [loading, setLoading] = useState(true);
    const [saving, setSaving] = useState(false);
    const [statusMessage, setStatusMessage] = useState<string | null>(null);

    // Fetch settings on load
    useEffect(() => {
        const fetchSettings = async () => {
            if (!user) return;
            try {
                const token = await getIdToken();
                const response = await fetch('/api/settings', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (response.ok) {
                    const data: UserSettings = await response.json();
                    setSettings(data);
                } else {
                    console.error("Failed to fetch settings.");
                }
            } catch (error) {
                console.error("Error fetching settings:", error);
            } finally {
                setLoading(false);
            }
        };
        fetchSettings();
    }, [user, getIdToken]);

    const handleSave = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!user || !settings) return;

        setSaving(true);
        setStatusMessage(null);
        try {
            const token = await getIdToken();
            const response = await fetch('/api/settings', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({
                    globalModel: settings.globalModel,
                    globalSystemPrompt: settings.globalSystemPrompt,
                }),
            });

            if (response.ok) {
                setStatusMessage('Settings saved successfully!');
            } else {
                setStatusMessage('Failed to save settings.');
            }
        } catch (error) {
            console.error("Error saving settings:", error);
            setStatusMessage('An error occurred during saving.');
        } finally {
            setSaving(false);
            setTimeout(() => setStatusMessage(null), 3000);
        }
    };
    
    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value } = e.target;
        setSettings(prev => prev ? ({ ...prev, [name]: value }) : null);
    };

    if (loading) {
        return (
             <div className="absolute inset-0 bg-gray-900/90 flex items-center justify-center text-white z-50">
                 Loading settings...
            </div>
        )
    }
    
    if (!settings) return null; 

    return (
        <div className="absolute inset-0 bg-gray-900/95 flex items-center justify-center z-50">
            <div className="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-2xl border border-gray-700">
                <div className="flex justify-between items-center mb-6 border-b border-gray-700 pb-3">
                    <h2 className="text-2xl font-bold text-white">AI Settings & Prompts</h2>
                    <button onClick={onClose} className="text-gray-400 hover:text-white transition">
                        <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>

                <form onSubmit={handleSave} className="space-y-6">
                    {/* Model Selection */}
                    <div>
                        <label htmlFor="globalModel" className="block text-sm font-medium text-gray-300 mb-1">
                            Default AI Model
                        </label>
                        <select
                            id="globalModel"
                            name="globalModel"
                            value={settings.globalModel}
                            onChange={handleInputChange}
                            className="w-full p-2 border border-gray-700 rounded-lg bg-gray-700 text-white focus:ring-blue-500 focus:border-blue-500"
                        >
                            {MODELS.map(model => (
                                <option key={model.id} value={model.id}>
                                    {model.name}
                                </option>
                            ))}
                        </select>
                        <p className="text-xs text-gray-500 mt-1">
                            {MODELS.find(m => m.id === settings.globalModel)?.description}
                        </p>
                    </div>

                    {/* System Prompt */}
                    <div>
                        <label htmlFor="globalSystemPrompt" className="block text-sm font-medium text-gray-300 mb-1">
                            Global System Prompt (Personality)
                        </label>
                        <textarea
                            id="globalSystemPrompt"
                            name="globalSystemPrompt"
                            value={settings.globalSystemPrompt}
                            onChange={handleInputChange}
                            rows={4}
                            placeholder="Set an instruction to define the AI's behavior..."
                            className="w-full p-3 border border-gray-700 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500 resize-none"
                        />
                        <p className="text-xs text-gray-500 mt-1">
                            This prompt defines the AI&apos;s behavior for all *new* conversations.
                        </p>
                    </div>
                    
                    {/* Save Button */}
                    <div className="flex justify-between items-center pt-4">
                        {statusMessage && (
                            <p className={`text-sm ${statusMessage.includes('saved') ? 'text-green-400' : 'text-red-400'}`}>
                                {statusMessage}
                            </p>
                        )}
                        <button
                            type="submit"
                            disabled={saving}
                            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition disabled:bg-blue-400"
                        >
                            {saving ? 'Saving...' : 'Save Settings'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
}

--- END FILE: components\SettingsPanel.tsx ---

--- START FILE: components\Sidebar.tsx ---

// components/Sidebar.tsx
'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
// import { deleteAllUserConversations } from '@/lib/history'; // Assuming we create this function
import SettingsPanel from './SettingsPanel'; // <-- NEW IMPORT

interface ChatHistoryItem {
    id: string;
    title: string;
    updatedAt: number;
}

interface SidebarProps {
    onSelectChat: (chatId: string | undefined) => void;
    currentChatId: string | undefined;
}

export default function Sidebar({ onSelectChat, currentChatId }: SidebarProps) {
    const { user, signOut, getIdToken } = useAuth();
    const [history, setHistory] = useState<ChatHistoryItem[]>([]);
    const [loading, setLoading] = useState(true);
    const [isSettingsOpen, setIsSettingsOpen] = useState(false); // <-- NEW STATE

    // FIX: Memoize fetchHistory using useCallback to stabilize it as a dependency
    const fetchHistory = useCallback(async () => {
        if (!user) return;
        setLoading(true);
        try {
            const token = await getIdToken();
            const response = await fetch('/api/chats', {
                headers: {
                    'Authorization': `Bearer ${token}`,
                }
            });
            if (response.ok) {
                const data: ChatHistoryItem[] = await response.json();
                setHistory(data);
            }
        } catch (error) {
            console.error("Failed to fetch chat history:", error);
        } finally {
            setLoading(false);
        }
    }, [user, getIdToken]); // Dependencies for useCallback

    useEffect(() => {
        fetchHistory();
    }, [currentChatId, fetchHistory]); // Dependency array now includes fetchHistory

    const handleNewChat = () => {
        onSelectChat(undefined);
    };

    const handleSignOut = async () => {
        if (confirm("Are you sure you want to sign out?")) {
            await signOut();
        }
    };

    const handleDeleteAllChats = async () => {
        if (!user) return;
        if (confirm("DANGER: Are you sure you want to permanently delete ALL your chat history? This cannot be undone.")) {
            // Placeholder/Mock action
            // await deleteAllUserConversations(user.uid); 
            alert("All user chats deleted (Mocked implementation). History sidebar will refresh.");
            setHistory([]);
            onSelectChat(undefined);
        }
    }

    // Updated handler to control the Settings modal
    const handleSettingsAction = (action: string) => {
        if (action === 'Settings') {
            setIsSettingsOpen(true);
        } else if (action === 'Delete All Chats') {
             handleDeleteAllChats();
        }
    };


    return (
        <div className="flex flex-col w-64 bg-gray-900 text-white h-screen p-3 shadow-2xl relative">
            {isSettingsOpen && <SettingsPanel onClose={() => setIsSettingsOpen(false)} />}
            
            {/* Header / New Chat Button */}
            <div className="mb-4">
                <button
                    onClick={handleNewChat}
                    className="flex w-full items-center justify-start gap-2 rounded-lg border border-gray-700 p-3 text-sm transition duration-150 hover:bg-gray-800"
                >
                    <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4"></path></svg>
                    Start New Chat
                </button>
            </div>

            {/* History List */}
            <div className="flex-1 overflow-y-auto space-y-2 pr-1">
                {loading && <div className="text-gray-500 text-sm p-3">Loading history...</div>}
                
                {history.length === 0 && !loading && (
                    <div className="text-gray-500 text-sm p-3">No history found.</div>
                )}
                
                {history.map((chat) => (
                    <button
                        key={chat.id}
                        onClick={() => onSelectChat(chat.id)}
                        className={`flex w-full items-center rounded-lg p-3 text-left text-sm transition duration-150 ${
                            chat.id === currentChatId 
                                ? 'bg-gray-700 font-semibold' 
                                : 'hover:bg-gray-800'
                        }`}
                        title={chat.title}
                    >
                        <svg className="w-4 h-4 mr-2 shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M20 12H4M12 4v16"></path></svg>
                        <span className="truncate flex-1">
                            {chat.title}
                        </span>
                    </button>
                ))}
            </div>
            
            {/* Settings and Footer Area */}
            <div className="pt-4 border-t border-gray-700 mt-4 space-y-2">
                 <button 
                    className="w-full text-left text-sm p-2 rounded-lg hover:bg-gray-800 transition text-blue-300"
                    onClick={() => handleSettingsAction('Settings')}
                >
                    <span className="font-semibold"> Settings & Prompts</span>
                </button>
                
                 <button 
                    className="w-full text-left text-sm p-2 rounded-lg hover:bg-gray-800 transition text-red-300"
                    onClick={() => handleSettingsAction('Delete All Chats')}
                >
                    <span className="font-semibold"> Delete All Chats (Mock)</span>
                </button>

                <div className="text-sm text-gray-400 border-t border-gray-800 pt-2">
                    {user?.email || "User"}
                </div>
                <button 
                    className="w-full text-left text-sm p-2 rounded-lg hover:bg-red-900 transition text-red-400"
                    onClick={handleSignOut}
                >
                    Log out
                </button>
            </div>
        </div>
    );
}

--- END FILE: components\Sidebar.tsx ---

--- START FILE: components\providers\AuthProvider.tsx ---

// components/providers/AuthProvider.tsx
'use client';

import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { User, onAuthStateChanged, signOut as firebaseSignOut } from 'firebase/auth';
import { auth } from '@/utils/firebase';

interface AuthContextType {
  user: User | null;
  loading: boolean;
  getIdToken: () => Promise<string | null>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
      setUser(currentUser);
      setLoading(false);
    });
    return () => unsubscribe();
  }, []);

  const getIdToken = async (): Promise<string | null> => {
    if (user) {
      return await user.getIdToken();
    }
    return null;
  };

  const signOut = async () => {
    await firebaseSignOut(auth);
    // Optionally wipe local state here if needed
  };

  return (
    <AuthContext.Provider value={{ user, loading, getIdToken, signOut }}>
      {children}
    </AuthContext.Provider>
  );
};

--- END FILE: components\providers\AuthProvider.tsx ---

--- START FILE: components\ui\AuthGate.tsx ---

// components/ui/AuthGate.tsx
'use client';

import { useState } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { signInWithEmailAndPassword, createUserWithEmailAndPassword, GoogleAuthProvider, signInWithPopup } from 'firebase/auth';
import { FirebaseError } from 'firebase/app';
import { auth } from '@/utils/firebase';

export default function AuthGate() {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [isRegister, setIsRegister] = useState(false);
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const { loading: authLoading } = useAuth();


    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        try {
            if (isRegister) {
                await createUserWithEmailAndPassword(auth, email, password);
            } else {
                await signInWithEmailAndPassword(auth, email, password);
            }
        } catch (err) {
            console.error(err);
            // FIX: Check if error is a FirebaseError for better typing
            const errorMessage = err instanceof FirebaseError ? err.message : 'Authentication failed.';
            setError(errorMessage);
        } finally {
            setLoading(false);
        }
    };

    const handleGoogleSignIn = async () => {
        setLoading(true);
        setError('');
        try {
            const provider = new GoogleAuthProvider();
            await signInWithPopup(auth, provider);
        } catch (err) {
            const errorMessage = err instanceof FirebaseError ? err.message : 'Google Sign-In failed.';
             setError(errorMessage);
        } finally {
             setLoading(false);
        }
    };

    if (authLoading) {
        return <div className="flex h-screen items-center justify-center bg-gray-900 text-white">Loading Auth...</div>
    }

    return (
        <div className="flex h-screen items-center justify-center bg-gray-900 text-white">
            <div className="w-full max-w-md p-8 space-y-6 bg-gray-800 rounded-xl shadow-2xl">
                <h2 className="text-2xl font-bold text-center">
                    {isRegister ? 'Sign Up for Big AI' : 'Sign In to Big AI'}
                </h2>
                {error && <p className="text-red-400 text-center">{error}</p>}
                
                <form onSubmit={handleSubmit} className="space-y-4">
                    <input
                        type="email"
                        placeholder="Email"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        className="w-full p-3 border border-gray-700 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500"
                        required
                    />
                    <input
                        type="password"
                        placeholder="Password"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        className="w-full p-3 border border-gray-700 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500"
                        required
                    />
                    <button
                        type="submit"
                        disabled={loading}
                        className="w-full p-3 text-white bg-blue-600 rounded-lg hover:bg-blue-700 transition duration-200 disabled:bg-blue-400"
                    >
                        {loading ? 'Processing...' : isRegister ? 'Register' : 'Sign In'}
                    </button>
                </form>

                <div className="relative flex items-center justify-center">
                    <span className="absolute px-3 bg-gray-800 text-gray-400 text-sm">OR</span>
                    <div className="w-full border-t border-gray-700"></div>
                </div>

                <button
                    onClick={handleGoogleSignIn}
                    disabled={loading}
                    className="w-full p-3 flex items-center justify-center gap-2 border border-gray-700 rounded-lg text-gray-300 hover:bg-gray-700 transition disabled:opacity-50"
                >
                    <svg width="20" height="20" viewBox="0 0 48 48"><path fill="#FFC107" d="M43.6 24c0-1.6-.2-3.3-.5-4.9H24v9.2h10.9c-.6 2.9-2.2 5.4-4.7 7.2v6.4h8.2c4.7-4.4 7.4-10.9 7.4-18z"/><path fill="#FF3D00" d="M24 48c6.6 0 12.3-2.2 16.4-6L31.9 35.6c-2.3 1.5-5.2 2.4-8 2.4-6.4 0-11.8-4.3-13.7-10.1h-8.5v6.6C4.8 41.7 13.7 48 24 48z"/><path fill="#4CAF50" d="M10.3 28.5c-.5-1.5-.8-3.1-.8-4.5s.3-3 .8-4.5V13H1.8C.6 15.6 0 18.5 0 24c0 5.5.6 8.4 1.8 11L10.3 28.5z"/><path fill="#1976D2" d="M24 9.6c3.4 0 6.4 1.2 8.8 3.5l7.3-7.3C36.3 3.4 30.5 0 24 0c-10.3 0-19.2 6.3-22.3 15.6l8.5 6.6C12.2 13.9 17.6 9.6 24 9.6z"/></svg>
                    Sign in with Google
                </button>

                <button
                    onClick={() => setIsRegister(p => !p)}
                    className="w-full text-sm text-center text-gray-400 hover:text-blue-500 transition"
                >
                    {isRegister ? 'Already have an account? Sign In' : 'Need an account? Register'}
                </button>
            </div>
        </div>
    );
}

--- END FILE: components\ui\AuthGate.tsx ---

--- START FILE: lib\firebaseAdmin.ts ---

// lib/firebaseAdmin.ts
import * as admin from 'firebase-admin';
import { NextRequest } from 'next/server';

// Initialize the Admin SDK only if it hasn't been initialized already
if (!admin.apps.length) {
  try {
    const serviceAccountJson = process.env.FIREBASE_SERVICE_ACCOUNT_JSON;
    
    if (!serviceAccountJson) {
        // This is the source of the 500s if db or admin.auth() is called before a return path.
        console.error("CRITICAL: FIREBASE_SERVICE_ACCOUNT_JSON environment variable is NOT set. Server-side persistence will fail.");
    } else {
        const serviceAccount = JSON.parse(serviceAccountJson);
        
        admin.initializeApp({
            credential: admin.credential.cert(serviceAccount),
        });
        console.log("Firebase Admin Initialized successfully.");
    }
  } catch (error) {
    console.error("FATAL: Firebase Admin initialization error. Check FIREBASE_SERVICE_ACCOUNT_JSON format.", error);
    // If initialization fails here, subsequent calls to getAuthId or db will throw.
  }
}

// Check if app is initialized before accessing services
const isInitialized = admin.apps.length > 0;
const db = isInitialized ? admin.firestore() : { collection: () => ({ where: () => ({ orderBy: () => ({ limit: () => ({ get: () => Promise.resolve({ docs: [] }) }) }) }), doc: () => ({ get: () => Promise.resolve(null), set: () => Promise.resolve(), update: () => Promise.resolve() }) }) } as unknown as admin.firestore.Firestore;

// Utility function to verify the user ID from the request
export async function getAuthId(req: NextRequest): Promise<string | null> {
    if (!isInitialized) {
        console.error("Authentication failed: Firebase Admin not initialized.");
        return null;
    }

    const authHeader = req.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return null;
    }
    const token = authHeader.split(' ')[1];
    
    try {
        const decodedToken = await admin.auth().verifyIdToken(token);
        return decodedToken.uid;
    } catch (error) {
        console.error("Token verification failed:", error);
        return null;
    }
}


// Exporting both db and admin
export { db, admin };

--- END FILE: lib\firebaseAdmin.ts ---

--- START FILE: lib\gemini.ts ---

// lib/gemini.ts
import { GoogleGenAI } from '@google/genai';
import { GeminiContent, ChatMessage } from '@/types/chat';

// We use a specific, high-capability model as requested (though slightly modified name for stability)
const MODEL_NAME = 'gemini-2.5-flash-preview-09-2025'; // <-- UPDATED DEFAULT MODEL NAME

// Initialize Gemini Client
const ai = new GoogleGenAI({});

// Helper function to convert client ChatMessage to GeminiContent
function chatMessageToGeminiContent(msg: ChatMessage): GeminiContent {
    const parts: ({ text: string } | { inlineData: { data: string; mimeType: string } })[] = []; // Using a union type for parts array

    // 1. Add text part
    if (msg.text) {
        parts.push({ text: msg.text });
    }

    // 2. Add file parts (multimodal)
    if (msg.files && msg.files.length > 0) {
        msg.files.forEach(file => {
            parts.push({
                inlineData: {
                    data: file.base64Data,
                    mimeType: file.mimeType,
                }
            }); 
        });
    }

    return {
        role: msg.role,
        parts: parts,
    } as GeminiContent; 
}


/**
 * Transforms client/storage messages into the format the Gemini API expects
 * and generates streaming content.
 * 
 * @param history A list of previous messages in the conversation (including the latest user prompt).
 * @returns A ReadableStream of text chunks.
 */
export async function generateStreamingResponse(
    history: ChatMessage[],
    systemInstruction?: string,
): Promise<ReadableStream<Uint8Array>> {
    
    // 1. Prepare contents array (convert ChatMessages to GeminiContent)
    const contents: GeminiContent[] = history.map(chatMessageToGeminiContent);

    // 2. Call the streaming API
    const responseStream = await ai.models.generateContentStream({
        model: MODEL_NAME, // Uses the updated model constant
        contents: contents,
        config: systemInstruction ? { systemInstruction } : undefined,
    });

    // 3. Convert the response stream to a standard Node.js/Next.js ReadableStream
    const encoder = new TextEncoder();
    
    const stream = new ReadableStream({
        async start(controller) {
            for await (const chunk of responseStream) {
                const text = chunk.text;
                if (text) {
                    controller.enqueue(encoder.encode(text));
                }
            }
            controller.close();
        },
    });

    return stream;
}

--- END FILE: lib\gemini.ts ---

--- START FILE: lib\history.ts ---

// lib/history.ts
import { db, admin } from './firebaseAdmin'; 
import { Conversation, ChatMessage, Role, FileAttachment } from '@/types/chat'; 
import { v4 as uuidv4 } from 'uuid';

const CONVERSATIONS_COLLECTION = 'conversations';

// Define the stored structure (using number for timestamp)
interface FirestoreMessage {
    id: string;
    text: string;
    role: Role;
    timestamp: number;
    files?: FileAttachment[];
}

// Helper to generate a conversational title
function generateTitle(firstMessage: string): string {
    const words = firstMessage.split(/\s+/).slice(0, 6);
    let title = words.join(' ');
    if (words.length > 5) {
        title += '...';
    }
    return title || "New Chat";
}

/**
 * Retrieves a conversation by its ID.
 */
export async function getConversation(chatId: string, userId: string): Promise<Conversation | null> {
    const docRef = db.collection(CONVERSATIONS_COLLECTION).doc(chatId);
    const doc = await docRef.get();

    if (!doc.exists) {
        return null;
    }
    
    const data = doc.data() as Omit<Conversation, 'messages' | 'createdAt' | 'updatedAt'> & { 
        messages: FirestoreMessage[],
        createdAt: number,
        updatedAt: number,
    };

    // Security check: Ensure the conversation belongs to the authenticated user
    if (data.userId !== userId) {
        console.warn(`Access denied: User ${userId} attempted to access chat ${chatId} belonging to ${data.userId}`);
        return null;
    }
    
    const conversation: Conversation = {
        ...data,
        messages: data.messages.map(m => ({
            ...m,
            timestamp: new Date(m.timestamp), 
        })),
        createdAt: new Date(data.createdAt),
        updatedAt: new Date(data.updatedAt),
    };

    return conversation;
}

/**
 * Creates a new conversation and adds the first message.
 */
export async function createConversation(
    userId: string, 
    firstMessage: string, 
    files: FileAttachment[] = [],
    model?: string, // NEW PARAMETER
    systemPrompt?: string // NEW PARAMETER
): Promise<Conversation> {
    const chatId = uuidv4();
    const now = Date.now();
    
    const userMessage: ChatMessage = {
        id: uuidv4(),
        text: firstMessage,
        role: 'user' as Role,
        timestamp: now,
        files: files.length > 0 ? files : undefined,
    };

    const newConversation: Conversation = {
        id: chatId,
        userId,
        createdAt: now,
        updatedAt: now,
        title: generateTitle(firstMessage), 
        messages: [userMessage],
        // Use provided model/prompt, otherwise default
        model: model || 'gemini-2.5-flash-preview-09-2025', // <-- Adjusted default here too for safety
        systemPrompt: systemPrompt || undefined,
    };

    // Note: Firestore automatically converts Date objects if we use them, but we use numbers for consistency.
    await db.collection(CONVERSATIONS_COLLECTION).doc(chatId).set(newConversation);

    return newConversation;
}

/**
 * Appends a new user message and the subsequent AI response to an existing conversation.
 */
export async function updateConversation(
    chatId: string, 
    userText: string, 
    modelText: string,
    userId: string, // Require User ID for security
    files: FileAttachment[] = [],
    isFirstExchange: boolean = false
): Promise<void> {
    
    // First, verify access (optional, but good practice if not done upstream)
    const docRef = db.collection(CONVERSATIONS_COLLECTION).doc(chatId);
    const doc = await docRef.get();
    if (!doc.exists || doc.data()?.userId !== userId) {
        throw new Error("Unauthorized chat update attempt.");
    }
    
    const userMessage: ChatMessage = {
        id: uuidv4(),
        text: userText,
        role: 'user' as Role,
        timestamp: Date.now(),
        files: files.length > 0 ? files : undefined,
    };
    
    const modelMessage: ChatMessage = {
        id: uuidv4(),
        text: modelText,
        role: 'model' as Role,
        timestamp: Date.now(),
    };

    const updateData: { messages: admin.firestore.FieldValue; updatedAt: number; title?: string } = {
        messages: admin.firestore.FieldValue.arrayUnion(userMessage, modelMessage),
        updatedAt: Date.now(),
    };

    if (isFirstExchange) {
        // If it was the first exchange, we ensure the title is updated
        updateData.title = generateTitle(userText);
    }
    
    await docRef.update(updateData);
}

// New function to delete all chats for a user
export async function deleteAllUserConversations(userId: string): Promise<void> {
    const batch = db.batch();
    const snapshot = await db.collection(CONVERSATIONS_COLLECTION)
        .where('userId', '==', userId)
        .get();

    snapshot.docs.forEach(doc => {
        batch.delete(doc.ref);
    });

    await batch.commit();
}

--- END FILE: lib\history.ts ---

--- START FILE: lib\settings.ts ---

// lib/settings.ts
import { db } from './firebaseAdmin';
import { UserSettings } from '@/types/chat';

const SETTINGS_COLLECTION = 'user_settings';

const DEFAULT_SETTINGS: UserSettings = {
    userId: 'default', // Placeholder, replaced upon fetch/save
    globalModel: 'gemini-2.5-flash-preview-09-2025', // <-- UPDATED DEFAULT MODEL
    globalSystemPrompt: 'You are Big AI, a helpful and large-scale language model developed by Google. Respond concisely and professionally.',
}

/**
 * Retrieves the global settings for a user.
 */
export async function getSettings(userId: string): Promise<UserSettings> {
    const docRef = db.collection(SETTINGS_COLLECTION).doc(userId);
    const doc = await docRef.get();

    if (doc.exists) {
        return doc.data() as UserSettings;
    }

    // If no settings exist, return defaults
    return { ...DEFAULT_SETTINGS, userId };
}

/**
 * Saves or updates the global settings for a user.
 */
export async function saveSettings(userId: string, settings: Partial<UserSettings>): Promise<void> {
    const docRef = db.collection(SETTINGS_COLLECTION).doc(userId);
    
    // Ensure we only update allowed fields and set the userId
    const updatePayload = {
        ...settings,
        userId: userId,
    };

    await docRef.set(updatePayload, { merge: true });
}

--- END FILE: lib\settings.ts ---

--- START FILE: public\file.svg ---

<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

--- END FILE: public\file.svg ---

--- START FILE: public\globe.svg ---

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

--- END FILE: public\globe.svg ---

--- START FILE: public\next.svg ---

<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

--- END FILE: public\next.svg ---

--- START FILE: public\vercel.svg ---

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

--- END FILE: public\vercel.svg ---

--- START FILE: public\window.svg ---

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

--- END FILE: public\window.svg ---

--- START FILE: types\chat.ts ---

// types/chat.ts

export type Role = 'user' | 'model';

export interface FileAttachment {
    base64Data: string; // Base64 encoded file content
    mimeType: string;
    filename: string;
    size: number; // File size in bytes
}

export interface ChatMessage {
    id: string; // UUID for message
    text: string;
    role: Role;
    timestamp: Date | number; // Use number (milliseconds) for Firestore
    files?: FileAttachment[]; // NEW: Optional files sent with the message
}

export interface Conversation {
    id: string; // UUID for conversation
    userId: string; // Required when Auth is implemented
    createdAt: Date | number;
    updatedAt: Date | number;
    title: string;
    messages: ChatMessage[];
    // NEW: User settings configuration for this chat session
    model?: string;
    systemPrompt?: string;
}

// NEW: Global User Settings for the Settings Panel
export interface UserSettings {
    userId: string;
    globalModel: string;
    globalSystemPrompt: string;
}

export interface GeminiContent {
    role: 'user' | 'model';
    parts: { text: string }[]; // Updated to handle multiple parts (text/data)
}

--- END FILE: types\chat.ts ---

--- START FILE: utils\firebase.ts ---

// utils/firebase.ts
import { initializeApp, getApps, getApp } from 'firebase/app';
import { getFirestore } from 'firebase/firestore';
import { getAuth } from 'firebase/auth';

// Ensure all environment variables are present for client-side config
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,
};

// Initialize Firebase for Client Use
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();
export const db = getFirestore(app);
export const auth = getAuth(app);
// Expose the app instance if needed for context
export { app };


--- END FILE: utils\firebase.ts ---

-----------------------------------------------------------------------------

please check here some internal error is happening please fix that and send me the ready to go code.
