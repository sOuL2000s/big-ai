
--- START FILE: .gitignore ---

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
package-lock.json

--- END FILE: .gitignore ---

--- START FILE: eslint.config.mjs ---

import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;


--- END FILE: eslint.config.mjs ---

--- START FILE: netlify.toml ---

# Configuration file for Netlify deployment

[build]
  command = "npm run build"
  publish = ".next"

# Tell Netlify's secrets scanner to ignore the public Firebase keys
# These are necessary for the client-side application to work and are 
# intentionally exposed in the browser bundle.
[context.production.environment]
  SECRETS_SCAN_OMIT_KEYS = "NEXT_PUBLIC_FIREBASE_API_KEY,NEXT_PUBLIC_FIREBASE_APP_ID,NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,NEXT_PUBLIC_FIREBASE_PROJECT_ID,NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET"

# If you use the Netlify Next.js plugin, it usually handles redirects 
# and headers, but adding basic cache control is always good practice.
[[headers]]
  for = "/_next/static/*"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

--- END FILE: netlify.toml ---

--- START FILE: next-env.d.ts ---

/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


--- END FILE: next-env.d.ts ---

--- START FILE: next.config.ts ---

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


--- END FILE: next.config.ts ---

--- START FILE: package.json ---

{
  "name": "big-ai",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@google/genai": "^1.31.0",
    "@types/uuid": "^11.0.0",
    "firebase": "^12.6.0",
    "firebase-admin": "^13.6.0",
    "next": "16.0.7",
    "react": "19.2.1",
    "react-dom": "19.2.1",
    "uuid": "^13.0.0",
    "marked": "^17.0.1",
    "dompurify": "^3.3.0",
    "prismjs": "^1.30.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^24",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/dompurify": "^3.2.0",
    "@types/prismjs": "^1.26.5",
    "eslint": "^9",
    "eslint-config-next": "16.0.7",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}


--- END FILE: package.json ---

--- START FILE: postcss.config.mjs ---

const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;


--- END FILE: postcss.config.mjs ---

--- START FILE: README.md ---

websiet link : https://big-ai-chatbot.netlify.app/

--- END FILE: README.md ---

--- START FILE: tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}


--- END FILE: tsconfig.json ---

--- START FILE: app\globals.css ---

/* app/globals.css */
@import "tailwindcss";

/* Import PrismJS themes */
@import 'prismjs/themes/prism-tomorrow.css'; /* Using 'tomorrow' for a modern, sleek dark look */

/*
 * ===================================================================
 * --- 1. CORE DEFAULT VARIABLES (BASE FALLBACK - Light Mode) ---
 * ===================================================================
 */
:root {
  --bg-primary: #f3f4f6;
  --bg-secondary: #ffffff;
  --text-primary: #1f2937;
  --text-secondary: #4b5563;
  --border-color: #e5e7eb;
  --card-bg: #ffffff;
  --card-border: #e5e7eb;
  --header-bg: #f9fafb;
  --accent-primary: #2563eb; /* blue-600 */
  --accent-primary-hover: #1d4ed8; /* blue-700 */
  --accent-secondary: #fcd34d; /* amber-300 */
  --accent-error: #ef4444; /* red-500 */
  --accent-success: #22c55e; /* green-500 */
  --user-bubble-bg: #bfdbfe; /* blue-200 */
  --user-bubble-text: #1e40af; /* blue-700 */
  --ai-bubble-bg: #f3f4f6; /* gray-100 */
  --ai-bubble-text: #374151; /* gray-700 */
  --sidebar-bg: #ffffff;
  --sidebar-border: #e5e7eb;
  --sidebar-item-hover: #f3f4f6;
  --loader-dot-color: var(--accent-primary);
  --code-block-bg: #f5f7fa;
  --code-block-header-bg: #e8ebf0;
  --code-block-border: #e2e4e8;
  --conversation-indicator: var(--accent-primary);
  --main-chat-window-bg: rgba(255, 255, 255, 0.8);
  --conversation-bg: rgba(255, 255, 255, 0.95);
  --conversation-text: #1f2937;
}

/*
 * --- Default Dark Mode (System & Fallback) ---
 * Applies if data-theme ends in -dark OR if system preference is dark.
 */
[data-theme$="-dark"] {
  /* This block should apply specifically to the element with the data-theme attribute */
  --bg-primary: #0a0a0a;
  --bg-secondary: #171717;
  --text-primary: #e5e7eb;
  --text-secondary: #a1a1aa;
  --border-color: #2d3748;
  --card-bg: #1f2937;
  --card-border: #2d3748;
  --header-bg: #1f2937;
  --accent-primary: #60a5fa;
  --accent-primary-hover: #3b82f6;
  --accent-secondary: #fcd34d;
  --accent-error: #f87171;
  --accent-success: #4ade80;
  --user-bubble-bg: #1e3a8a;
  --user-bubble-text: #e0f2fe;
  --ai-bubble-bg: #374151;
  --ai-bubble-text: #f9fafb;
  --sidebar-bg: #0a0a0a;
  --sidebar-border: #2d3748;
  --sidebar-item-hover: #171717;
  --code-block-bg: #1f2937;
  --code-block-header-bg: #171717;
  --code-block-border: #2d3748;
  --main-chat-window-bg: rgba(19, 19, 26, 0.9);
  --conversation-bg: rgba(19, 19, 26, 0.95);
  --conversation-text: #e5e7eb;
  --conversation-indicator: #818cf8;
}

@media (prefers-color-scheme: dark) {
  /* This ensures system dark mode preference is respected when data-theme is not set */
  :root {
    --bg-primary: #0a0a0a;
    --bg-secondary: #171717;
    --text-primary: #e5e7eb;
    --text-secondary: #a1a1aa;
    --border-color: #2d3748;
    --card-bg: #1f2937;
    --card-border: #2d3748;
    --header-bg: #1f2937;
    --accent-primary: #60a5fa;
    --accent-primary-hover: #3b82f6;
    --accent-secondary: #fcd34d;
    --accent-error: #f87171;
    --accent-success: #4ade80;
    --user-bubble-bg: #1e3a8a;
    --user-bubble-text: #e0f2fe;
    --ai-bubble-bg: #374151;
    --ai-bubble-text: #f9fafb;
    --sidebar-bg: #0a0a0a;
    --sidebar-border: #2d3748;
    --sidebar-item-hover: #171717;
    --code-block-bg: #1f2937;
    --code-block-header-bg: #171717;
    --code-block-border: #2d3748;
    --main-chat-window-bg: rgba(19, 19, 26, 0.9);
    --conversation-bg: rgba(19, 19, 26, 0.95);
    --conversation-text: #e5e7eb;
    --conversation-indicator: #818cf8;
  }
}

/*
 * ===================================================================
 * --- 2. EXPLICIT THEME DEFINITIONS (Overrides Defaults) ---
 * ===================================================================
 */

/* Default Theme: Light Mode */
[data-theme="default-light"] {
    --bg-primary: #f3f4f6;
    --bg-secondary: #ffffff;
    --text-primary: #1f2937;
    --text-secondary: #4b5563;
    --border-color: #e5e7eb;
    --card-bg: #ffffff;
    --card-border: #e5e7eb;
    --header-bg: #f9fafb;
    --accent-primary: #6366f1;
    --accent-primary-hover: #4f46e5;
    --accent-secondary: #22d3ee;
    --accent-error: #ef4444;
    --accent-success: #22c55e;
    --user-bubble-bg: #e0f2fe;
    --user-bubble-text: #1e40af;
    --ai-bubble-bg: #f3f4f6;
    --ai-bubble-text: #374151;
    --sidebar-bg: #ffffff;
    --sidebar-border: #e5e7eb;
    --sidebar-item-hover: #f3f4f6;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #1f2937;
    --conversation-indicator: #6366f1;
    --code-block-bg: #e8ebf0;
    --code-block-header-bg: #e8ebf0;
    --code-block-border: #e2e4e8;
}

/* Default Theme: Dark Mode */
[data-theme="default-dark"] {
    --bg-primary: #0a0a0f;
    --bg-secondary: #13131a;
    --text-primary: #e5e7eb;
    --text-secondary: #a1a1aa;
    --border-color: #2d3748;
    --card-bg: #13131a;
    --card-border: #2d3748;
    --header-bg: #1f2937;
    --accent-primary: #818cf8;
    --accent-primary-hover: #6366f1;
    --accent-secondary: #67e8f9;
    --accent-error: #f87171;
    --accent-success: #4ade80;
    --user-bubble-bg: #1a237e;
    --user-bubble-text: #e0e7ff;
    --ai-bubble-bg: #2d3748;
    --ai-bubble-text: #f9fafb;
    --sidebar-bg: #13131a;
    --sidebar-border: #2d3748;
    --sidebar-item-hover: #1f2937;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(19, 19, 26, 0.9);
    --conversation-bg: rgba(19, 19, 26, 0.95);
    --conversation-text: #e5e7eb;
    --conversation-indicator: #818cf8;
    --code-block-bg: #13131a;
    --code-block-header-bg: #13131a;
    --code-block-border: #2d3748;
}

/* Celestial Horizon Theme: Dark Mode */
[data-theme="celestial-horizon-dark"] {
    --bg-primary: #0D1117;
    --bg-secondary: #161B22;
    --text-primary: #C9D1D9;
    --text-secondary: #8B949E;
    --border-color: #30363D;
    --card-bg: #1F2633;
    --card-border: #30363D;
    --header-bg: #161B22;
    --accent-primary: #58A6FF;
    --accent-primary-hover: #388BF2;
    --accent-secondary: #B1B8C1;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #253B64;
    --user-bubble-text: #E0F2FE;
    --ai-bubble-bg: #1F2633;
    --ai-bubble-text: #C9D1D9;
    --sidebar-bg: #161B22;
    --sidebar-border: #30363D;
    --sidebar-item-hover: #1F2633;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(22, 27, 34, 0.9);
    --conversation-bg: rgba(22, 27, 34, 0.95);
    --conversation-text: #C9D1D9;
    --conversation-indicator: #58A6FF;
    --code-block-bg: #161B22;
    --code-block-header-bg: #161B22;
    --code-block-border: #30363D;
}

/* Celestial Horizon Theme: Light Mode */
[data-theme="celestial-horizon-light"] {
    --bg-primary: #F0F4F8;
    --bg-secondary: #FFFFFF;
    --text-primary: #2D3748;
    --text-secondary: #718096;
    --border-color: #E2E8F0;
    --card-bg: #FFFFFF;
    --card-border: #E2E8F0;
    --header-bg: #EDF2F7;
    --accent-primary: #3B82F6;
    --accent-primary-hover: #2563EB;
    --accent-secondary: #60A5FA;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #DBEAFE;
    --user-bubble-text: #1E40AF;
    --ai-bubble-bg: #EBF4FF;
    --ai-bubble-text: #2D3748;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E2E8F0;
    --sidebar-item-hover: #F0F4F8;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2D3748;
    --conversation-indicator: #3B82F6;
    --code-block-bg: #EDF2F7;
    --code-block-header-bg: #EDF2F7;
    --code-block-border: #E2E8F0;
}

/* Verdant Calm Theme: Dark Mode */
[data-theme="verdant-calm-dark"] {
    --bg-primary: #1a2a22;
    --bg-secondary: #21362d;
    --text-primary: #e0f2e8;
    --text-secondary: #99bbaa;
    --border-color: #3f544c;
    --card-bg: #294237;
    --card-border: #4a6356;
    --header-bg: #2c493c;
    --accent-primary: #3cb878;
    --accent-primary-hover: #2fa163;
    --accent-secondary: #60c58e;
    --accent-error: #f87171;
    --accent-success: #4ade80;
    --user-bubble-bg: #1e8449;
    --user-bubble-text: #e0f2e8;
    --ai-bubble-bg: #34495e;
    --ai-bubble-text: #e0f2e8;
    --sidebar-bg: #21362d;
    --sidebar-border: #3f544c;
    --sidebar-item-hover: #2c493c;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(33, 54, 45, 0.9);
    --conversation-bg: rgba(33, 54, 45, 0.95);
    --conversation-text: #e0f2e8;
    --conversation-indicator: #3cb878;
    --code-block-bg: #2c493c;
    --code-block-header-bg: #2c493c;
    --code-block-border: #3f544c;
}

/* Verdant Calm Theme: Light Mode */
[data-theme="verdant-calm-light"] {
    --bg-primary: #edf9f5;
    --bg-secondary: #ffffff;
    --text-primary: #2d3f35;
    --text-secondary: #5e7d6b;
    --border-color: #dbeae5;
    --card-bg: #ffffff;
    --card-border: #dbeae5;
    --header-bg: #f5fcf9;
    --accent-primary: #3cb878;
    --accent-primary-hover: #2fa163;
    --accent-secondary: #60c58e;
    --accent-error: #ef4444;
    --accent-success: #22c55e;
    --user-bubble-bg: #c8e6c9;
    --user-bubble-text: #1b5e20;
    --ai-bubble-bg: #e8f5e9;
    --ai-bubble-text: #388e3c;
    --sidebar-bg: #ffffff;
    --sidebar-border: #dbeae5;
    --sidebar-item-hover: #edf9f5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2d3f35;
    --conversation-indicator: #3cb878;
    --code-block-bg: #f5fcf9;
    --code-block-header-bg: #f5fcf9;
    --code-block-border: #dbeae5;
}

/* Cybernetic Pulse Theme: Dark Mode */
[data-theme="cybernetic-pulse-dark"] {
    --bg-primary: #0a0e1a;
    --bg-secondary: #161c28;
    --text-primary: #e2e8f0;
    --text-secondary: #94a3b8;
    --border-color: #2f3e52;
    --card-bg: #1f2a3a;
    --card-border: #3a4b5e;
    --header-bg: #1f2a3a;
    --accent-primary: #0ea5e9;
    --accent-primary-hover: #0284c7;
    --accent-secondary: #38bdf8;
    --accent-error: #f87171;
    --accent-success: #4ade80;
    --user-bubble-bg: #0c4a6e;
    --user-bubble-text: #e0f2fe;
    --ai-bubble-bg: #2d3748;
    --ai-bubble-text: #f0f8ff;
    --sidebar-bg: #161c28;
    --sidebar-border: #2f3e52;
    --sidebar-item-hover: #1f2a3a;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(22, 28, 40, 0.9);
    --conversation-bg: rgba(22, 28, 40, 0.95);
    --conversation-text: #e2e8f0;
    --conversation-indicator: #0ea5e9;
    --code-block-bg: #1f2a3a;
    --code-block-header-bg: #1f2a3a;
    --code-block-border: #2f3e52;
}

/* Cybernetic Pulse Theme: Light Mode */
[data-theme="cybernetic-pulse-light"] {
    --bg-primary: #f8fafc;
    --bg-secondary: #ffffff;
    --text-primary: #1e293b;
    --text-secondary: #475569;
    --border-color: #e0e7f2;
    --card-bg: #ffffff;
    --card-border: #e0e7f2;
    --header-bg: #f1f5f9;
    --accent-primary: #0ea5e9;
    --accent-primary-hover: #0284c7;
    --accent-secondary: #38bdf8;
    --accent-error: #ef4444;
    --accent-success: #22c55e;
    --user-bubble-bg: #bfdbfe;
    --user-bubble-text: #1e3a8a;
    --ai-bubble-bg: #e0f2fe;
    --ai-bubble-text: #0284c7;
    --sidebar-bg: #ffffff;
    --sidebar-border: #e0e7f2;
    --sidebar-item-hover: #f1f5f9;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #1e293b;
    --conversation-indicator: #0ea5e9;
    --code-block-bg: #f1f5f9;
    --code-block-header-bg: #f1f5f9;
    --code-block-border: #e0e7f2;
}

/* Urban Pulse Theme: Dark Mode */
[data-theme="urban-pulse-dark"] {
    --bg-primary: #1A1A1D;
    --bg-secondary: #242426;
    --text-primary: #F0F0F0;
    --text-secondary: #A0A0A0;
    --border-color: #38383B;
    --card-bg: #242426;
    --card-border: #38383B;
    --header-bg: #1A1A1D;
    --accent-primary: #00BFFF;
    --accent-primary-hover: #009ACD;
    --accent-secondary: #66CCFF;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #0F4C81;
    --user-bubble-text: #E0FFFF;
    --ai-bubble-bg: #36454F;
    --ai-bubble-text: #F0F0F0;
    --sidebar-bg: #1A1A1D;
    --sidebar-border: #38383B;
    --sidebar-item-hover: #242426;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(36, 36, 38, 0.9);
    --conversation-bg: rgba(36, 36, 38, 0.95);
    --conversation-text: #F0F0F0;
    --conversation-indicator: #00BFFF;
    --code-block-bg: #1A1A1D;
    --code-block-header-bg: #1A1A1D;
    --code-block-border: #38383B;
}

/* Urban Pulse Theme: Light Mode */
[data-theme="urban-pulse-light"] {
    --bg-primary: #F2F4F8;
    --bg-secondary: #FFFFFF;
    --text-primary: #333333;
    --text-secondary: #777777;
    --border-color: #DDE2E8;
    --card-bg: #FFFFFF;
    --card-border: #DDE2E8;
    --header-bg: #E8ECF2;
    --accent-primary: #1E90FF;
    --accent-primary-hover: #107EEB;
    --accent-secondary: #63B2FF;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #CCE5FF;
    --user-bubble-text: #003F8C;
    --ai-bubble-bg: #E8F0F5;
    --ai-bubble-text: #333333;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #DDE2E8;
    --sidebar-item-hover: #E8F0F5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #333333;
    --conversation-indicator: #1E90FF;
    --code-block-bg: #E8ECF2;
    --code-block-header-bg: #E8ECF2;
    --code-block-border: #DDE2E8;
}

/* Rustic Ember Theme: Dark Mode */
[data-theme="rustic-ember-dark"] {
    --bg-primary: #3E2723;
    --bg-secondary: #4E342E;
    --text-primary: #FBE9E7;
    --text-secondary: #BCAAA4;
    --border-color: #5D4037;
    --card-bg: #4E342E;
    --card-border: #5D4037;
    --header-bg: #3E2723;
    --accent-primary: #D84315;
    --accent-primary-hover: #BF360C;
    --accent-secondary: #FF8A65;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #8D6E63;
    --user-bubble-text: #FBE9E7;
    --ai-bubble-bg: #5D4037;
    --ai-bubble-text: #FBE9E7;
    --sidebar-bg: #3E2723;
    --sidebar-border: #5D4037;
    --sidebar-item-hover: #4E342E;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(78, 52, 46, 0.9);
    --conversation-bg: rgba(78, 52, 46, 0.95);
    --conversation-text: #FBE9E7;
    --conversation-indicator: #D84315;
    --code-block-bg: #3E2723;
    --code-block-header-bg: #3E2723;
    --code-block-border: #5D4037;
}

/* Rustic Ember Theme: Light Mode */
[data-theme="rustic-ember-light"] {
    --bg-primary: #F5E8DC;
    --bg-secondary: #FFFFFF;
    --text-primary: #4E342E;
    --text-secondary: #8D6E63;
    --border-color: #E6DCCD;
    --card-bg: #FFFFFF;
    --card-border: #E6DCCD;
    --header-bg: #F8EFE5;
    --accent-primary: #E65100;
    --accent-primary-hover: #D84315;
    --accent-secondary: #FFB74D;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #FFCCBC;
    --user-bubble-text: #BF360C;
    --ai-bubble-bg: #FBE9E7;
    --ai-bubble-text: #4E342E;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E6DCCD;
    --sidebar-item-hover: #F8EFE5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #4E342E;
    --conversation-indicator: #E65100;
    --code-block-bg: #F8EFE5;
    --code-block-header-bg: #F8EFE5;
    --code-block-border: #E6DCCD;
}

/* Neon Mirage Theme: Dark Mode */
[data-theme="neon-mirage-dark"] {
    --bg-primary: #05001C;
    --bg-secondary: #120033;
    --text-primary: #E0FFFF;
    --text-secondary: #8A2BE2;
    --border-color: #2F004F;
    --card-bg: #1A0040;
    --card-border: #2F004F;
    --header-bg: #120033;
    --accent-primary: #FF1493;
    --accent-primary-hover: #C7007C;
    --accent-secondary: #00BFFF;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #4B0082;
    --user-bubble-text: #E0FFFF;
    --ai-bubble-bg: #2E0854;
    --ai-bubble-text: #E0FFFF;
    --sidebar-bg: #120033;
    --sidebar-border: #2F004F;
    --sidebar-item-hover: #1A0040;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(26, 0, 64, 0.9);
    --conversation-bg: rgba(26, 0, 64, 0.95);
    --conversation-text: #E0FFFF;
    --conversation-indicator: #FF1493;
    --code-block-bg: #120033;
    --code-block-header-bg: #120033;
    --code-block-border: #2F004F;
}

/* Neon Mirage Theme: Light Mode */
[data-theme="neon-mirage-light"] {
    --bg-primary: #F8F0FF;
    --bg-secondary: #FFFFFF;
    --text-primary: #330066;
    --text-secondary: #663399;
    --border-color: #EBD9FC;
    --card-bg: #FFFFFF;
    --card-border: #EBD9FC;
    --header-bg: #F2E0FF;
    --accent-primary: #FF69B4;
    --accent-primary-hover: #E0509B;
    --accent-secondary: #87CEEB;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #FCE4EC;
    --user-bubble-text: #C2185B;
    --ai-bubble-bg: #F3E5F5;
    --ai-bubble-text: #330066;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #EBD9FC;
    --sidebar-item-hover: #F2E0FF;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #330066;
    --conversation-indicator: #FF69B4;
    --code-block-bg: #F2E0FF;
    --code-block-header-bg: #F2E0FF;
    --code-block-border: #EBD9FC;
}

/* Ivory Bloom Theme: Dark Mode */
[data-theme="ivory-bloom-dark"] {
    --bg-primary: #2B2D42;
    --bg-secondary: #4A4E69;
    --text-primary: #DCDCDC;
    --text-secondary: #A0A4B8;
    --border-color: #5D607E;
    --card-bg: #4A4E69;
    --card-border: #5D607E;
    --header-bg: #373A50;
    --accent-primary: #9B59B6;
    --accent-primary-hover: #8E44AD;
    --accent-secondary: #66CCFF;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #7C4F9B;
    --user-bubble-text: #FFFFFF;
    --ai-bubble-bg: #5D607E;
    --ai-bubble-text: #DCDCDC;
    --sidebar-bg: #2B2D42;
    --sidebar-border: #5D607E;
    --sidebar-item-hover: #373A50;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(74, 78, 105, 0.9);
    --conversation-bg: rgba(74, 78, 105, 0.95);
    --conversation-text: #DCDCDC;
    --conversation-indicator: #9B59B6;
    --code-block-bg: #373A50;
    --code-block-header-bg: #373A50;
    --code-block-border: #5D607E;
}

/* Ivory Bloom Theme: Light Mode */
[data-theme="ivory-bloom-light"] {
    --bg-primary: #FDFDFD;
    --bg-secondary: #FFFFFF;
    --text-primary: #333333;
    --text-secondary: #777777;
    --border-color: #EAEAEA;
    --card-bg: #FFFFFF;
    --card-border: #EAEAEA;
    --header-bg: #F5F5F5;
    --accent-primary: #8E44AD;
    --accent-primary-hover: #7F3C9E;
    --accent-secondary: #BA68C8;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #F2E6F7;
    --user-bubble-text: #5D2C7B;
    --ai-bubble-bg: #EAE0F0;
    --ai-bubble-text: #333333;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #EAEAEA;
    --sidebar-item-hover: #F5F5F5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #333333;
    --conversation-indicator: #8E44AD;
    --code-block-bg: #F5F5F5;
    --code-block-header-bg: #F5F5F5;
    --code-block-border: #EAEAEA;
}

/* Obsidian Night Theme: Dark Mode */
[data-theme="obsidian-night-dark"] {
    --bg-primary: #121212;
    --bg-secondary: #1E1E1E;
    --text-primary: #F0F0F0;
    --text-secondary: #A0A0A0;
    --border-color: #333333;
    --card-bg: #1E1E1E;
    --card-border: #333333;
    --header-bg: #121212;
    --accent-primary: #BB86FC;
    --accent-primary-hover: #9E65E2;
    --accent-secondary: #03DAC6;
    --accent-error: #CF6679;
    --accent-success: #03DAC6;
    --user-bubble-bg: #3700B3;
    --user-bubble-text: #FFFFFF;
    --ai-bubble-bg: #2C2C2C;
    --ai-bubble-text: #F0F0F0;
    --sidebar-bg: #121212;
    --sidebar-border: #333333;
    --sidebar-item-hover: #1E1E1E;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(30, 30, 30, 0.9);
    --conversation-bg: rgba(30, 30, 30, 0.95);
    --conversation-text: #F0F0F0;
    --conversation-indicator: #BB86FC;
    --code-block-bg: #121212;
    --code-block-header-bg: #121212;
    --code-block-border: #333333;
}

/* Obsidian Night Theme: Light Mode */
[data-theme="obsidian-night-light"] {
    --bg-primary: #E0E0E0;
    --bg-secondary: #FFFFFF;
    --text-primary: #2C2C2C;
    --text-secondary: #6B6B6B;
    --border-color: #C0C0C0;
    --card-bg: #FFFFFF;
    --card-border: #C0C0C0;
    --header-bg: #D0D0D0;
    --accent-primary: #6200EE;
    --accent-primary-hover: #5B00D9;
    --accent-secondary: #018786;
    --accent-error: #B00020;
    --accent-success: #018786;
    --user-bubble-bg: #BBDEFB;
    --user-bubble-text: #1A237E;
    --ai-bubble-bg: #E0E0E0;
    --ai-bubble-text: #2C2C2C;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #C0C0C0;
    --sidebar-item-hover: #D0D0D0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2C2C2C;
    --conversation-indicator: #6200EE;
    --code-block-bg: #D0D0D0;
    --code-block-header-bg: #D0D0D0;
    --code-block-border: #C0C0C0;
}

/* Solar Dawn Theme: Dark Mode */
[data-theme="solar-dawn-dark"] {
    --bg-primary: #1A0E2A;
    --bg-secondary: #2C1840;
    --text-primary: #FCE8D8;
    --text-secondary: #D8BFD8;
    --border-color: #40265B;
    --card-bg: #2C1840;
    --card-border: #40265B;
    --header-bg: #1A0E2A;
    --accent-primary: #FF5722;
    --accent-primary-hover: #E64A19;
    --accent-secondary: #FFCC80;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #7C4F9B;
    --user-bubble-text: #FCE8D8;
    --ai-bubble-bg: #40265B;
    --ai-bubble-text: #FCE8D8;
    --sidebar-bg: #1A0E2A;
    --sidebar-border: #40265B;
    --sidebar-item-hover: #2C1840;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(44, 24, 64, 0.9);
    --conversation-bg: rgba(44, 24, 64, 0.95);
    --conversation-text: #FCE8D8;
    --conversation-indicator: #FF5722;
    --code-block-bg: #1A0E2A;
    --code-block-header-bg: #1A0E2A;
    --code-block-border: #40265B;
}

/* Solar Dawn Theme: Light Mode */
[data-theme="solar-dawn-light"] {
    --bg-primary: #FFFBEA;
    --bg-secondary: #FFFFFF;
    --text-primary: #3E2723;
    --text-secondary: #8D6E63;
    --border-color: #FFE0B2;
    --card-bg: #FFFFFF;
    --card-border: #FFE0B2;
    --header-bg: #FFF3E0;
    --accent-primary: #FF8F00;
    --accent-primary-hover: #FF6F00;
    --accent-secondary: #FFD54F;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #FFE0B2;
    --user-bubble-text: #E65100;
    --ai-bubble-bg: #FFF3E0;
    --ai-bubble-text: #3E2723;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #FFE0B2;
    --sidebar-item-hover: #FFF3E0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #3E2723;
    --conversation-indicator: #FF8F00;
    --code-block-bg: #FFFBEA;
    --code-block-header-bg: #FFFBEA;
    --code-block-border: #FFE0B2;
}

/* Aurora Drift Theme: Dark Mode */
[data-theme="aurora-drift-dark"] {
    --bg-primary: #0A192F;
    --bg-secondary: #172A45;
    --text-primary: #E6F0FF;
    --text-secondary: #A0B3D6;
    --border-color: #2F476D;
    --card-bg: #172A45;
    --card-border: #2F476D;
    --header-bg: #0A192F;
    --accent-primary: #66CCCC;
    --accent-primary-hover: #55B3B3;
    --accent-secondary: #99CCFF;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #336699;
    --user-bubble-text: #E6F0FF;
    --ai-bubble-bg: #2F476D;
    --ai-bubble-text: #E6F0FF;
    --sidebar-bg: #0A192F;
    --sidebar-border: #2F476D;
    --sidebar-item-hover: #172A45;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(23, 42, 69, 0.9);
    --conversation-bg: rgba(23, 42, 69, 0.95);
    --conversation-text: #E6F0FF;
    --conversation-indicator: #66CCCC;
    --code-block-bg: #0A192F;
    --code-block-header-bg: #0A192F;
    --code-block-border: #2F476D;
}

/* Aurora Drift Theme: Light Mode */
[data-theme="aurora-drift-light"] {
    --bg-primary: #E0F2F7;
    --bg-secondary: #FFFFFF;
    --text-primary: #2B4550;
    --text-secondary: #5E7A8A;
    --border-color: #B2EBF2;
    --card-bg: #FFFFFF;
    --card-border: #B2EBF2;
    --header-bg: #CCEEF0;
    --accent-primary: #00BCD4;
    --accent-primary-hover: #00ACC1;
    --accent-secondary: #4DD0E1;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #B2EBF2;
    --user-bubble-text: #006064;
    --ai-bubble-bg: #CCEEF0;
    --ai-bubble-text: #2B4550;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #B2EBF2;
    --sidebar-item-hover: #CCEEF0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2B4550;
    --conversation-indicator: #00BCD4;
    --code-block-bg: #E0F2F7;
    --code-block-header-bg: #E0F2F7;
    --code-block-border: #B2EBF2;
}

/* Timeless Echo Theme: Dark Mode */
[data-theme="timeless-echo-dark"] {
    --bg-primary: #2C2C2C;
    --bg-secondary: #3D3D3D;
    --text-primary: #E0E0E0;
    --text-secondary: #B0B0B0;
    --border-color: #555555;
    --card-bg: #3D3D3D;
    --card-border: #555555;
    --header-bg: #2C2C2C;
    --accent-primary: #A57C52;
    --accent-primary-hover: #8B653D;
    --accent-secondary: #C8A87C;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #785A3D;
    --user-bubble-text: #E0E0E0;
    --ai-bubble-bg: #555555;
    --ai-bubble-text: #E0E0E0;
    --sidebar-bg: #2C2C2C;
    --sidebar-border: #555555;
    --sidebar-item-hover: #3D3D3D;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(61, 61, 61, 0.9);
    --conversation-bg: rgba(61, 61, 61, 0.95);
    --conversation-text: #E0E0E0;
    --conversation-indicator: #A57C52;
    --code-block-bg: #2C2C2C;
    --code-block-header-bg: #2C2C2C;
    --code-block-border: #555555;
}

/* Timeless Echo Theme: Light Mode */
[data-theme="timeless-echo-light"] {
    --bg-primary: #FDF7E5;
    --bg-secondary: #FFFFFF;
    --text-primary: #4A4A4A;
    --text-secondary: #808080;
    --border-color: #E6E0D3;
    --card-bg: #FFFFFF;
    --card-border: #E6E0D3;
    --header-bg: #F5EFEB;
    --accent-primary: #8D6E63;
    --accent-primary-hover: #795548;
    --accent-secondary: #BCAAA4;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #D7CCC8;
    --user-bubble-text: #5D4037;
    --ai-bubble-bg: #EFEBE9;
    --ai-bubble-text: #4A4A4A;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E6E0D3;
    --sidebar-item-hover: #F5EFEB;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #4A4A4A;
    --conversation-indicator: #8D6E63;
    --code-block-bg: #F5EFEB;
    --code-block-header-bg: #F5EFEB;
    --code-block-border: #E6E0D3;
}

/* Mystic Void Theme: Dark Mode */
[data-theme="mystic-void-dark"] {
    --bg-primary: #110B1D;
    --bg-secondary: #1F1731;
    --text-primary: #ECE4F7;
    --text-secondary: #B29BCE;
    --border-color: #372A4F;
    --card-bg: #1F1731;
    --card-border: #372A4F;
    --header-bg: #110B1D;
    --accent-primary: #9400D3;
    --accent-primary-hover: #7B00B0;
    --accent-secondary: #8A2BE2;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #5B2C7B;
    --user-bubble-text: #ECE4F7;
    --ai-bubble-bg: #372A4F;
    --ai-bubble-text: #ECE4F7;
    --sidebar-bg: #110B1D;
    --sidebar-border: #372A4F;
    --sidebar-item-hover: #1F1731;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(31, 23, 49, 0.9);
    --conversation-bg: rgba(31, 23, 49, 0.95);
    --conversation-text: #ECE4F7;
    --conversation-indicator: #9400D3;
    --code-block-bg: #110B1D;
    --code-block-header-bg: #110B1D;
    --code-block-border: #372A4F;
}

/* Mystic Void Theme: Light Mode */
[data-theme="mystic-void-light"] {
    --bg-primary: #F7EDFF;
    --bg-secondary: #FFFFFF;
    --text-primary: #330066;
    --text-secondary: #663399;
    --border-color: #EBD9FC;
    --card-bg: #FFFFFF;
    --card-border: #EBD9FC;
    --header-bg: #F2E0FF;
    --accent-primary: #8A2BE2;
    --accent-primary-hover: #7B1FB2;
    --accent-secondary: #9370DB;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #E6D2F2;
    --user-bubble-text: #4B0082;
    --ai-bubble-bg: #F0E6F8;
    --ai-bubble-text: #330066;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #EBD9FC;
    --sidebar-item-hover: #F2E0FF;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #330066;
    --conversation-indicator: #8A2BE2;
    --code-block-bg: #F2E0FF;
    --code-block-header-bg: #F2E0FF;
    --code-block-border: #EBD9FC;
}

/* Darkest Black & White Theme: Dark Mode */
[data-theme="darkest-bw-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #111111;
    --text-primary: #FFFFFF;
    --text-secondary: #AAAAAA;
    --border-color: #333333;
    --card-bg: #111111;
    --card-border: #333333;
    --header-bg: #0A0A0A;
    --accent-primary: #E0E0E0;
    --accent-primary-hover: #FFFFFF;
    --accent-secondary: #888888;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #222222;
    --user-bubble-text: #FFFFFF;
    --ai-bubble-bg: #333333;
    --ai-bubble-text: #FFFFFF;
    --sidebar-bg: #000000;
    --sidebar-border: #333333;
    --sidebar-item-hover: #111111;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: #000000;
    --conversation-bg: #000000;
    --conversation-text: #FFFFFF;
    --conversation-indicator: #FFFFFF;
    --code-block-bg: #0A0A0A;
    --code-block-header-bg: #0A0A0A;
    --code-block-border: #333333;
}

/* Darkest Black & White Theme: Light Mode */
[data-theme="darkest-bw-light"] {
    --bg-primary: #FFFFFF;
    --bg-secondary: #F0F0F0;
    --text-primary: #000000;
    --text-secondary: #555555;
    --border-color: #DDDDDD;
    --card-bg: #F0F0F0;
    --card-border: #DDDDDD;
    --header-bg: #F5F5F5;
    --accent-primary: #333333;
    --accent-primary-hover: #000000;
    --accent-secondary: #777777;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #EEEEEE;
    --user-bubble-text: #000000;
    --ai-bubble-bg: #DDDDDD;
    --ai-bubble-text: #000000;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #DDDDDD;
    --sidebar-item-hover: #F0F0F0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: #F0F0F0;
    --conversation-bg: #FFFFFF;
    --conversation-text: #000000;
    --conversation-indicator: #000000;
    --code-block-bg: #F5F5F5;
    --code-block-header-bg: #F5F5F5;
    --code-block-border: #DDDDDD;
}

/* Coder's Dark Theme */
[data-theme="coder-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #0A0A0A;
    --text-primary: #00BCD4;
    --text-secondary: #8B949E;
    --border-color: #30363D;
    --card-bg: #0A0A0A;
    --card-border: #30363D;
    --header-bg: #000000;
    --accent-primary: #00BCD4;
    --accent-primary-hover: #0097A7;
    --accent-secondary: #8A2BE2;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #2C3E50;
    --user-bubble-text: #E0E0E0;
    --ai-bubble-bg: #1A1A1A;
    --ai-bubble-text: #E0E0E0;
    --sidebar-bg: #000000;
    --sidebar-border: #30363D;
    --sidebar-item-hover: #0A0A0A;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #00BCD4;
    --conversation-indicator: #00BCD4;
    --code-block-bg: #27272A;
    --code-block-header-bg: #27272A;
    --code-block-border: #3F3F46;
}

/* Coder's Light Theme */
[data-theme="coder-light"] {
    --bg-primary: #F0F2F5;
    --bg-secondary: #FFFFFF;
    --text-primary: #008C9D;
    --text-secondary: #718096;
    --border-color: #DDE2E8;
    --card-bg: #FFFFFF;
    --card-border: #DDE2E8;
    --header-bg: #E8EDF2;
    --accent-primary: #008C9D;
    --accent-primary-hover: #006D7D;
    --accent-secondary: #6A1B9A;
    --accent-error: #D32F2F;
    --accent-success: #388E3C;
    --user-bubble-bg: #E0F7FA;
    --user-bubble-text: #004D40;
    --ai-bubble-bg: #F0F4F8;
    --ai-bubble-text: #2C2C30;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #DDE2E8;
    --sidebar-item-hover: #F0F2F5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #004D40;
    --conversation-indicator: #008C9D;
    --code-block-bg: #ECEFF1;
    --code-block-header-bg: #ECEFF1;
    --code-block-border: #CFD8DC;
}

/* Cyberpunk Theme: Dark Mode */
[data-theme="cyberpunk-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #1A0F24;
    --text-primary: #00FFFF;
    --text-secondary: #A08AB2;
    --border-color: #3A1D4D;
    --card-bg: #1A0F24;
    --card-border: #3A1D4D;
    --header-bg: #0A050F;
    --accent-primary: #00FFFF;
    --accent-primary-hover: #00CED1;
    --accent-secondary: #FF1493;
    --accent-error: #FF4500;
    --accent-success: #32CD32;
    --user-bubble-bg: #3A204D;
    --user-bubble-text: #E0E0E0;
    --ai-bubble-bg: #100814;
    --ai-bubble-text: #E0E0E0;
    --sidebar-bg: #000000;
    --sidebar-border: #3A1D4D;
    --sidebar-item-hover: #1A0F24;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(10, 5, 15, 0.9);
    --conversation-bg: rgba(10, 5, 15, 0.95);
    --conversation-text: #00FFFF;
    --conversation-indicator: #00FFFF;
    --code-block-bg: #20102A;
    --code-block-header-bg: #20102A;
    --code-block-border: #3A1D4D;
}
[data-theme="cyberpunk-light"] {
    --bg-primary: #F0F8FF;
    --bg-secondary: #FFFFFF;
    --text-primary: #00CED1;
    --text-secondary: #6A5ACD;
    --border-color: #ADD8E6;
    --card-bg: #FFFFFF;
    --card-border: #ADD8E6;
    --header-bg: #E0F2F7;
    --accent-primary: #00CED1;
    --accent-primary-hover: #00BFFF;
    --accent-secondary: #FF69B4;
    --accent-error: #DC143C;
    --accent-success: #3CB371;
    --user-bubble-bg: #E0FFFF;
    --user-bubble-text: #2F4F4F;
    --ai-bubble-bg: #F0F8FF;
    --ai-bubble-text: #4169E1;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #ADD8E6;
    --sidebar-item-hover: #E0F2F7;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2F4F4F;
    --conversation-indicator: #00CED1;
    --code-block-bg: #ADD8E6;
    --code-block-header-bg: #ADD8E6;
    --code-block-border: #87CEEB;
}

/* Matrix Code Theme */
[data-theme="matrix-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #0A0A0A;
    --text-primary: #00FF00;
    --text-secondary: #008000;
    --border-color: #004000;
    --card-bg: #0A0A0A;
    --card-border: #004000;
    --header-bg: #000000;
    --accent-primary: #017801;
    --accent-primary-hover: #00CC00;
    --accent-secondary: #00FFFF;
    --accent-error: #FF0000;
    --accent-success: #00FF00;
    --user-bubble-bg: #001A00;
    --user-bubble-text: #00FF00;
    --ai-bubble-bg: #000500;
    --ai-bubble-text: #00FF00;
    --sidebar-bg: #000000;
    --sidebar-border: #004000;
    --sidebar-item-hover: #001500;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #00FF00;
    --conversation-indicator: #00FF00;
    --code-block-bg: #001000;
    --code-block-header-bg: #001000;
    --code-block-border: #002000;
}
[data-theme="matrix-light"] {
    --bg-primary: #FFFFFF;
    --bg-secondary: #F0F0F0;
    --text-primary: #008000;
    --text-secondary: #404040;
    --border-color: #D0D0D0;
    --card-bg: #F0F0F0;
    --card-border: #D0D0D0;
    --header-bg: #E0E0E0;
    --accent-primary: #008000;
    --accent-primary-hover: #006000;
    --accent-secondary: #00AAAA;
    --accent-error: #CC0000;
    --accent-success: #00AA00;
    --user-bubble-bg: #E0FFE0;
    --user-bubble-text: #202020;
    --ai-bubble-bg: #F0FFF0;
    --ai-bubble-text: #303030;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #D0D0D0;
    --sidebar-item-hover: #E0E0E0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #202020;
    --conversation-indicator: #008000;
    --code-block-bg: #E0FFE0;
    --code-block-header-bg: #E0FFE0;
    --code-block-border: #C0D0C0;
}

/* Solarized Theme */
[data-theme="solarized-light"] {
    --bg-primary: #FDF6E3;
    --bg-secondary: #EEE8D5;
    --text-primary: #2AA198;
    --text-secondary: #657B83;
    --border-color: #93A1A1;
    --card-bg: #EEE8D5;
    --card-border: #93A1A1;
    --header-bg: #FDF6E3;
    --accent-primary: #2AA198;
    --accent-primary-hover: #268BD2;
    --accent-secondary: #DC322F;
    --accent-error: #DC322F;
    --accent-success: #859900;
    --user-bubble-bg: #839496;
    --user-bubble-text: #FDF6E3;
    --ai-bubble-bg: #E0E0D0;
    --ai-bubble-text: #586E75;
    --sidebar-bg: #FDF6E3;
    --sidebar-border: #93A1A1;
    --sidebar-item-hover: #EEE8D5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #586E75;
    --conversation-indicator: #2AA198;
    --code-block-bg: #FDF6E3;
    --code-block-header-bg: #FDF6E3;
    --code-block-border: #D0D0C0;
}
[data-theme="solarized-dark"] {
    --bg-primary: #002B36;
    --bg-secondary: #073642;
    --text-primary: #2AA198;
    --text-secondary: #839496;
    --border-color: #586E75;
    --card-bg: #073642;
    --card-border: #586E75;
    --header-bg: #002B36;
    --accent-primary: #2AA198;
    --accent-primary-hover: #268BD2;
    --accent-secondary: #DC322F;
    --accent-error: #DC322F;
    --accent-success: #859900;
    --user-bubble-bg: #586E75;
    --user-bubble-text: #FDF6E3;
    --ai-bubble-bg: #073642;
    --ai-bubble-text: #93A1A1;
    --sidebar-bg: #002B36;
    --sidebar-border: #586E75;
    --sidebar-item-hover: #073642;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 43, 54, 0.9);
    --conversation-bg: rgba(0, 43, 54, 0.95);
    --conversation-text: #FDF6E3;
    --conversation-indicator: #2AA198;
    --code-block-bg: #002B36;
    --code-block-header-bg: #002B36;
    --code-block-border: #586E75;
}

/* Dracula Theme */
[data-theme="dracula-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #282A36;
    --text-primary: #BD93F9;
    --text-secondary: #6272A4;
    --border-color: #44475A;
    --card-bg: #282A36;
    --card-border: #44475A;
    --header-bg: #000000;
    --accent-primary: #BD93F9;
    --accent-primary-hover: #FF79C6;
    --accent-secondary: #50FA7B;
    --accent-error: #FF5555;
    --accent-success: #50FA7B;
    --user-bubble-bg: #44475A;
    --user-bubble-text: #F8F8F2;
    --ai-bubble-bg: #1A1C25;
    --ai-bubble-text: #F8F8F2;
    --sidebar-bg: #000000;
    --sidebar-border: #44475A;
    --sidebar-item-hover: #282A36;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #F8F8F2;
    --conversation-indicator: #BD93F9;
    --code-block-bg: #2F313E;
    --code-block-header-bg: #2F313E;
    --code-block-border: #44475A;
}
[data-theme="dracula-light"] {
    --bg-primary: #F8F8F2;
    --bg-secondary: #F0F0E0;
    --text-primary: #FF79C6;
    --text-secondary: #6272A4;
    --border-color: #CCDEF2;
    --card-bg: #F0F0E0;
    --card-border: #CCDEF2;
    --header-bg: #E8E8E0;
    --accent-primary: #FF79C6;
    --accent-primary-hover: #BD93F9;
    --accent-secondary: #50FA7B;
    --accent-error: #FF5555;
    --accent-success: #50FA7B;
    --user-bubble-bg: #CCDEF2;
    --user-bubble-text: #282A36;
    --ai-bubble-bg: #E8E8E0;
    --ai-bubble-text: #303240;
    --sidebar-bg: #F8F8F2;
    --sidebar-border: #CCDEF2;
    --sidebar-item-hover: #F0F0E0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #282A36;
    --conversation-indicator: #FF79C6;
    --code-block-bg: #D8D8D0;
    --code-block-header-bg: #D8D8D0;
    --code-block-border: #C2C2C0;
}

/* Monokai Pro Theme */
[data-theme="monokai-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #2D2A2E;
    --text-primary: #A6E22E;
    --text-secondary: #75715E;
    --border-color: #49483E;
    --card-bg: #2D2A2E;
    --card-border: #49483E;
    --header-bg: #000000;
    --accent-primary: #A6E22E;
    --accent-primary-hover: #E6DB74;
    --accent-secondary: #FD971F;
    --accent-error: #F92672;
    --accent-success: #A6E22E;
    --user-bubble-bg: #49483E;
    --user-bubble-text: #FCFCFA;
    --ai-bubble-bg: #1A1A1A;
    --ai-bubble-text: #FCFCFA;
    --sidebar-bg: #000000;
    --sidebar-border: #49483E;
    --sidebar-item-hover: #2D2A2E;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #FCFCFA;
    --conversation-indicator: #A6E22E;
    --code-block-bg: #27252A;
    --code-block-header-bg: #27252A;
    --code-block-border: #3F3C38;
}
[data-theme="monokai-light"] {
    --bg-primary: #FCFCFA;
    --bg-secondary: #F5F5F0;
    --text-primary: #F92672;
    --text-secondary: #75715E;
    --border-color: #D0D0CB;
    --card-bg: #F5F5F0;
    --card-border: #D0D0CB;
    --header-bg: #EEEEEC;
    --accent-primary: #F92672;
    --accent-primary-hover: #A6E22E;
    --accent-secondary: #FD971F;
    --accent-error: #CC3333;
    --accent-success: #A6E22E;
    --user-bubble-bg: #E0E0D8;
    --user-bubble-text: #30302E;
    --ai-bubble-bg: #EEEEEC;
    --ai-bubble-text: #40403C;
    --sidebar-bg: #FCFCFA;
    --sidebar-border: #D0D0CB;
    --sidebar-item-hover: #F5F5F0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #30302E;
    --conversation-indicator: #F92672;
    --code-block-bg: #E0E0D8;
    --code-block-header-bg: #E0E0D8;
    --code-block-border: #C0C0B8;
}

/* Nord Theme */
[data-theme="nord-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #2E3440;
    --text-primary: #88C0D0;
    --text-secondary: #ECEFF4;
    --border-color: #4C566A;
    --card-bg: #2E3440;
    --card-border: #4C566A;
    --header-bg: #000000;
    --accent-primary: #88C0D0;
    --accent-primary-hover: #81A1C1;
    --accent-secondary: #B48EAD;
    --accent-error: #BF616A;
    --accent-success: #A3BE8C;
    --user-bubble-bg: #4C566A;
    --user-bubble-text: #D8DEE9;
    --ai-bubble-bg: #1A1D23;
    --ai-bubble-text: #D8DEE9;
    --sidebar-bg: #000000;
    --sidebar-border: #4C566A;
    --sidebar-item-hover: #2E3440;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #D8DEE9;
    --conversation-indicator: #88C0D0;
    --code-block-bg: #242933;
    --code-block-header-bg: #242933;
    --code-block-border: #4C566A;
}
[data-theme="nord-light"] {
    --bg-primary: #ECEFF4;
    --bg-secondary: #D8DEE9;
    --text-primary: #5E81AC;
    --text-secondary: #4C566A;
    --border-color: #B4BFCD;
    --card-bg: #D8DEE9;
    --card-border: #B4BFCD;
    --header-bg: #DEE3EB;
    --accent-primary: #5E81AC;
    --accent-primary-hover: #81A1C1;
    --accent-secondary: #B48EAD;
    --accent-error: #BF616A;
    --accent-success: #A3BE8C;
    --user-bubble-bg: #AABECF;
    --user-bubble-text: #2E3440;
    --ai-bubble-bg: #DEE3EB;
    --ai-bubble-text: #3B4252;
    --sidebar-bg: #ECEFF4;
    --sidebar-border: #B4BFCD;
    --sidebar-item-hover: #D8DEE9;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2E3440;
    --conversation-indicator: #5E81AC;
    --code-block-bg: #C0C7D1;
    --code-block-header-bg: #C0C7D1;
    --code-block-border: #B4BFCD;
}

/* Gruvbox Theme */
[data-theme="gruvbox-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #282828;
    --text-primary: #83A598;
    --text-secondary: #A89984;
    --border-color: #504945;
    --card-bg: #282828;
    --card-border: #504945;
    --header-bg: #000000;
    --accent-primary: #83A598;
    --accent-primary-hover: #B8BB26;
    --accent-secondary: #FABD2F;
    --accent-error: #FB4934;
    --accent-success: #B8BB26;
    --user-bubble-bg: #504945;
    --user-bubble-text: #EBDBB2;
    --ai-bubble-bg: #1D2021;
    --ai-bubble-text: #EBDBB2;
    --sidebar-bg: #000000;
    --sidebar-border: #504945;
    --sidebar-item-hover: #282828;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #EBDBB2;
    --conversation-indicator: #83A598;
    --code-block-bg: #32302F;
    --code-block-header-bg: #32302F;
    --code-block-border: #504945;
}
[data-theme="gruvbox-light"] {
    --bg-primary: #FBF1C7;
    --bg-secondary: #FEF6E4;
    --text-primary: #427B58;
    --text-secondary: #7C6F64;
    --border-color: #BDAEAA;
    --card-bg: #FEF6E4;
    --card-border: #BDAEAA;
    --header-bg: #EBDBB2;
    --accent-primary: #427B58;
    --accent-primary-hover: #8EC07C;
    --accent-secondary: #D79921;
    --accent-error: #CC241D;
    --accent-success: #8EC07C;
    --user-bubble-bg: #D5C4A1;
    --user-bubble-text: #3C3836;
    --ai-bubble-bg: #EBDBB2;
    --ai-bubble-text: #504945;
    --sidebar-bg: #FBF1C7;
    --sidebar-border: #BDAEAA;
    --sidebar-item-hover: #EBDBB2;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #3C3836;
    --conversation-indicator: #427B58;
    --code-block-bg: #D5C4A1;
    --code-block-header-bg: #D5C4A1;
    --code-block-border: #BDAEAA;
}

/* Catppuccin Theme */
[data-theme="catppuccin-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #24273A;
    --text-primary: #8BD5CA;
    --text-secondary: #A5ADCE;
    --border-color: #494D64;
    --card-bg: #24273A;
    --card-border: #494D64;
    --header-bg: #000000;
    --accent-primary: #8BD5CA;
    --accent-primary-hover: #B7BFEF;
    --accent-secondary: #F4B8E4;
    --accent-error: #ED8796;
    --accent-success: #A6DA95;
    --user-bubble-bg: #494D64;
    --user-bubble-text: #CAD3F5;
    --ai-bubble-bg: #1A1D2A;
    --ai-bubble-text: #CAD3F5;
    --sidebar-bg: #000000;
    --sidebar-border: #494D64;
    --sidebar-item-hover: #24273A;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #CAD3F5;
    --conversation-indicator: #8BD5CA;
    --code-block-bg: #2E3243;
    --code-block-header-bg: #2E3243;
    --code-block-border: #494D64;
}
[data-theme="catppuccin-light"] {
    --bg-primary: #EFF1F5;
    --bg-secondary: #E6E9EF;
    --text-primary: #179299;
    --text-secondary: #5C5F77;
    --border-color: #CBD0E1;
    --card-bg: #E6E9EF;
    --card-border: #CBD0E1;
    --header-bg: #EAECEF;
    --accent-primary: #179299;
    --accent-primary-hover: #7287FD;
    --accent-secondary: #EA76CB;
    --accent-error: #E64553;
    --accent-success: #40A02B;
    --user-bubble-bg: #CBD0E1;
    --user-bubble-text: #4C4F69;
    --ai-bubble-bg: #EAECEF;
    --ai-bubble-text: #626880;
    --sidebar-bg: #EFF1F5;
    --sidebar-border: #CBD0E1;
    --sidebar-item-hover: #E6E9EF;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #4C4F69;
    --conversation-indicator: #179299;
    --code-block-bg: #D4D7E2;
    --code-block-header-bg: #D4D7E2;
    --code-block-border: #C8CDDD;
}

/* Cosmic Nexus Theme: Dark Mode */
[data-theme="cosmic-nexus-dark"] {
    --bg-primary: #05050A;
    --bg-secondary: #101018;
    --text-primary: #E6E6E6;
    --text-secondary: #94A3B8;
    --border-color: #2A2A3A;
    --card-bg: #101018;
    --card-border: #2A2A3A;
    --header-bg: #0A0A10;
    --accent-primary: #00F5FF;
    --accent-primary-hover: #00CED1;
    --accent-secondary: #D400FF;
    --accent-error: #FF4500;
    --accent-success: #0AFF9D;
    --user-bubble-bg: #003344;
    --user-bubble-text: #E0FFFF;
    --ai-bubble-bg: #18052A;
    --ai-bubble-text: #E6E6E6;
    --sidebar-bg: #101018;
    --sidebar-border: #2A2A3A;
    --sidebar-item-hover: #1A1A22;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(16, 16, 24, 0.9);
    --conversation-bg: rgba(5, 5, 10, 0.95);
    --conversation-text: #E6E6E6;
    --conversation-indicator: #00F5FF;
    --code-block-bg: #0A0A10;
    --code-block-header-bg: #0A0A10;
    --code-block-border: #2A2A3A;
}

/* Cosmic Nexus Theme: Light Mode */
[data-theme="cosmic-nexus-light"] {
    --bg-primary: #F0F8FF;
    --bg-secondary: #FFFFFF;
    --text-primary: #1F2937;
    --text-secondary: #4B5563;
    --border-color: #E5E7EB;
    --card-bg: #FFFFFF;
    --card-border: #E5E7EB;
    --header-bg: #EAF0F8;
    --accent-primary: #00CED1;
    --accent-primary-hover: #00BFFF;
    --accent-secondary: #9370DB;
    --accent-error: #FF4500;
    --accent-success: #0AFF9D;
    --user-bubble-bg: #E0FFFF;
    --user-bubble-text: #004D40;
    --ai-bubble-bg: #F3F8FF;
    --ai-bubble-text: #2F4F4F;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E5E7EB;
    --sidebar-item-hover: #EAF0F8;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.85);
    --conversation-bg: rgba(255, 255, 255, 0.9);
    --conversation-text: #1F2937;
    --conversation-indicator: #00CED1;
    --code-block-bg: #EAF0F8;
    --code-block-header-bg: #EAF0F8;
    --code-block-border: #E5E7EB;
}

/* Starship Minimal Theme: Dark Mode */
[data-theme="starship-minimal-dark"] {
    --bg-primary: #0D1117;
    --bg-secondary: #161B22;
    --text-primary: #F0F6FC;
    --text-secondary: #8B949E;
    --border-color: #30363D;
    --card-bg: #161B22;
    --card-border: #30363D;
    --header-bg: #0D1117;
    --accent-primary: #2F81F7;
    --accent-primary-hover: #1C6EDD;
    --accent-secondary: #58A6FF;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #1F385B;
    --user-bubble-text: #DBEAFE;
    --ai-bubble-bg: #21262D;
    --ai-bubble-text: #F0F6FC;
    --sidebar-bg: #161B22;
    --sidebar-border: #30363D;
    --sidebar-item-hover: #21262D;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(13, 17, 23, 0.9);
    --conversation-bg: rgba(13, 17, 23, 0.95);
    --conversation-text: #F0F6FC;
    --conversation-indicator: #2F81F7;
    --code-block-bg: #161B22;
    --code-block-header-bg: #161B22;
    --code-block-border: #30363D;
}

/* Starship Minimal Theme: Light Mode */
[data-theme="starship-minimal-light"] {
    --bg-primary: #F0F4F8;
    --bg-secondary: #FFFFFF;
    --text-primary: #2D3748;
    --text-secondary: #718096;
    --border-color: #E2E8F0;
    --card-bg: #FFFFFF;
    --card-border: #E2E8F0;
    --header-bg: #EDF2F7;
    --accent-primary: #1E90FF;
    --accent-primary-hover: #107EEB;
    --accent-secondary: #63B2FF;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #DBEAFE;
    --user-bubble-text: #1E40AF;
    --ai-bubble-bg: #F3F8FF;
    --ai-bubble-text: #2D3748;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E2E8F0;
    --sidebar-item-hover: #F0F4F8;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.85);
    --conversation-bg: rgba(255, 255, 255, 0.9);
    --conversation-text: #2D3748;
    --conversation-indicator: #1E90FF;
    --code-block-bg: #EDF2F7;
    --code-block-header-bg: #EDF2F7;
    --code-block-border: #E2E8F0;
}

/* Offbeat Cosmic Pastels Theme: Dark Mode */
[data-theme="offbeat-cosmic-dark"] {
    --bg-primary: #0C0F16;
    --bg-secondary: #1A1E2B;
    --text-primary: #FDFDFD;
    --text-secondary: #A0A5B5;
    --border-color: #30354F;
    --card-bg: #1A1E2B;
    --card-border: #30354F;
    --header-bg: #0C0F16;
    --accent-primary: #5CE1E6;
    --accent-primary-hover: #45CCD1;
    --accent-secondary: #C780FF;
    --accent-error: #FF6347;
    --accent-success: #7FFF00;
    --user-bubble-bg: #3A2B5B;
    --user-bubble-text: #E0E0E0;
    --ai-bubble-bg: #2B1E40;
    --ai-bubble-text: #FDFDFD;
    --sidebar-bg: #1A1E2B;
    --sidebar-border: #30354F;
    --sidebar-item-hover: #212535;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(12, 15, 22, 0.9);
    --conversation-bg: rgba(12, 15, 22, 0.95);
    --conversation-text: #FDFDFD;
    --conversation-indicator: #5CE1E6;
    --code-block-bg: #1A1E2B;
    --code-block-header-bg: #1A1E2B;
    --code-block-border: #30354F;
}

/* Offbeat Cosmic Pastels Theme: Light Mode */
[data-theme="offbeat-cosmic-light"] {
    --bg-primary: #F9FDFD;
    --bg-secondary: #FFFFFF;
    --text-primary: #2D3748;
    --text-secondary: #718096;
    --border-color: #E2E8F0;
    --card-bg: #FFFFFF;
    --card-border: #E2E8F0;
    --header-bg: #EEF8F8;
    --accent-primary: #00BCD4;
    --accent-primary-hover: #00ACC1;
    --accent-secondary: #A078E0;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #DBFEFF;
    --user-bubble-text: #004D40;
    --ai-bubble-bg: #E0FFFF;
    --ai-bubble-text: #2D3748;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E2E8F0;
    --sidebar-item-hover: #EEF8F8;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.85);
    --conversation-bg: rgba(255, 255, 255, 0.9);
    --conversation-text: #2D3748;
    --conversation-indicator: #00BCD4;
    --code-block-bg: #EEF8F8;
    --code-block-header-bg: #EEF8F8;
    --code-block-border: #E2E8F0;
}


/*
 * ===================================================================
 * --- 3. THEME-SPECIFIC BACKGROUNDS AND ANIMATIONS (BODY STYLES) ---
 * ===================================================================
 * These cannot be variable declarations and must be applied directly
 * to the body element using the data-theme selector.
 */

/* Clear background image for B&W themes */
body[data-theme^="darkest-bw"] {
    background-image: none !important;
}

/* Cosmic Nexus Dark */
body[data-theme="cosmic-nexus-dark"] {
    background-image: radial-gradient(circle at 15% 15%, rgba(0,245,255,0.08) 0%, transparent 25%),
                      radial-gradient(circle at 85% 85%, rgba(212,0,255,0.08) 0%, transparent 25%),
                      url('data:image/svg+xml;utf8,<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="smallGrid" width="16" height="16" patternUnits="userSpaceOnUse"><path d="M 16 0 L 0 0 L 0 16" fill="none" stroke="rgba(0,245,255,0.05)" stroke-width="0.5"/></pattern><pattern id="grid" width="80" height="80" patternUnits="userSpaceOnUse"><rect width="80" height="80" fill="url(%23smallGrid)"/><path d="M 80 0 L 0 0 L 0 80" fill="none" stroke="rgba(0,245,255,0.08)" stroke-width="1"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grid)"/></svg>');
    background-size: cover, cover, auto;
    background-blend-mode: overlay, overlay, multiply;
}

/* Starship Minimal Dark */
body[data-theme="starship-minimal-dark"] {
    background-image: url('data:image/svg+xml;utf8,<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 L 0 10" fill="none" stroke="rgba(47,129,247,0.08)" stroke-width="0.5"/></pattern><pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse"><rect width="50" height="50" fill="url(%23smallGrid)"/><path d="M 50 0 L 0 0 L 0 50" fill="none" stroke="rgba(47,129,247,0.12)" stroke-width="1"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grid)"/></svg>');
    background-size: cover;
    background-blend-mode: overlay;
}

/* Offbeat Cosmic Pastels Theme: Dark Mode (with animation) */
@keyframes pastel-nebula-drift {
    0% { background-position: 0% 0%; }
    100% { background-position: 100% 100%; }
}
body[data-theme="offbeat-cosmic-dark"] {
    background-image: radial-gradient(circle at 20% 80%, rgba(199,128,255,0.1) 0%, transparent 40%),
                      radial-gradient(circle at 80% 20%, rgba(92,225,230,0.1) 0%, transparent 40%),
                      linear-gradient(135deg, rgba(255,180,233,0.05) 0%, transparent 50%, rgba(199,128,255,0.05) 100%);
    background-size: cover;
    background-blend-mode: soft-light;
    animation: pastel-nebula-drift 25s infinite alternate ease-in-out;
}


/*
 * ===================================================================
 * --- 4. BASE APPLICATION STYLES (Using Variables) ---
 * ===================================================================
 */
body {
  background: var(--bg-primary); 
  color: var(--text-primary);
  font-family: 'Inter', Arial, Helvetica, sans-serif;
  height: 100vh;
  overflow: hidden;
  transition: background-color 0.6s ease, color 0.6s ease;
}

/* Custom scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-thumb {
  background: color-mix(in srgb, var(--accent-primary) 50%, transparent); 
  border-radius: 4px;
}
::-webkit-scrollbar-track {
  background: var(--bg-primary);
}

/* Markdown and Code Styling Overrides */

/* Code block wrapper (created by custom renderer) */
.code-block-container {
    background-color: var(--code-block-bg) !important;
    border: 1px solid var(--code-block-border) !important;
    border-radius: 0.5rem !important;
    margin-top: 1rem !important;
    margin-bottom: 1rem !important;
    overflow: hidden; /* Contains children border radius */
}

/* Code block container (standard markdown pre tag) */
.message-content pre {
    /* Remove default markdown styles from PRE */
    background-color: var(--code-block-bg) !important;
    border: none !important;
    margin: 0 !important;
    padding: 0 !important;
    border-radius: 0 !important;
    overflow-x: auto; /* FIX: Enable horizontal scroll */
}

/* Code block header */
.code-block-header {
    background-color: var(--code-block-header-bg);
    color: var(--text-secondary);
    padding: 0.5rem 1rem;
    border-bottom: 1px solid var(--code-block-border);
    font-size: 0.85em;
    display: flex; /* Ensure button aligns */
    justify-content: space-between;
    align-items: center;
}

/* Code content inside pre (Prism.js applies most styling here) */
.message-content pre code {
    /* Override Prism's default padding/margin/background/text settings */
    color: var(--text-primary); /* Use theme color for text */
    display: block;
    padding: 1rem !important; /* Padding for the code content */
    background: transparent !important; /* Use container background, not code background */
    min-width: 100%; /* Important for horizontal scrolling */
    box-sizing: border-box;
    /* FIX: Force content not to wrap for horizontal scrolling */
    white-space: pre !important; 
    max-width: 1000px;
}

/* Inline code */
.message-content code:not(pre > code) {
    background-color: color-mix(in srgb, var(--accent-primary) 15%, transparent) !important;
    border-radius: 0.25rem;
    padding: 0.2em 0.4em;
    font-size: 0.9em;
    color: var(--accent-primary) !important;
}

/* Styling for button when Speech Recognition is active */
.voice-input-active {
    background-color: var(--accent-error) !important;
    animation: pulse-red 1s infinite cubic-bezier(0.4, 0, 0.6, 1);
}
@keyframes pulse-red {
    0%, 100% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--accent-error) 70%, transparent); }
    50% { box-shadow: 0 0 0 10px color-mix(in srgb, var(--accent-error) 0%, transparent); }
}

/* User Bubble Styles (Ensure they use the variables) */
.chat-message.user {
    background-color: var(--user-bubble-bg);
    color: var(--user-bubble-text);
}

/* AI Bubble Styles (Ensure they use the variables) */
.chat-message.model {
    background-color: var(--ai-bubble-bg);
    color: var(--ai-bubble-text);
    border: 1px solid var(--border-color);
}

--- END FILE: app\globals.css ---

--- START FILE: app\layout.tsx ---

// app/layout.tsx
import type { Metadata } from "next";
import "./globals.css";
import { AuthProvider } from '@/components/providers/AuthProvider';
import { ThemeProvider } from '@/components/providers/ThemeContext'; // NEW IMPORT


export const metadata: Metadata = {
  title: "Big AI Chatbot (Production)",
  description: "A large scale Gemini chat application.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // Theme is applied via CSS variables and the ThemeProvider context
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={`antialiased`}> 
        <AuthProvider>
          <ThemeProvider> {/* Wrap children with ThemeProvider */}
            {children}
          </ThemeProvider>
        </AuthProvider>
      </body>
    </html>
  );
}

--- END FILE: app\layout.tsx ---

--- START FILE: app\page.tsx ---

// app/page.tsx
'use client';

import { useState, useEffect } from 'react';
import ChatArea from '@/components/ChatArea';
import Sidebar from '@/components/Sidebar';
import { useAuth } from '@/components/providers/AuthProvider';
import AuthGate from '@/components/ui/AuthGate';
import ConversationModeOverlay from '@/components/ConversationModeOverlay';
import { useTheme } from '@/components/providers/ThemeContext';

export default function HomePage() {
  const { user, loading: authLoading } = useAuth();
  const { loadingSettings } = useTheme();

  const [currentChatId, setCurrentChatId] = useState<string | undefined>(undefined);
  const [refreshSidebarToggle, setRefreshSidebarToggle] = useState(false);
  const [isConversationModeOpen, setIsConversationModeOpen] = useState(false);
  
  // === NEW RESPONSIVENESS STATE ===
  const [isSidebarOpen, setIsSidebarOpen] = useState(false); // Default to CLOSED on mobile
  const [isMobile, setIsMobile] = useState(false);

  // Effect to determine screen size and manage sidebar visibility default
  useEffect(() => {
    const handleResize = () => {
      const mobile = window.innerWidth < 768; 
      setIsMobile(mobile);
      if (!mobile) {
        setIsSidebarOpen(true); // Always open sidebar on desktop
      } else {
        // If resized to mobile, close the sidebar unless it was already open manually
        setIsSidebarOpen(false); 
      }
    };

    window.addEventListener('resize', handleResize);
    handleResize(); // Initial check

    return () => window.removeEventListener('resize', handleResize);
  }, []); 
  // ===================================

  const handleSelectChat = (chatId: string | undefined) => {
    setCurrentChatId(chatId);
    if (isConversationModeOpen) setIsConversationModeOpen(false);
    
    if (isMobile) setIsSidebarOpen(false); 
  };
  
  const handleNewMessageSent = () => {
    setRefreshSidebarToggle(prev => !prev);
  }

  if (authLoading || loadingSettings) {
    return <div className="flex h-screen items-center justify-center text-xl" style={{color: 'var(--text-primary)'}}>Loading application...</div>
  }

  if (!user) {
    return <AuthGate />;
  }

  // Main application view
  return (
    // FIX: Ensure the main container is hidden overflow to prevent scroll issues
    <div className="flex h-screen overflow-hidden relative" style={{ backgroundColor: 'var(--bg-primary)' }}>
      
      {/* 2. Main Chat Area - This needs to take up all space */}
      {/* On desktop (md:), it takes remaining flex space. On mobile, it takes full width/height. */}
      <main className="flex-1 flex flex-col min-w-0 w-full h-full"> 
        <ChatArea 
          chatId={currentChatId}
          onChatIdChange={setCurrentChatId}
          onNewMessageSent={handleNewMessageSent}
          onOpenConversationMode={() => setIsConversationModeOpen(true)}
          
          onToggleSidebar={() => setIsSidebarOpen(prev => !prev)}
          isMobileView={isMobile}
        />
      </main>
      
      {/* 1. Sidebar - Rendered on top of main content on mobile */}
      <Sidebar 
        onSelectChat={handleSelectChat} 
        currentChatId={currentChatId}
        onNewMessageSent={handleNewMessageSent}
        onOpenConversationMode={() => { 
            setIsConversationModeOpen(true); 
            if (isMobile) setIsSidebarOpen(false);
        }} 
        key={refreshSidebarToggle.toString()} 
        
        isMobileOpen={isSidebarOpen}
        onCloseMobile={() => setIsSidebarOpen(false)}
        isMobileView={isMobile}
      />
      
      {/* 3. Mobile Overlay Backdrop */}
      {isMobile && isSidebarOpen && (
        <div 
          className="fixed inset-0 bg-black/50 z-20 md:hidden" 
          onClick={() => setIsSidebarOpen(false)}
        />
      )}
      
      {/* 4. Conversation Mode Overlay */}
      {isConversationModeOpen && (
        <ConversationModeOverlay
          chatId={currentChatId}
          onChatIdChange={setCurrentChatId}
          onClose={() => setIsConversationModeOpen(false)}
          onNewMessageSent={handleNewMessageSent}
        />
      )}
    </div>
  );
}

--- END FILE: app\page.tsx ---

--- START FILE: app\api\chat\route.ts ---

// app/api/chat/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { generateStreamingResponse } from '@/lib/gemini';
import { getConversation, createConversation, updateConversation, deleteConversation } from '@/lib/history';
import { getSettings } from '@/lib/settings';
import { ChatMessage, Conversation, FileAttachment } from '@/types/chat';
import { getAuthId } from '@/lib/firebaseAdmin';

export const runtime = 'nodejs'; 

interface ChatRequest {
    chatId?: string; 
    message: string;
    files?: FileAttachment[];
}

// --- GET: Load existing conversation history ---
export async function GET(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }

    try {
        const { searchParams } = new URL(req.url);
        const chatId = searchParams.get('chatId');

        if (!chatId) {
            return NextResponse.json({ error: 'chatId is required' }, { status: 400 });
        }

        // Use userId in getConversation for authorization check
        const conversation = await getConversation(chatId, userId);

        if (!conversation) {
             return NextResponse.json({ error: 'Conversation not found or unauthorized' }, { status: 404 });
        }

        return NextResponse.json(conversation);

    } catch (error) {
        console.error('API GET Error:', error);
        return NextResponse.json({ error: 'Failed to retrieve chat history' }, { status: 500 });
    }
}

// --- DELETE: Delete a specific conversation ---
export async function DELETE(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }
    
    try {
        const { searchParams } = new URL(req.url);
        const chatId = searchParams.get('chatId');

        if (!chatId) {
            return NextResponse.json({ error: 'chatId is required' }, { status: 400 });
        }
        
        await deleteConversation(chatId, userId);
        
        return NextResponse.json({ message: `Conversation ${chatId} deleted successfully` });

    } catch (error) {
        console.error('API DELETE Error:', error);
        if (error instanceof Error && error.message.includes('Unauthorized')) {
             return NextResponse.json({ error: 'Unauthorized or conversation not found' }, { status: 403 });
        }
        return NextResponse.json({ error: 'Failed to delete chat history' }, { status: 500 });
    }
}


// --- POST: Handle new message/streaming ---
export async function POST(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }

  try {
    const { message, chatId: incomingChatId, files = [] }: ChatRequest = await req.json();

    if (!message || message.trim() === '') {
        // Allow empty text if files are present (e.g., "Analyze this image")
        if (files.length === 0) {
            return NextResponse.json({ error: 'Message cannot be empty.' }, { status: 400 });
        }
    }

    let conversation: Conversation | null = null;
    let chatId = incomingChatId;
    let isFirstExchange = false;

    if (chatId) {
        conversation = await getConversation(chatId, userId);
        if (!conversation) {
            return NextResponse.json({ error: 'Conversation not found or unauthorized.' }, { status: 404 });
        }
    } else {
        // NEW: Fetch global settings for model and system prompt
        const userSettings = await getSettings(userId);
        
        // NEW: Create conversation with global settings context
        conversation = await createConversation(
            userId, 
            message, 
            files,
            userSettings.globalModel, // Pass global model
            userSettings.globalSystemPrompt // Pass global system prompt
        );
        chatId = conversation.id;
        isFirstExchange = true;
    }

    // 1. Prepare history and current prompt (including files)
    const history: ChatMessage[] = conversation?.messages || [];
    
    // The current exchange (user message + files) is added to the history context for Gemini
    const userMessageForContext: ChatMessage = { 
        id: 'temp', 
        text: message, 
        role: 'user', 
        timestamp: Date.now(),
        files: files.length > 0 ? files : undefined,
    } as ChatMessage;

    const fullHistoryContext: ChatMessage[] = [
        ...history,
        userMessageForContext
    ];
    
    // Optional: Pass system prompt from conversation settings
    const systemInstruction = conversation?.systemPrompt;

    // 2. Generate the streaming response
    const stream = await generateStreamingResponse(
        fullHistoryContext,
        systemInstruction
    );
    
    // 3. Read the entire stream response to save it to the database
    let fullBotResponse = '';
    
    // Use .tee() to create two identical streams: one for the client, one for history saving
    const [clientStream, historyStream] = stream.tee();
    
    const reader = historyStream.getReader();
    const decoder = new TextDecoder();
    
    // Asynchronously save history
    (async () => {
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                fullBotResponse += decoder.decode(value);
            }
            
            // 4. Persist the full exchange asynchronously
            if (chatId) {
                await updateConversation(chatId, message, fullBotResponse, userId, files, isFirstExchange);
            }
        } catch (dbError) {
            console.error('CRITICAL: Error saving history to Firestore:', dbError);
        }
    })();
    
    // 5. Send the streaming response back to the client immediately
    const response = new NextResponse(clientStream, {
        headers: {
            'Content-Type': 'text/plain',
            'X-Chat-ID': chatId,
        },
        status: 200,
    });
    
    return response;

  } catch (error) {
    console.error('FATAL API Error:', error);
    return NextResponse.json({ error: 'Failed to process chat request.' }, { status: 500 });
  }
}

--- END FILE: app\api\chat\route.ts ---

--- START FILE: app\api\chats\route.ts ---

// app/api/chats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { db, getAuthId } from '@/lib/firebaseAdmin';
import { Conversation } from '@/types/chat';
import { deleteAllUserConversations } from '@/lib/history'; // Server-side import

export const runtime = 'nodejs';

/**
 * Fetches a list of recent conversations for the current user.
 */
export async function GET(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }
    
    try {
        const snapshot = await db.collection('conversations')
            .where('userId', '==', userId) // Use real User ID
            .orderBy('updatedAt', 'desc')
            .limit(20) // Limit to 20 recent chats
            .get();

        const chats = snapshot.docs.map(doc => {
            const data = doc.data() as Conversation;
            
            // Return only necessary data for the sidebar
            return {
                id: data.id,
                title: data.title,
                updatedAt: data.updatedAt,
            };
        });

        return NextResponse.json(chats);

    } catch (error) {
        console.error('Error fetching chat list:', error);
        return NextResponse.json({ error: 'Failed to retrieve conversation list' }, { status: 500 });
    }
}

/**
 * Deletes all conversations for the current user.
 */
export async function DELETE(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }
    
    try {
        await deleteAllUserConversations(userId);
        return NextResponse.json({ message: 'All conversations deleted successfully' });

    } catch (error) {
        console.error('Error deleting chat list:', error);
        return NextResponse.json({ error: 'Failed to delete conversations' }, { status: 500 });
    }
}

--- END FILE: app\api\chats\route.ts ---

--- START FILE: app\api\settings\route.ts ---

// app/api/settings/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getAuthId } from '@/lib/firebaseAdmin';
import { getSettings, saveSettings } from '@/lib/settings';
import { UserSettings, PromptTemplate } from '@/types/chat';

export const runtime = 'nodejs';

// --- GET: Load user settings ---
export async function GET(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    try {
        const settings = await getSettings(userId);
        // Ensure sensitive info (API Key) is only returned if explicitly requested or handled carefully.
        // For simplicity, we return the full settings object here as it's authenticated.
        return NextResponse.json(settings);
    } catch (error) {
        console.error('API GET Settings Error:', error);
        return NextResponse.json({ error: 'Failed to retrieve settings' }, { status: 500 });
    }
}

// --- POST: Save user settings ---
export async function POST(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    try {
        const body: Partial<UserSettings> = await req.json();
        
        // Use the saveSettings logic from lib/settings, which handles merging
        await saveSettings(userId, body);

        return NextResponse.json({ message: 'Settings saved successfully' });
    } catch (error) {
        console.error('API POST Settings Error:', error);
        return NextResponse.json({ error: 'Failed to save settings' }, { status: 500 });
    }
}

--- END FILE: app\api\settings\route.ts ---

--- START FILE: components\ChatArea.tsx ---

// components/ChatArea.tsx
'use client';

import React, { useState, useCallback, useEffect, useRef, ChangeEvent, DragEvent as ReactDragEvent, KeyboardEvent } from 'react';
import { ChatMessage, Conversation, FileAttachment } from '@/types/chat';
import ChatBubble from './ChatBubble'; 
import { useAuth } from '@/components/providers/AuthProvider';
import { v4 as uuidvv4 } from 'uuid';
import { useTheme } from '@/components/providers/ThemeContext';
import useSpeechRecognition from '@/hooks/useSpeechRecognition';

const BOT_PENDING_ID = 'bot-pending';

interface ChatAreaProps {
    chatId: string | undefined;
    onChatIdChange: (newChatId: string) => void;
    onNewMessageSent: () => void; // Trigger sidebar refresh
    onOpenConversationMode: () => void;
    // === NEW PROPS ===
    onToggleSidebar: () => void;
    isMobileView: boolean;
    // =================
}

// Utility to convert file to Base64
const fileToBase64 = (file: File): Promise<FileAttachment> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
            const result = reader.result as string;
            const [, base64Data] = result.split(',');
            if (base64Data) {
                resolve({
                    base64Data: base64Data,
                    mimeType: file.type,
                    filename: file.name,
                    size: file.size,
                });
            } else {
                reject(new Error("Failed to read file data."));
            }
        };
        reader.onerror = (error) => reject(error);
    });
};


export default function ChatArea({ chatId, onChatIdChange, onNewMessageSent, onOpenConversationMode, onToggleSidebar, isMobileView }: ChatAreaProps) {
  const { user, getIdToken } = useAuth();
  const { settings } = useTheme();
  
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isHistoryLoading, setIsHistoryLoading] = useState(false);
  const [attachments, setAttachments] = useState<File[]>([]); 
  
  const chatEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  // NEW: Speech Recognition Hook Integration
  const { isListening, transcript, startListening, stopListening, recognitionSupported, resetTranscript } = useSpeechRecognition({ 
      onFinalTranscript: (finalTranscript) => {
          setInput(prev => (prev.trim() + ' ' + finalTranscript).trim());
          resetTranscript();
      },
      onInterimTranscript: (interimTranscript) => {
        // Use interim transcript for instant visual feedback
        setInput(prev => (prev.split(' ')[0] + ' ' + interimTranscript).trim());
      },
      onStart: () => {
          // Temporarily disable sending when listening starts
          // We rely on the input state being updated by the hook
      },
      onEnd: () => {
         // Focus on input after listening stops
         inputRef.current?.focus();
      }
  });


  // Combine hook transcript with input state
  useEffect(() => {
    // If listening and transcript changes, we don't update input directly here, 
    // the hook manages it via onFinalTranscript and onInterimTranscript handlers provided above.
    // We update the placeholder dynamically based on listening state.
    if (inputRef.current) {
        inputRef.current.placeholder = isLoading 
            ? "Please wait..." 
            : (isListening 
                ? "Listening... Speak now." 
                : (attachments.length > 0 ? `Message Big AI about ${attachments.length} files...` : "Message Big AI..."));
    }
  }, [isLoading, isListening, attachments.length]);
  
  // Dynamic Input Height Adjustment 
  useEffect(() => {
    const textarea = inputRef.current;
    if (textarea) {
      textarea.style.height = 'auto'; 
      textarea.style.height = `${textarea.scrollHeight}px`;
    }
  }, [input]);


  // --- History Loading Effect ---
  useEffect(() => {
    if (!user) return;

    if (chatId) {
      setIsHistoryLoading(true);
      setMessages([]); // Clear old messages
      
      const fetchChatHistory = async () => {
        try {
          const token = await getIdToken();
          const response = await fetch(`/api/chat?chatId=${chatId}`, {
              headers: { 'Authorization': `Bearer ${token}` }
          });
          
          if (response.ok) {
            const conversation: Conversation = await response.json();
            const clientMessages: ChatMessage[] = conversation.messages.map(m => ({
                ...m,
                timestamp: new Date(m.timestamp),
            }));
            setMessages(clientMessages);
          } else {
            console.error("Failed to load conversation:", chatId);
            setMessages([{ id: uuidvv4(), text: 'Failed to load conversation history. Check console for details.', role: 'model', timestamp: new Date() } as ChatMessage]);
          }
        } catch (error) {
          console.error("Error fetching chat history:", error);
        } finally {
          setIsHistoryLoading(false);
        }
      };
      fetchChatHistory();
    } else {
      // New chat state
      setMessages([]);
      setAttachments([]); 
      setIsHistoryLoading(false);
    }
  }, [chatId, user, getIdToken]);

  // --- Utility Functions ---
  const addMessage = useCallback((msg: ChatMessage) => {
    setMessages((prev) => [...prev, msg]);
  }, []);

  const updateBotStreamingMessage = useCallback((text: string) => {
    setMessages((prev) => {
      const lastMessage = prev[prev.length - 1];
      if (lastMessage && lastMessage.id === BOT_PENDING_ID) {
        return [
          ...prev.slice(0, -1),
          { ...lastMessage, text: lastMessage.text + text },
        ];
      }
      return [...prev, { id: BOT_PENDING_ID, text, role: 'model', timestamp: new Date() } as ChatMessage];
    });
  }, []);

  const finalizeBotMessage = useCallback((finalText: string) => {
    setMessages((prev) => {
      const finalIndex = prev.findIndex(m => m.id === BOT_PENDING_ID);
      if (finalIndex !== -1) {
        const finalBotMessage: ChatMessage = {
            id: uuidvv4(), 
            text: finalText,
            role: 'model',
            timestamp: new Date(),
          };
        return [...prev.slice(0, finalIndex), finalBotMessage];
      }
      return prev;
    });
    onNewMessageSent(); // Notify parent to refresh sidebar
  }, [onNewMessageSent]);

  // --- Input and UI Handlers ---
  
  const handleKeyPress = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      // Stop listening if Enter is pressed
      if (isListening) stopListening();
      handleSendMessage(e as unknown as React.FormEvent);
    }
  };

  type FileEvent = ChangeEvent<HTMLInputElement> | ReactDragEvent<HTMLDivElement> | React.ClipboardEvent<HTMLTextAreaElement>;
  
  const handleFileSelect = (e: FileEvent) => {
      const selectedFiles: File[] = [];
  
      if ('clipboardData' in e) {
          if (e.clipboardData?.files) {
              selectedFiles.push(...Array.from(e.clipboardData.files));
          }
      } else if ('dataTransfer' in e) { // ReactDragEvent<HTMLDivElement>
          if (e.dataTransfer?.files) {
              selectedFiles.push(...Array.from(e.dataTransfer.files));
          }
      } else if ('target' in e && (e.target as HTMLInputElement).files) { // ChangeEvent<HTMLInputElement>
          const target = e.target as HTMLInputElement;
          if (target.files) {
              selectedFiles.push(...Array.from(target.files));
          }
      }
      
      const validFiles: File[] = selectedFiles.filter((file) => 
        (file.type.startsWith('image/') || file.type === 'application/pdf' || file.type.startsWith('text/') || file.type.startsWith('audio/') || file.type.startsWith('video/')) && file.size < 20 * 1024 * 1024 // 20MB limit
      );
  
      if (validFiles.length > 0) {
        setAttachments(prev => [...prev, ...validFiles]);
      }
  };

  const removeAttachment = (index: number) => {
    setAttachments(prev => prev.filter((_, i) => i !== index));
  };
  
  const handleVoiceInputToggle = () => {
      if (isLoading || isHistoryLoading) return;
      if (isListening) {
          stopListening();
      } else {
          // Clear current text if no attachments exist, otherwise append
          if (attachments.length === 0) {
              setInput('');
          }
          startListening(input);
      }
  };


  // --- Main Send Handler ---

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (isListening) stopListening();
    
    const trimmedInput = input.trim();
    
    if ((!trimmedInput && attachments.length === 0) || isLoading || isHistoryLoading) return;

    // 1. Convert attachments to Base64 payload
    const base64Attachments: FileAttachment[] = await Promise.all(
        attachments.map(file => fileToBase64(file))
    );
    
    // Check if the user's current settings include a system prompt to be passed to the API
    const globalSystemPrompt = settings?.globalSystemPrompt;
    const streamingEnabled = settings?.streamingEnabled ?? true; 
    
    const userMessage: ChatMessage = {
      id: uuidvv4(),
      text: trimmedInput,
      role: 'user',
      timestamp: new Date(),
      files: base64Attachments.length > 0 ? base64Attachments : undefined,
    };

    addMessage(userMessage);
    addMessage({ 
        id: BOT_PENDING_ID, 
        text: '...', 
        role: 'model', 
        timestamp: new Date() 
    } as ChatMessage);
    
    setInput('');
    setAttachments([]); 
    setIsLoading(true);

    try {
      const token = await getIdToken();
      
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`, 
        },
        body: JSON.stringify({
          message: trimmedInput,
          chatId: chatId, 
          files: base64Attachments, 
          // Pass the system prompt if this is a NEW chat (API route will use it if chatId is missing)
          globalSystemPrompt: chatId ? undefined : globalSystemPrompt, 
        }),
      });

      if (response.status === 401) {
          finalizeBotMessage('Session expired. Please log out and log back in.');
          return;
      }
      if (!response.ok || !response.body) {
        // Attempt to read error body if available
        let errorMsg = 'Sorry, Big AI ran into an internal error.';
        try {
            const errorData = await response.json();
            errorMsg = errorData.error || errorMsg;
        } catch {}
        finalizeBotMessage(errorMsg);
        return; 
      }
      
      const newChatId = response.headers.get('X-Chat-ID');
      if (newChatId && newChatId !== chatId) {
          onChatIdChange(newChatId); 
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let accumulatedText = '';

      // CONDITIONAL STREAMING LOGIC
      if (streamingEnabled) {
          // Streaming/Typing mode (Read chunk by chunk and update UI)
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            accumulatedText += chunk;
            updateBotStreamingMessage(chunk); 
          }
      } else {
          // Instant response mode (Wait for stream to finish reading entirely)
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            accumulatedText += decoder.decode(value);
          }
          // Display the final accumulated text all at once
          updateBotStreamingMessage(accumulatedText);
      }
      
      finalizeBotMessage(accumulatedText);

    } catch (error) {
      console.error('Error fetching AI response:', error);
      finalizeBotMessage('Sorry, Big AI ran into a communication error.');
    } finally {
      setIsLoading(false);
    }
  };
  
  // Scroll Anchor Effect
  useEffect(() => {
    if (!isHistoryLoading) {
        chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages, isHistoryLoading]);

  // --- Render ---

  if (isHistoryLoading) {
    return (
        <div className="flex flex-col h-full items-center justify-center" style={{backgroundColor: 'var(--bg-primary)', color: 'var(--text-secondary)'}}>
            <svg className="animate-spin h-8 w-8" style={{color: 'var(--accent-primary)'}} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <p className="mt-4">Loading conversation...</p>
        </div>
    );
  }

  return (
    <div className="flex flex-col h-full w-full" style={{backgroundColor: 'var(--bg-primary)'}}>
      <header className="p-4 border-b shadow-sm flex justify-between items-center" style={{backgroundColor: 'var(--header-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}>
        
        {/* === MOBILE SIDEBAR TOGGLE BUTTON === */}
        {isMobileView && (
            <button
                onClick={onToggleSidebar}
                className="p-2 rounded-lg transition mr-2 md:hidden"
                title="Toggle Sidebar"
                disabled={isLoading || isHistoryLoading}
                style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-primary)', border: '1px solid var(--border-color)'}}
            >
                 <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M4 6h16M4 12h16M4 18h7"></path></svg>
            </button>
        )}
        {/* ================================== */}

        <h1 className="font-semibold truncate max-w-[calc(100%-80px)]">
            {chatId ? messages[0]?.text.substring(0, 50) + '...' : 'New Conversation'}
        </h1>
        {/* Conversation Mode Button in Header */}
        <button
            onClick={onOpenConversationMode}
            className="p-2 rounded-lg transition"
            title="Start Conversation Mode (Voice Chat)"
            disabled={isLoading || isHistoryLoading}
            style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-primary)', border: '1px solid var(--border-color)'}}
        >
             <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
        </button>
      </header>
      
      {/* Chat Messages Display */}
      <div 
        className="flex-1 overflow-y-auto p-4 space-y-6"
        style={{backgroundColor: 'var(--bg-primary)'}}
        onDrop={(e) => { e.preventDefault(); handleFileSelect(e); }}
        onDragOver={(e) => { e.preventDefault(); e.currentTarget.style.boxShadow = `0 0 10px var(--accent-primary)`; }}
        onDragLeave={(e) => { e.preventDefault(); e.currentTarget.style.boxShadow = 'none'; }}
      >
        {messages.length === 0 && (
            <div className='flex flex-col items-center justify-center h-full text-gray-500' style={{color: 'var(--text-secondary)'}}>
                <h1 className='text-3xl font-bold mb-4' style={{color: 'var(--accent-primary)'}}>Big AI</h1>
                <p>Start a new conversation or drag files here!</p>
            </div>
        )}
        {messages.map((msg, index) => (
          <ChatBubble 
            key={msg.id + index} 
            message={msg} 
            isPending={msg.id === BOT_PENDING_ID} 
          />
        ))}
        {/* Scroll Anchor */}
        <div ref={chatEndRef} />
      </div>

      {/* Input Form Area */}
      <div className="p-4 border-t flex flex-col items-center" style={{backgroundColor: 'var(--header-bg)', borderColor: 'var(--border-color)'}}>
        
        {/* File Preview Area */}
        {attachments.length > 0 && (
            <div className='w-full max-w-2xl mb-3 flex flex-wrap gap-2 p-3 border rounded-lg' style={{borderColor: 'var(--border-color)', backgroundColor: 'var(--bg-secondary)'}}>
                {attachments.map((file, index) => (
                    <div key={index} className='relative flex items-center p-2 rounded-md text-sm' style={{backgroundColor: 'var(--ai-bubble-bg)', color: 'var(--text-primary)'}}>
                        <span className='truncate max-w-[150px]'>{file.name}</span>
                        <button 
                            type="button" 
                            onClick={() => removeAttachment(index)} 
                            className='ml-2 text-red-500 hover:text-red-700'
                        >
                            &times;
                        </button>
                    </div>
                ))}
            </div>
        )}


        <form onSubmit={handleSendMessage} className="flex w-full max-w-2xl border rounded-xl shadow-lg" style={{borderColor: 'var(--border-color)', backgroundColor: 'var(--card-bg)'}}>
            
            {/* Voice Input Button */}
            {recognitionSupported && (
                <button
                    type="button"
                    onClick={handleVoiceInputToggle}
                    className={`p-3 transition flex items-center justify-center shrink-0 ${isListening ? 'voice-input-active' : ''}`}
                    title={isListening ? "Stop Listening" : "Start Voice Input (STT)"}
                    disabled={isLoading || isHistoryLoading}
                    style={{color: isListening ? 'white' : 'var(--text-secondary)', borderRadius: '0.75rem 0 0 0.75rem'}}
                >
                    <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 11a7 7 0 01-7 7v0a7 7 0 01-7-7v0a7 7 0 0114 0zM12 18v3m4 0H8m6-12a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                </button>
            )}

            {/* File Upload Button */}
            <label htmlFor="file-upload" className="p-3 text-gray-500 hover:text-blue-500 cursor-pointer flex items-center justify-center shrink-0" style={{color: 'var(--text-secondary)', borderLeft: recognitionSupported ? '1px solid var(--border-color)' : 'none'}}>
                <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13.5"></path></svg>
                <input 
                    id="file-upload" 
                    type="file" 
                    multiple 
                    onChange={handleFileSelect as (e: ChangeEvent<HTMLInputElement>) => void}
                    className="hidden" 
                    disabled={isLoading || isHistoryLoading || isListening}
                />
            </label>

            <textarea
                ref={inputRef}
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleKeyPress}
                onPaste={handleFileSelect as (e: React.ClipboardEvent<HTMLTextAreaElement>) => void} 
                placeholder={isListening ? "Listening..." : "Message Big AI..."}
                className="flex-1 p-3 bg-transparent focus:outline-none resize-none overflow-y-auto max-h-[200px]"
                style={{ minHeight: '48px', color: 'var(--text-primary)' }}
                disabled={isLoading || isHistoryLoading || isListening}
                rows={1}
                autoFocus
            />
            
            {/* Send Button */}
            <button
              type="submit"
              className="px-4 py-3 text-white rounded-r-xl hover:opacity-90 transition disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
              disabled={isLoading || isHistoryLoading || isListening || (!input.trim() && attachments.length === 0)}
              style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}} // Use AI text color for contrast on accent background
            >
              <svg className="w-5 h-5 transform rotate-45 -mt-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
            </button>
        </form>
      </div>
    </div>
  );
}

--- END FILE: components\ChatArea.tsx ---

--- START FILE: components\ChatBubble.tsx ---

// components/ChatBubble.tsx
'use client';

import React, { useEffect, useMemo, useRef } from 'react';
import { ChatMessage, FileAttachment } from '@/types/chat';

// External Libraries for Markdown Rendering
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
// Removed: import 'prismjs/themes/prism-dark.css'; // Now imported in globals.css for global application

// Import specific Prism languages needed
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-markup';


// --- TTS / DICTATION UTILITY (Client-side implementation) ---
// Global state for TTS to ensure only one message is speaking at a time
let isSpeaking = false;
let currentUtterance: SpeechSynthesisUtterance | null = null;
let currentButtonRef: React.MutableRefObject<HTMLButtonElement | null> | null = null;

const SPEAK_ICON = `<svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M15.536 8.464l-2.071 2.071-2.071-2.071m4.142 4.142l-2.071 2.071m0 0l-2.071-2.071M12 21a9 9 0 110-18 9 9 0 010 18z"></path></svg>`;
const PAUSE_ICON = `<svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
const COPY_ICON = `<svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5v-2a2 2 0 012-2h2a2 2 0 012 2v2m-3 7h3m-3 4h3"></path></svg>`;
const CHECK_ICON = `<svg class="w-4 h-4 text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7"></path></svg>`;

const startSpeech = (text: string, buttonRef: React.MutableRefObject<HTMLButtonElement | null>) => {
    if (!window.speechSynthesis) return console.error('Speech synthesis not supported.');

    // Cancel any current speaking message
    if (window.speechSynthesis.speaking || window.speechSynthesis.paused) {
        window.speechSynthesis.cancel();
    }
    
    // Reset icon on the previously speaking button, if applicable
    if (currentButtonRef && currentButtonRef.current) {
        const iconSpan = currentButtonRef.current.querySelector('[data-icon="tts"]');
        if (iconSpan) iconSpan.innerHTML = SPEAK_ICON;
    }

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'en-US';

    utterance.onstart = () => {
        isSpeaking = true;
        currentUtterance = utterance;
        currentButtonRef = buttonRef;
        const iconSpan = buttonRef.current?.querySelector('[data-icon="tts"]');
        if (iconSpan) iconSpan.innerHTML = PAUSE_ICON;
    };
    utterance.onend = () => {
        isSpeaking = false;
        currentUtterance = null;
        currentButtonRef = null;
        const iconSpan = buttonRef.current?.querySelector('[data-icon="tts"]');
        if (iconSpan) iconSpan.innerHTML = SPEAK_ICON;
    };
    utterance.onerror = (event) => {
        console.error('Speech synthesis error:', event.error);
        isSpeaking = false;
        currentUtterance = null;
        currentButtonRef = null;
    };

    window.speechSynthesis.speak(utterance);
}

const toggleSpeech = (text: string, buttonRef: React.MutableRefObject<HTMLButtonElement | null>) => {
    if (!window.speechSynthesis) return;

    if (isSpeaking && currentUtterance?.text === text) {
        if (window.speechSynthesis.paused) {
            window.speechSynthesis.resume();
        } else {
            window.speechSynthesis.pause();
        }
    } else {
        startSpeech(text, buttonRef);
    }
};

// --- MARKED CUSTOM RENDERER ---
const renderer = new marked.Renderer();

// Custom code block renderer
renderer.code = ({ text, lang, escaped }: { text: string; lang?: string; escaped?: boolean }): string => {
    const language = lang || 'plaintext';
    // Marked escapes HTML entities; we need to unescape for Prism to work correctly.
    const unescapedCode = text.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    
    const header = `
        <div class="code-block-header flex justify-between items-center">
            <span class="text-xs font-semibold uppercase" style="color: var(--text-secondary);">${language}</span>
            <button type="button" class="copy-button p-1 rounded transition flex items-center gap-1 text-xs" 
                data-code="${encodeURIComponent(unescapedCode)}" 
                style="color: var(--text-secondary); padding: 0.25rem 0.5rem;">
                <span data-icon="clipboard" style="color: var(--text-secondary);">${COPY_ICON}</span>
                <span data-text="Copy">Copy</span>
            </button>
        </div>
    `;
    
    // We wrap the standard <pre> tag in the .code-block-container defined in CSS
    // The inner <pre><code> is where Prism.js applies its magic
    return `
        <div class="code-block-container" data-lang="${language}">
            ${header}
            <pre><code class="language-${language}">${unescapedCode}</code></pre>
        </div>
    `;
};


marked.setOptions({
    breaks: true,
    renderer: renderer,
    gfm: true,
});

// --- REACT COMPONENT ---

interface ChatBubbleProps {
    message: ChatMessage;
    isPending: boolean;
}

const ChatBubble: React.FC<ChatBubbleProps> = ({ message, isPending }) => {
    const contentRef = useRef<HTMLDivElement>(null);
    const copyButtonRef = useRef<HTMLButtonElement | null>(null);
    const dictateButtonRef = useRef<HTMLButtonElement | null>(null);
    const isUser = message.role === 'user';

    // Parse and sanitize markdown content
    const sanitizedHtml = useMemo(() => {
        if (isUser) {
            // Only convert simple line breaks to <p> tags for cleaner display of user input
            // NOTE: Must sanitize before applying manual line breaks if using DOMPurify
            const safeText = DOMPurify.sanitize(message.text);
            return `<p>${safeText.replace(/\n/g, '<br/>')}</p>`;
        }
        
        const html = marked.parse(message.text);
        // DOMPurify sanitizes the entire generated HTML
        return DOMPurify.sanitize(html as string);
    }, [message.text, isUser]);

    // Apply syntax highlighting and copy listeners after rendering
    useEffect(() => {
        if (contentRef.current && !isUser) {
            // 1. Syntax highlighting
            contentRef.current.querySelectorAll('pre code').forEach((block) => {
                try {
                    // This is client-side code, Prism should be globally available via imported modules
                    Prism.highlightElement(block);
                } catch (e) {
                    console.error("Prism highlighting failed:", e);
                }
            });
            
            // 2. Setup Copy Listeners for code blocks
            contentRef.current.querySelectorAll('.copy-button').forEach(button => {
                const encodedCode = button.getAttribute('data-code');
                if (!encodedCode) return;

                const code = decodeURIComponent(encodedCode);
                
                // Use functional component lifecycle to manage event listeners for cleanliness
                const handleCopy = (e: Event) => {
                    e.preventDefault();
                    navigator.clipboard.writeText(code).then(() => {
                        const iconSpan = button.querySelector('[data-icon="clipboard"]');
                        const textSpan = button.querySelector('[data-text]');
                        
                        // Checkmark icon
                        if (iconSpan) iconSpan.innerHTML = CHECK_ICON;
                        if (textSpan) textSpan.textContent = "Copied!";

                        setTimeout(() => {
                            // Clipboard icon
                            if (iconSpan) iconSpan.innerHTML = COPY_ICON;
                            if (textSpan) textSpan.textContent = "Copy";
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                    });
                };
                
                // Ensure listener is added only once
                button.removeEventListener('click', handleCopy as EventListener); 
                button.addEventListener('click', handleCopy as EventListener);
            });
        }
    }, [sanitizedHtml, isUser]);

    // Cleanup TTS on unmount
    useEffect(() => {
        return () => {
            // Check if this component's button was the one currently speaking
            if (currentButtonRef === dictateButtonRef && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                isSpeaking = false;
                currentUtterance = null;
                currentButtonRef = null;
            }
        };
    }, []);

    const handleCopyText = () => {
        navigator.clipboard.writeText(message.text)
            .then(() => {
                 // Provide visual feedback by temporarily changing the icon
                 if (copyButtonRef.current) {
                     const iconSpan = copyButtonRef.current.querySelector('svg');
                     if (iconSpan) {
                         // Use innerHTML update for reliability
                         iconSpan.outerHTML = CHECK_ICON;
                     }
                     
                     // Temporarily set the color for the entire button/icon
                     copyButtonRef.current.style.color = 'var(--accent-success)';

                     setTimeout(() => {
                         if (copyButtonRef.current) {
                             copyButtonRef.current.style.color = 'var(--text-secondary)';
                             const resetIconSpan = copyButtonRef.current.querySelector('svg');
                             if (resetIconSpan) {
                                  resetIconSpan.outerHTML = COPY_ICON;
                             }
                         }
                     }, 2000);
                 }
            })
            .catch(err => console.error("Copy failed:", err));
    };


    const renderAttachments = (files: FileAttachment[]) => (
        <div className="flex flex-wrap gap-2 mt-2">
            {files.map((file, index) => {
                const isImage = file.mimeType.startsWith('image/');
                const isTooLarge = file.size > 1024 * 1024 * 5; // 5MB heuristic
                
                return (
                    <div key={index} className="flex flex-col items-center p-2 rounded-lg max-w-[150px]" style={{border: '1px solid var(--border-color)', backgroundColor: 'var(--bg-primary)'}}>
                        {isImage && !isTooLarge ? (
                            <img 
                                src={`data:${file.mimeType};base64,${file.base64Data}`}
                                alt={file.filename}
                                className="w-full h-auto object-cover rounded-md max-h-24"
                            />
                        ) : (
                            // File icon placeholder
                            <svg className="w-8 h-8 shrink-0" style={{color: 'var(--accent-secondary)'}} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="1.5"><path strokeLinecap="round" strokeLinejoin="round" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-2.414-2.414A1 1 0 0015.586 6H7a2 2 0 00-2 2v11a2 2 0 002 2zM17 17H7m10-4H7m4-4H7"></path></svg>
                        )}
                        <span className="text-xs truncate w-full text-center mt-1" style={{color: 'var(--text-secondary)'}}>
                            {file.filename}
                        </span>
                    </div>
                );
            })}
        </div>
    );

    return (
        // Added 'group' class here to enable CSS hover effects for message actions
        <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} group`}>
            <div className="flex items-start max-w-[75%]">
                {/* Avatar / Role Indicator (AI) */}
                <div className={`p-2 rounded-full text-white mr-3 shrink-0 self-start ${isUser ? 'hidden' : 'bg-blue-600'}`} style={{backgroundColor: isUser ? 'var(--text-primary)' : 'var(--accent-primary)'}}>
                    {isUser ? '' : 'AI'}
                </div>
                
                {/* Bubble Content */}
                <div
                    className={`p-3 rounded-xl shadow-md transition duration-300 ease-in-out break-words relative ${
                        isUser
                            ? 'rounded-bl-none'
                            : 'rounded-tr-none border'
                    }`}
                    style={{
                        backgroundColor: isUser ? 'var(--user-bubble-bg)' : 'var(--ai-bubble-bg)',
                        color: isUser ? 'var(--user-bubble-text)' : 'var(--ai-bubble-text)',
                        borderColor: isUser ? 'transparent' : 'var(--border-color)'
                    }}
                >
                    {/* Render Multimodal Attachments first */}
                    {message.files && renderAttachments(message.files)}

                    {/* Render Text Content */}
                    <div 
                        ref={contentRef}
                        className={`message-content ${isUser ? '' : 'prose max-w-none'}`} 
                        dangerouslySetInnerHTML={{ __html: sanitizedHtml }}
                    />

                    {/* Message Actions (Copy/Dictate) */}
                    <div className="absolute bottom-1 flex space-x-2 opacity-0 group-hover:opacity-100 transition-opacity p-1 rounded-lg" 
                        style={{
                            backgroundColor: 'var(--header-bg)', 
                            border: '1px solid var(--border-color)',
                            // Use ternary operator to position the action buttons correctly
                            right: isUser ? '10px' : 'auto',
                            left: isUser ? 'auto' : '10px',
                            bottom: '10px',
                        }}
                    >
                        
                        {/* Copy Button */}
                        <button 
                            ref={copyButtonRef}
                            onClick={handleCopyText} 
                            title="Copy Message"
                            className="p-1 rounded transition hover:bg-[var(--sidebar-item-hover)] flex items-center justify-center" // Added flex classes
                            style={{color: 'var(--text-secondary)'}}
                        >
                            {/* FIX: Explicitly set stroke and color for SVG consistency */}
                            <svg className="w-4 h-4 shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2" style={{color: 'inherit', stroke: 'currentColor'}}><path strokeLinecap="round" strokeLinejoin="round" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5v-2a2 2 0 012-2h2a2 2 0 012 2v2m-3 7h3m-3 4h3"></path></svg>
                        </button>

                        {/* Dictate Button (Only when not pending) */}
                        {!isPending && (
                             <button
                                ref={dictateButtonRef}
                                onClick={() => toggleSpeech(message.text, dictateButtonRef)}
                                title="Dictate Message (TTS)"
                                className="p-1 rounded transition hover:bg-[var(--sidebar-item-hover)] flex items-center justify-center" // Added flex classes
                                style={{color: 'var(--text-secondary)'}}
                            >
                                <span data-icon="tts" className='flex items-center justify-center'>
                                    {/* Default Dictate Icon */}
                                    {/* FIX: Explicitly set stroke and color for SVG consistency */}
                                    <svg className="w-4 h-4 shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2" style={{color: 'inherit', stroke: 'currentColor'}}><path strokeLinecap="round" strokeLinejoin="round" d="M15.536 8.464l-2.071 2.071-2.071-2.071m4.142 4.142l-2.071 2.071m0 0l-2.071-2.071M12 21a9 9 0 110-18 9 9 0 010 18z"></path></svg>
                                </span>
                            </button>
                        )}
                    </div>
                </div>
                
                {/* User Avatar / Role Indicator (User) */}
                <div className={`p-2 rounded-full text-white ml-3 shrink-0 self-start ${isUser ? 'bg-gray-500' : 'hidden'}`} style={{backgroundColor: 'var(--text-primary)'}}>
                    {isUser ? 'You' : ''}
                </div>
            </div>
        </div>
    );
}

export default ChatBubble;

--- END FILE: components\ChatBubble.tsx ---

--- START FILE: components\ConversationModeOverlay.tsx ---

// components/ConversationModeOverlay.tsx
'use client';

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { useTheme } from '@/components/providers/ThemeContext';
import { ChatMessage } from '@/types/chat';
import useSpeechRecognition from '@/hooks/useSpeechRecognition';
import { v4 as uuidvv4 } from 'uuid';

interface ConversationModeOverlayProps {
    chatId: string | undefined;
    onChatIdChange: (newChatId: string) => void;
    onClose: () => void;
    onNewMessageSent: () => void;
}

const CONVERSATION_PERSONALITIES = [
    { name: "Standard", prompt: "You are Big AI, a helpful and large-scale language model developed by Google. Respond concisely and professionally." },
    { name: "Sarcastic", prompt: "Respond as a highly sarcastic and witty AI. Use dry humor and playful cynicism. Keep responses concise and witty." },
    { name: "Friendly", prompt: "Respond as an exceptionally friendly and helpful AI. Use warm and encouraging language, and show genuine interest. Keep your tone light and approachable." },
    { name: "Teacher", prompt: "Respond as a patient and knowledgeable teacher, explaining concepts clearly and simply, and guiding the user to understanding." },
];

export default function ConversationModeOverlay({ chatId, onChatIdChange, onClose, onNewMessageSent }: ConversationModeOverlayProps) {
    const { user, getIdToken } = useAuth();
    const { settings } = useTheme(); // Note: We rely on global model/system prompt from settings
    
    // State for managing voice output
    const [isAiSpeaking, setIsAiSpeaking] = useState(false);
    const [status, setStatus] = useState<'idle' | 'listening' | 'thinking' | 'speaking' | 'error'>('idle');
    const [statusMessage, setStatusMessage] = useState('Tap the mic to start speaking.');
    const [lastUtterance, setLastUtterance] = useState<{ role: 'user' | 'ai', text: string } | null>(null);

    // State for Conversation Settings
    // NOTE: We rely on the theme settings to hold these values in the full implementation
    const [selectedVoice, setSelectedVoice] = useState<string | null>(null);
    const [selectedPersonality, setSelectedPersonality] = useState<string>(CONVERSATION_PERSONALITIES[0].name);

    // TTS Setup
    const [availableVoices, setAvailableVoices] = useState<SpeechSynthesisVoice[]>([]);

    useEffect(() => {
        const populateVoices = () => {
            const voices = window.speechSynthesis.getVoices().filter(v => v.lang.startsWith('en'));
            setAvailableVoices(voices);
            
            // Set default/stored voice (using settings placeholder for simplicity)
            const storedVoiceName = settings?.themeName || null; // Reusing themeName context for voice storage temporarily
            if (storedVoiceName && voices.length > 0) {
                // Find a default voice if the stored one isn't available
                setSelectedVoice(voices.find(v => v.name === storedVoiceName)?.name || voices[0].name);
            } else if (voices.length > 0) {
                 // Set a default if nothing is stored
                 setSelectedVoice(voices[0].name);
            }
        };

        populateVoices();
        if (window.speechSynthesis.onvoiceschanged !== undefined) {
            window.speechSynthesis.onvoiceschanged = populateVoices;
        }

        // Load conversation settings from global settings
        if (settings) {
            // Check if globalSystemPrompt is active (handled via the PromptManager)
            if (settings.globalSystemPrompt.trim()) {
                setSelectedPersonality('Custom Prompt');
            } else {
                 // Fallback to the default personality if custom prompt is inactive
                setSelectedPersonality(CONVERSATION_PERSONALITIES[0].name);
            }
        }
        
        // Cleanup TTS on component unmount
        return () => {
            if (window.speechSynthesis.speaking || window.speechSynthesis.paused) {
                window.speechSynthesis.cancel();
            }
        };

    }, [settings]);

    // Speech Recognition Hook for the Conversation Loop
    const { 
        isListening, 
        transcript, 
        startListening, 
        stopListening, 
        recognitionSupported,
        resetTranscript
    } = useSpeechRecognition({
        continuous: false, // Ensure it stops after detecting a pause
        onStart: () => {
            // Only update status if AI isn't currently speaking
            if (!isAiSpeaking) {
                setStatus('listening');
                setStatusMessage('Listening...');
                setLastUtterance({ role: 'user', text: '' });
            }
        },
        onFinalTranscript: (finalTranscript) => {
            setLastUtterance({ role: 'user', text: finalTranscript });
            // Immediately stop listening if we got a final transcript, as continuous is false
            stopListening();
            handleUserSpeechEnd(finalTranscript);
        },
        onInterimTranscript: (interimTranscript) => {
             // Update interim text displayed to user
             setLastUtterance(prev => ({ role: 'user', text: (prev?.text || '') + interimTranscript }));
        },
        onEnd: () => {
            if (status === 'listening') {
                // If it ended without a final transcript (e.g., no speech detected, or user paused too long)
                setStatus('idle');
                setStatusMessage('No speech detected. Tap the mic to try again.');
            }
        },
        onError: (error) => {
            console.error("Conversation STT Error:", error);
            setStatus('error');
            setStatusMessage(`Error: ${error}. Tap the mic to restart.`);
             setTimeout(() => {
                setStatus('idle');
                setStatusMessage('Tap the mic to start speaking.');
            }, 5000);
        }
    });


    // --- Core Conversation Loop Handlers ---

    const handleUserSpeechEnd = async (userText: string) => {
        if (!userText.trim()) {
            setStatus('idle');
            setStatusMessage('No speech detected. Tap the mic to try again.');
            return;
        }
        
        setStatus('thinking');
        setStatusMessage('AI is thinking...');

        try {
            const token = await getIdToken();
            
            // Determine the system prompt based on settings
            const systemPrompt = settings?.globalSystemPrompt.trim();
            const personalityPrompt = CONVERSATION_PERSONALITIES.find(p => p.name === selectedPersonality)?.prompt;
            
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`, 
                },
                body: JSON.stringify({
                    message: userText,
                    chatId: chatId, 
                    // Pass system prompt only for NEW chats, or if we want to explicitly use a personality prompt
                    globalSystemPrompt: chatId ? systemPrompt : (systemPrompt || personalityPrompt), 
                }),
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `API returned status ${response.status}`);
            }

            const newChatId = response.headers.get('X-Chat-ID');
            if (newChatId && newChatId !== chatId) {
                onChatIdChange(newChatId); 
            }
            
            // Read streamed response (assuming the API is designed to return plain text in this route)
            const reader = response.body?.getReader();
            const decoder = new TextDecoder();
            let fullBotResponse = '';

            // This is a simplified stream reading compared to ChatArea, as we need the full text before TTS
            while (reader) {
                 const { done, value } = await reader.read();
                 if (done) break;
                 fullBotResponse += decoder.decode(value);
            }
            
            setLastUtterance({ role: 'ai', text: fullBotResponse });
            startSpeaking(fullBotResponse);
            onNewMessageSent(); // Trigger sidebar refresh
            
        } catch (error) {
            console.error('Conversation AI Error:', error);
            setStatus('error');
            setStatusMessage(`AI Error: ${error instanceof Error ? error.message : 'Unknown communication error.'}`);
            setTimeout(() => {
                if (recognitionSupported) {
                    setStatus('idle');
                    setStatusMessage('Tap the mic to restart.');
                }
            }, 5000);
        }
    };
    
    const startSpeaking = (text: string) => {
        if (!window.speechSynthesis) return;

        setStatus('speaking');
        setStatusMessage('AI Speaking...');
        setIsAiSpeaking(true);

        const utterance = new SpeechSynthesisUtterance(text);
        
        const voice = availableVoices.find(v => v.name === selectedVoice);
        if (voice) {
            utterance.voice = voice;
        }
        
        utterance.onend = () => {
            setIsAiSpeaking(false);
            // After AI speaks, restart listening
            if (recognitionSupported) {
                 // Slight delay before restarting mic to prevent capturing residual sound
                 setTimeout(() => startListening(), 500); 
            } else {
                 setStatus('idle');
                 setStatusMessage('Conversation finished. Speech recognition disabled.');
            }
        };
        utterance.onerror = (e) => {
            console.error('TTS Error:', e);
            setIsAiSpeaking(false);
            if (recognitionSupported) {
                 setTimeout(() => startListening(), 500); 
            } else {
                 setStatus('idle');
            }
        }

        window.speechSynthesis.speak(utterance);
    };

    const handleMicToggle = () => {
        if (!user) return;
        
        if (isAiSpeaking) {
            window.speechSynthesis.cancel();
            setIsAiSpeaking(false);
            setStatus('idle');
            setStatusMessage('AI speech canceled. Tap the mic to restart.');
        } else if (isListening) {
            stopListening();
            setStatus('idle');
            setStatusMessage('Listening stopped. Tap the mic to restart.');
        } else {
            if (!recognitionSupported) {
                 setStatus('error');
                 setStatusMessage("Speech Recognition is not supported in this browser.");
                 return;
            }
            // Reset state and start listening
            resetTranscript();
            setLastUtterance(null);
            startListening();
        }
    };
    
    // UI mapping
    const soundBlobState = isListening ? 'listening' : (isAiSpeaking ? 'speaking' : 'idle');
    const micButtonState = isListening || isAiSpeaking;

    const currentPersonalityDisplay = settings?.globalSystemPrompt.trim() 
        ? 'Custom Prompt' 
        : CONVERSATION_PERSONALITIES.find(p => p.name === selectedPersonality)?.name || 'Standard';

    return (
        <div 
            className="fixed inset-0 flex flex-col items-center justify-center p-4 transition-opacity duration-500"
            style={{backgroundColor: 'var(--conversation-bg)', color: 'var(--conversation-text)', zIndex: 100}}
        >
            <button id="conversation-mode-close-btn" onClick={onClose} className="absolute top-4 right-4 p-2 rounded-full hover:bg-black/10 transition" style={{color: 'var(--text-secondary)'}}>
                <svg className="w-8 h-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>

            <div className="conversation-controls absolute top-4 flex gap-4 p-3 rounded-full border" style={{borderColor: 'var(--border-color)', backgroundColor: 'var(--card-bg)'}}>
                <div className='flex items-center gap-2 text-sm'>
                    <span style={{color: 'var(--accent-primary)'}}>Voice:</span> 
                    <select
                        value={selectedVoice || ''}
                        onChange={(e) => setSelectedVoice(e.target.value)}
                        disabled={isListening || isAiSpeaking}
                        className="p-1 rounded border" style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--text-primary)', borderColor: 'var(--border-color)'}}
                    >
                        {availableVoices.map(voice => (
                            <option key={voice.name} value={voice.name}>{voice.name}</option>
                        ))}
                    </select>
                </div>
                <div className='flex items-center gap-2 text-sm'>
                     <span style={{color: 'var(--accent-primary)'}}>Personality:</span> 
                    <span className='font-semibold'>{currentPersonalityDisplay}</span>
                </div>
            </div>

            {/* Sound Blob Animation Area */}
            <div className="relative w-72 h-72 flex items-center justify-center mt-20 mb-8">
                {/* Note: Tailwind doesn't easily support the complex CSS animations/shapes from Part 2,
                    so we use simple concentric circles driven by state variables. */}
                <div 
                    className={`absolute w-full h-full rounded-full transition-all duration-500 blur-lg 
                        ${soundBlobState === 'listening' ? 'scale-110 opacity-70' : soundBlobState === 'speaking' ? 'scale-105 opacity-80' : 'scale-90 opacity-50'}`}
                    style={{backgroundColor: 'var(--conversation-indicator)'}}
                ></div>
                 <div 
                    className={`absolute w-40 h-40 flex items-center justify-center rounded-full transition-all duration-500`}
                    style={{backgroundColor: 'var(--card-bg)', color: 'var(--conversation-indicator)'}}
                >
                    <svg className="w-16 h-16" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M4.343 19.657l.707-.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                </div>
            </div>

            <div className={`text-3xl font-extrabold text-center mb-6 min-h-[3rem] transition-colors duration-300`} 
                 style={{color: status === 'error' ? 'var(--accent-error)' : 'var(--text-primary)'}}
            >
                {statusMessage}
            </div>

            <div className="w-full max-w-xl h-24 overflow-y-auto p-3 rounded-xl border mb-8" 
                 style={{backgroundColor: 'var(--bg-secondary)', borderColor: 'var(--border-color)', color: 'var(--text-secondary)'}}
            >
                {lastUtterance ? (
                    <p className={`text-lg ${lastUtterance.role === 'user' ? 'text-blue-400' : 'text-green-400'} font-semibold truncate`}>
                        {lastUtterance.role === 'user' ? 'You: ' : 'AI: '}
                        {lastUtterance.text}
                    </p>
                ) : (
                    <p className='text-center italic'>Recent speech appears here.</p>
                )}
            </div>

            <button 
                onClick={handleMicToggle} 
                className={`w-20 h-20 rounded-full shadow-xl transition-all duration-300 ${micButtonState ? 'voice-input-active' : ''}`}
                title={micButtonState ? "Stop" : "Start Listening"}
                style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}
            >
                <svg className="w-10 h-10 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 11a7 7 0 01-7 7v0a7 7 0 01-7-7v0a7 7 0 0114 0zM12 18v3m4 0H8m6-12a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
            </button>
            <p className='text-xs mt-4' style={{color: 'var(--text-secondary)'}}>
                {isAiSpeaking ? 'Click to stop AI speech.' : (isListening ? 'Click to stop listening.' : 'Click to speak.')}
            </p>
        </div>
    );
}

--- END FILE: components\ConversationModeOverlay.tsx ---

--- START FILE: components\PromptManager.tsx ---

// components/PromptManager.tsx
'use client';

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { useTheme } from '@/components/providers/ThemeContext';
import { PromptTemplate, UserSettings } from '@/types/chat';
import { v4 as uuidv4 } from 'uuid';

interface PromptManagerProps {
    onClose: () => void;
}

const MODELS = [
    { id: 'gemini-3-pro-preview', name: 'Gemini 3.0 Pro' },
    { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro' },
    { id: 'gemini-2.5-flash-preview-09-2025', name: 'Gemini 2.5 Flash (Recommended)' },
    { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash (Stable)' },
    { id: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash Lite' },
];

export default function PromptManager({ onClose }: PromptManagerProps) {
    const { user } = useAuth();
    const { settings, updateSettings } = useTheme();
    
    // Local state for forms
    const [globalPrompt, setGlobalPrompt] = useState(settings?.globalSystemPrompt || '');
    const [apiKeyInput, setApiKeyInput] = useState(settings?.apiKey || '');
    const [templates, setTemplates] = useState<PromptTemplate[]>(settings?.templates || []);

    const [templateName, setTemplateName] = useState('');
    const [templateContent, setTemplateContent] = useState('');
    const [editingTemplateId, setEditingTemplateId] = useState<string | null>(null);
    const [statusMessage, setStatusMessage] = useState<string | null>(null);

    // --- Global Prompt/Model/API Key Handlers ---

    const handleSaveGlobalSettings = async (e: React.FormEvent) => {
        e.preventDefault();
        const newPrompt = globalPrompt.trim();

        await updateSettings({
            globalSystemPrompt: newPrompt,
            globalModel: settings?.globalModel, // Keep model synced
            apiKey: apiKeyInput.trim() || null,
        });

        setStatusMessage('Global settings saved successfully!');
        setTimeout(() => setStatusMessage(null), 3000);
    };

    const handleClearGlobalPrompt = async () => {
        setGlobalPrompt('');
        await updateSettings({ globalSystemPrompt: '' });
        setStatusMessage('Global prompt cleared.');
        setTimeout(() => setStatusMessage(null), 3000);
    };
    
    const handleModelChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        updateSettings({ globalModel: e.target.value });
    };

    // --- Template Handlers ---

    const handleClearTemplateForm = () => {
        setTemplateName('');
        setTemplateContent('');
        setEditingTemplateId(null);
    };

    const handleSaveTemplate = async () => {
        if (!templateName.trim() || !templateContent.trim()) {
            setStatusMessage('Template name and content are required.');
            return;
        }

        const updatedTemplates = [...templates];
        const newTemplate: PromptTemplate = {
            id: editingTemplateId || uuidv4(),
            name: templateName.trim(),
            content: templateContent.trim(),
        };

        if (editingTemplateId) {
            const index = updatedTemplates.findIndex(t => t.id === editingTemplateId);
            if (index !== -1) {
                updatedTemplates[index] = newTemplate;
                setStatusMessage('Template updated successfully!');
            }
        } else {
            updatedTemplates.push(newTemplate);
            setStatusMessage('Template saved successfully!');
        }

        setTemplates(updatedTemplates);
        await updateSettings({ templates: updatedTemplates });
        handleClearTemplateForm();
        setTimeout(() => setStatusMessage(null), 3000);
    };

    const handleEditTemplate = (template: PromptTemplate) => {
        setTemplateName(template.name);
        setTemplateContent(template.content);
        setEditingTemplateId(template.id);
    };
    
    const handleDeleteTemplate = async (templateId: string) => {
        if (!window.confirm('Are you sure you want to delete this template?')) return;
        
        const updatedTemplates = templates.filter(t => t.id !== templateId);
        setTemplates(updatedTemplates);
        await updateSettings({ templates: updatedTemplates });
        
        if (editingTemplateId === templateId) {
            handleClearTemplateForm();
        }

        // If the active global prompt matches the deleted template, clear it too.
        if (settings?.globalSystemPrompt === templates.find(t => t.id === templateId)?.content) {
             setGlobalPrompt('');
             await updateSettings({ globalSystemPrompt: '' });
        }

        setStatusMessage('Template deleted.');
        setTimeout(() => setStatusMessage(null), 3000);
    };

    const handleUseTemplate = async (content: string) => {
        setGlobalPrompt(content);
        await updateSettings({ globalSystemPrompt: content });
        setStatusMessage('Template activated as Global System Prompt!');
        setTimeout(() => setStatusMessage(null), 3000);
    };

    const globalPromptIsActive = globalPrompt.trim() !== '';

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
            {/* FIX: Use max-w-full and w-full to prevent horizontal overflow on small screens */}
            <div className="p-8 rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-y-auto border" style={{backgroundColor: 'var(--card-bg)', color: 'var(--text-primary)', borderColor: 'var(--border-color)'}}>
                
                <div className="flex justify-between items-center mb-6 border-b pb-3" style={{borderColor: 'var(--border-color)'}}>
                    <h2 className="text-2xl font-bold flex items-center gap-2">
                        <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-primary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        Prompt & API Configuration
                    </h2>
                    <button onClick={onClose} className="p-1 rounded hover:opacity-80 transition" style={{color: 'var(--text-secondary)'}}>
                        <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                
                {/* Status Message */}
                {statusMessage && (
                    <div className={`p-3 mb-4 text-sm rounded-lg text-center ${statusMessage.includes('saved') || statusMessage.includes('activated') ? 'bg-green-600 text-white' : 'bg-red-600 text-white'}`}>
                        {statusMessage}
                    </div>
                )}

                {/* --- API Key Management --- */}
                <div className="mb-6 p-4 rounded-lg border" style={{backgroundColor: 'var(--bg-secondary)', borderColor: 'var(--border-color)'}}>
                    <h3 className="text-lg font-bold mb-3 flex items-center gap-2">
                        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-secondary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 7a2 2 0 012 2v5a2 2 0 01-2 2h-2m-3-1a2 2 0 00-2 2v5m-3-4a2 2 0 002 2h4a2 2 0 002-2v-5a2 2 0 00-2-2m0 0a2 2 0 100-4 2 2 0 000 4z"></path></svg>
                        Gemini API Key
                    </h3>
                    <div className="flex items-center gap-2">
                        <input
                            type="password"
                            value={apiKeyInput}
                            onChange={(e) => setApiKeyInput(e.target.value)}
                            placeholder="Enter your private Gemini API Key (optional)"
                            className="w-full p-2 rounded-md border text-sm"
                            style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                        />
                         <button onClick={handleSaveGlobalSettings} className="p-2 rounded-md transition" style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}>
                            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M8 7H5a2 2 0 00-2 2v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                        </button>
                    </div>
                    <p className="text-xs mt-1" style={{color: apiKeyInput.trim() ? 'var(--accent-success)' : 'var(--accent-error)'}}>
                        {apiKeyInput.trim() ? 'Key is set. Your key will be prioritized for API calls.' : 'No key set. Using server fallback key.'}
                    </p>
                </div>

                {/* --- Global System Prompt --- */}
                <form onSubmit={handleSaveGlobalSettings} className="mb-6 p-4 rounded-lg border" style={{backgroundColor: 'var(--bg-secondary)', borderColor: 'var(--border-color)'}}>
                    <h3 className="text-lg font-bold mb-3 flex items-center gap-2">
                        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: globalPromptIsActive ? 'var(--accent-primary)' : 'var(--text-secondary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                        Global System Prompt {globalPromptIsActive && <span className='text-xs font-normal' style={{color: 'var(--accent-primary)'}}>(Active)</span>}
                    </h3>
                    <textarea
                        value={globalPrompt}
                        onChange={(e) => setGlobalPrompt(e.target.value)}
                        rows={4}
                        placeholder="Define the AI's personality/behavior for new chats (e.g., 'You are a highly sarcastic chef.')."
                        className="w-full p-3 rounded-md border resize-none"
                        style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                    />
                    <div className="flex justify-between items-center mt-4">
                        <button 
                            type="button"
                            onClick={handleClearGlobalPrompt} 
                            className="px-3 py-2 text-sm rounded-lg transition" 
                            style={{backgroundColor: 'var(--accent-error)', color: 'white'}}
                        >
                            Clear Prompt
                        </button>
                        <button 
                            type="submit"
                            className="px-4 py-2 text-sm rounded-lg transition"
                            style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}
                        >
                            Save Prompt
                        </button>
                    </div>
                </form>

                {/* --- Prompt Templates Management --- */}
                <div className="p-4 rounded-lg border" style={{backgroundColor: 'var(--bg-secondary)', borderColor: 'var(--border-color)'}}>
                    <h3 className="text-lg font-bold mb-4 flex items-center gap-2">
                        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-primary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                        Prompt Templates ({templates.length})
                    </h3>
                    
                    {/* Template Input Form */}
                    <div className="mb-4 space-y-2">
                        <input
                            type="text"
                            value={templateName}
                            onChange={(e) => setTemplateName(e.target.value)}
                            placeholder="Template Name (e.g., 'Sarcastic AI')"
                            className="w-full p-2 rounded-md border text-sm"
                            style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                        />
                        <textarea
                            value={templateContent}
                            onChange={(e) => setTemplateContent(e.target.value)}
                            rows={3}
                            placeholder="Enter the reusable system prompt content here."
                            className="w-full p-3 rounded-md border resize-none text-sm"
                            style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                        />
                        <div className="flex justify-end gap-2 pt-2">
                            <button 
                                type="button"
                                onClick={handleClearTemplateForm} 
                                className="px-3 py-2 text-sm rounded-lg transition" 
                                style={{backgroundColor: 'var(--bg-primary)', color: 'var(--text-secondary)', border: '1px solid var(--border-color)'}}
                            >
                                Clear Form
                            </button>
                            <button 
                                type="button"
                                onClick={handleSaveTemplate}
                                className="px-4 py-2 text-sm rounded-lg transition"
                                style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}
                            >
                                {editingTemplateId ? 'Update Template' : 'Save New Template'}
                            </button>
                        </div>
                    </div>
                    
                    {/* Saved Templates List */}
                    <ul className="space-y-3 max-h-60 overflow-y-auto pr-2 pt-4 border-t" style={{borderColor: 'var(--border-color)'}}>
                        {templates.length === 0 ? (
                            <li className="text-center text-sm p-4" style={{color: 'var(--text-secondary)'}}>No templates saved yet.</li>
                        ) : (
                            templates.map(template => (
                                <li key={template.id} className="p-3 rounded-lg border" style={{backgroundColor: 'var(--bg-primary)', borderColor: 'var(--border-color)'}}>
                                    <div className="font-semibold mb-1 truncate" style={{color: 'var(--accent-primary)'}}>{template.name}</div>
                                    <p className="text-xs mb-2 truncate" style={{color: 'var(--text-secondary)'}}>
                                        {template.content.substring(0, 100) + (template.content.length > 100 ? '...' : '')}
                                    </p>
                                    <div className="flex gap-2 justify-end text-xs mt-2">
                                        <button onClick={() => handleUseTemplate(template.content)} className="px-2 py-1 rounded transition" style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}>Use</button>
                                        <button onClick={() => handleEditTemplate(template)} className="px-2 py-1 rounded transition" style={{backgroundColor: 'var(--card-bg)', color: 'var(--text-primary)', border: '1px solid var(--border-color)'}}>Edit</button>
                                        <button onClick={() => handleDeleteTemplate(template.id)} className="px-2 py-1 rounded transition" style={{backgroundColor: 'var(--accent-error)', color: 'white'}}>Delete</button>
                                    </div>
                                </li>
                            ))
                        )}
                    </ul>
                </div>

                <div className="flex justify-end mt-6">
                    <button onClick={onClose} className="px-4 py-2 rounded-lg font-semibold transition" style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}>
                        Close Panel
                    </button>
                </div>
            </div>
        </div>
    );
}

--- END FILE: components\PromptManager.tsx ---

--- START FILE: components\SettingsPanel.tsx ---

// components/SettingsPanel.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { UserSettings } from '@/types/chat';

interface SettingsPanelProps {
    onClose: () => void;
}

const MODELS = [
    { name: 'Gemini 2.5 Flash (Preview 09-2025)', id: 'gemini-2.5-flash-preview-09-2025', description: 'The recommended default model, stable and powerful.' }, // <-- NEW DEFAULT
    { name: 'Gemini 2.5 Flash (Stable)', id: 'gemini-2.5-flash', description: 'Fast and versatile, ideal for chat.' },
    { name: 'Gemini 2.5 Pro', id: 'gemini-2.5-pro', description: 'Most capable model for complex tasks.' },
    { name: 'Gemini 3.0 Pro', id: 'gemini-3-pro-preview', description: 'Experimental, highest reasoning capability.' },
];

export default function SettingsPanel({ onClose }: SettingsPanelProps) {
    const { user, getIdToken } = useAuth();
    const [settings, setSettings] = useState<UserSettings | null>(null);
    const [loading, setLoading] = useState(true);
    const [saving, setSaving] = useState(false);
    const [statusMessage, setStatusMessage] = useState<string | null>(null);

    // Fetch settings on load
    useEffect(() => {
        const fetchSettings = async () => {
            if (!user) return;
            try {
                const token = await getIdToken();
                const response = await fetch('/api/settings', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (response.ok) {
                    const data: UserSettings = await response.json();
                    setSettings(data);
                } else {
                    console.error("Failed to fetch settings.");
                }
            } catch (error) {
                console.error("Error fetching settings:", error);
            } finally {
                setLoading(false);
            }
        };
        fetchSettings();
    }, [user, getIdToken]);

    const handleSave = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!user || !settings) return;

        setSaving(true);
        setStatusMessage(null);
        try {
            const token = await getIdToken();
            const response = await fetch('/api/settings', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({
                    globalModel: settings.globalModel,
                    globalSystemPrompt: settings.globalSystemPrompt,
                }),
            });

            if (response.ok) {
                setStatusMessage('Settings saved successfully!');
            } else {
                setStatusMessage('Failed to save settings.');
            }
        } catch (error) {
            console.error("Error saving settings:", error);
            setStatusMessage('An error occurred during saving.');
        } finally {
            setSaving(false);
            setTimeout(() => setStatusMessage(null), 3000);
        }
    };
    
    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value } = e.target;
        setSettings(prev => prev ? ({ ...prev, [name]: value }) : null);
    };

    if (loading) {
        return (
             <div className="absolute inset-0 bg-gray-900/90 flex items-center justify-center text-white z-50">
                 Loading settings...
            </div>
        )
    }
    
    if (!settings) return null; 

    return (
        <div className="absolute inset-0 bg-gray-900/95 flex items-center justify-center z-50">
            <div className="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-2xl border border-gray-700">
                <div className="flex justify-between items-center mb-6 border-b border-gray-700 pb-3">
                    <h2 className="text-2xl font-bold text-white">AI Settings & Prompts</h2>
                    <button onClick={onClose} className="text-gray-400 hover:text-white transition">
                        <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>

                <form onSubmit={handleSave} className="space-y-6">
                    {/* Model Selection */}
                    <div>
                        <label htmlFor="globalModel" className="block text-sm font-medium text-gray-300 mb-1">
                            Default AI Model
                        </label>
                        <select
                            id="globalModel"
                            name="globalModel"
                            value={settings.globalModel}
                            onChange={handleInputChange}
                            className="w-full p-2 border border-gray-700 rounded-lg bg-gray-700 text-white focus:ring-blue-500 focus:border-blue-500"
                        >
                            {MODELS.map(model => (
                                <option key={model.id} value={model.id}>
                                    {model.name}
                                </option>
                            ))}
                        </select>
                        <p className="text-xs text-gray-500 mt-1">
                            {MODELS.find(m => m.id === settings.globalModel)?.description}
                        </p>
                    </div>

                    {/* System Prompt */}
                    <div>
                        <label htmlFor="globalSystemPrompt" className="block text-sm font-medium text-gray-300 mb-1">
                            Global System Prompt (Personality)
                        </label>
                        <textarea
                            id="globalSystemPrompt"
                            name="globalSystemPrompt"
                            value={settings.globalSystemPrompt}
                            onChange={handleInputChange}
                            rows={4}
                            placeholder="Set an instruction to define the AI's behavior..."
                            className="w-full p-3 border border-gray-700 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500 resize-none"
                        />
                        <p className="text-xs text-gray-500 mt-1">
                            This prompt defines the AI&apos;s behavior for all *new* conversations.
                        </p>
                    </div>
                    
                    {/* Save Button */}
                    <div className="flex justify-between items-center pt-4">
                        {statusMessage && (
                            <p className={`text-sm ${statusMessage.includes('saved') ? 'text-green-400' : 'text-red-400'}`}>
                                {statusMessage}
                            </p>
                        )}
                        <button
                            type="submit"
                            disabled={saving}
                            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition disabled:bg-blue-400"
                        >
                            {saving ? 'Saving...' : 'Save Settings'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
}

--- END FILE: components\SettingsPanel.tsx ---

--- START FILE: components\Sidebar.tsx ---

// components/Sidebar.tsx
'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { useTheme } from '@/components/providers/ThemeContext';
import PromptManager from './PromptManager'; 

interface ChatHistoryItem {
    id: string;
    title: string;
    updatedAt: number;
}

interface SidebarProps {
    onSelectChat: (chatId: string | undefined) => void;
    currentChatId: string | undefined;
    onNewMessageSent: () => void; 
    onOpenConversationMode: () => void; 
    isMobileOpen: boolean;
    onCloseMobile: () => void;
    isMobileView: boolean;
}

// Available Models list (Kept the same)
const AVAILABLE_MODELS = [
    { id: 'gemini-3-pro-preview', name: 'Gemini 3.0 Pro' },
    { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro' },
    { id: 'gemini-2.5-flash-preview-09-2025', name: 'Gemini 2.5 Flash (Recommended)' },
    { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash (Stable)' },
    { id: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash Lite' },
];

export default function Sidebar({ onSelectChat, currentChatId, onNewMessageSent, onOpenConversationMode, isMobileOpen, onCloseMobile, isMobileView }: SidebarProps) {
    const { user, signOut, getIdToken } = useAuth();
    const { themeName, themeMode, setMode, setTheme, settings, updateSettings, availableThemes } = useTheme();
    
    const [history, setHistory] = useState<ChatHistoryItem[]>([]);
    const [loading, setLoading] = useState(true);
    const [isPromptManagerOpen, setIsPromptManagerOpen] = useState(false); 
    const [isSettingsCollapsed, setIsSettingsCollapsed] = useState(true); 

    const fetchHistory = useCallback(async () => {
        if (!user) return;
        setLoading(true);
        try {
            const token = await getIdToken();
            const response = await fetch('/api/chats', {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            if (response.ok) {
                const data: ChatHistoryItem[] = await response.json();
                setHistory(data);
            }
        } catch (error) {
            console.error("Failed to fetch chat history:", error);
        } finally {
            setLoading(false);
        }
    }, [user, getIdToken]); 

    useEffect(() => {
        fetchHistory();
    }, [onNewMessageSent, fetchHistory]); 

    const handleNewChat = () => {
        onSelectChat(undefined);
    };
    
    const handleDeleteChat = async (chatIdToDelete: string) => {
        if (!user) return;
        
        const chatToDelete = history.find(c => c.id === chatIdToDelete);
        const title = chatToDelete?.title || "this chat";

        if (confirm(`Are you sure you want to delete ${title}? This cannot be undone.`)) {
            try {
                const token = await getIdToken();
                const response = await fetch(`/api/chat?chatId=${chatIdToDelete}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.ok) {
                    setHistory(prev => prev.filter(c => c.id !== chatIdToDelete));
                    
                    if (currentChatId === chatIdToDelete) {
                        onSelectChat(undefined);
                    }
                    onNewMessageSent();
                } else {
                    console.error("Failed to delete chat:", await response.json());
                    alert("Failed to delete chat. Check console.");
                }
            } catch (error) {
                 console.error("Error deleting chat:", error);
                 alert("Error deleting chat. Check console.");
            }
        }
    }

    const handleSignOut = async () => {
        if (confirm("Are you sure you want to sign out?")) {
            await signOut();
        }
    };
    
    const handleDeleteAllChats = async () => {
        if (!user) return;
        if (confirm("DANGER: Are you sure you want to permanently delete ALL your chat history? This cannot be undone.")) {
            try {
                const token = await getIdToken();
                const response = await fetch('/api/chats', {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.ok) {
                    setHistory([]);
                    onSelectChat(undefined);
                } else {
                    console.error('Failed to delete all chats:', await response.json());
                }
            } catch (error) {
                 console.error("Error deleting all chats:", error);
            }
        }
    }

    const handleClearLocalStorage = () => {
        if (confirm('WARNING: Are you sure you want to clear all local settings (themes, model selection)? Your chat history (saved in the cloud) will NOT be affected, but you may need to re-login and re-select your preferred theme.')) {
            localStorage.clear(); 
            window.location.reload(); 
        }
    }
    
    const handleModelChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        updateSettings({ globalModel: e.target.value });
    };

    const handleThemeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        setTheme(e.target.value);
    };

    const handleModeToggle = (e: React.ChangeEvent<HTMLInputElement>) => {
        setMode(e.target.checked ? 'dark' : 'light');
    };
    
    const handleStreamingToggle = (e: React.ChangeEvent<HTMLInputElement>) => {
        updateSettings({ streamingEnabled: e.target.checked });
    };


    return (
        // FIX: Use w-full only on mobile for full screen coverage, keep w-64 for desktop.
        // Add shrink-0 to prevent flex shrinkage on desktop.
        <div 
            className={`
                flex flex-col h-screen p-3 shadow-2xl shrink-0 transition-transform duration-300 ease-in-out
                w-64 md:relative md:translate-x-0
                ${isMobileView ? 'fixed z-30 inset-y-0 w-full max-w-[80%]' : ''} 
                ${isMobileOpen ? 'translate-x-0' : '-translate-x-full'}
            `} 
            style={{backgroundColor: 'var(--sidebar-bg)', color: 'var(--text-primary)', borderRight: '1px solid var(--sidebar-border)'}}
        >
            
            {isPromptManagerOpen && (
                <PromptManager onClose={() => { setIsPromptManagerOpen(false); onNewMessageSent(); }} />
            )}
            
            <div className="flex items-center justify-between pb-4 border-b mb-4" style={{borderColor: 'var(--sidebar-border)'}}>
                 <h2 className="text-xl font-bold flex items-center gap-2" style={{color: 'var(--text-primary)'}}>
                    <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-primary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M4.343 19.657l.707-.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                    Big AI
                </h2>
                
                {/* Mobile Close Button */}
                {isMobileView && (
                    <button 
                        onClick={onCloseMobile} 
                        className="p-1 rounded-full hover:bg-[var(--sidebar-item-hover)]"
                        style={{color: 'var(--text-primary)'}}
                    >
                         <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                )}
            </div>
            
            {/* New Chat Button */}
            <button
                onClick={handleNewChat}
                className="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors mb-4"
                style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}} 
            >
                <svg className="w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M12 4v16m8-8H4"></path></svg> 
                Start New Chat
            </button>


            {/* Conversation Mode Button */}
             <button
                onClick={onOpenConversationMode}
                className="w-full flex items-center justify-center p-3 rounded-xl font-semibold transition-colors mb-4"
                style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-primary)', border: '1px solid var(--border-color)'}}
                title="Start Voice Conversation"
            >
                <svg className="w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                Conversation Mode
            </button>


            {/* History List */}
            <div className="flex-1 overflow-y-auto space-y-2 pr-1">
                <h3 className="text-sm font-semibold uppercase sticky top-0 py-1" style={{color: 'var(--text-secondary)', backgroundColor: 'var(--sidebar-bg)'}}>
                    History ({history.length})
                </h3>
                {loading && <div className="text-sm p-3" style={{color: 'var(--text-secondary)'}}>Loading history...</div>}
                
                {history.length === 0 && !loading && (
                    <div className="text-sm p-3" style={{color: 'var(--text-secondary)'}}>No history found.</div>
                )}
                
                {history.map((chat) => (
                    <div 
                        key={chat.id}
                        className={`group flex items-center justify-between p-3 rounded-lg text-sm transition duration-150 ${
                            chat.id === currentChatId 
                                ? 'font-semibold' 
                                : 'hover:opacity-80'
                        }`}
                        style={{
                            backgroundColor: chat.id === currentChatId ? 'var(--accent-primary)' : 'var(--bg-secondary)',
                            color: chat.id === currentChatId ? 'var(--ai-bubble-text)' : 'var(--text-primary)',
                            cursor: 'pointer'
                        }}
                        title={chat.title}
                    >
                        {/* Title Section (Clickable area to select chat) */}
                        <button
                            onClick={() => onSelectChat(chat.id)}
                            className="flex items-center flex-1 min-w-0 pr-2 text-left"
                            style={{ color: 'inherit', background: 'none', border: 'none', padding: 0 }}
                        >
                            <svg className="w-4 h-4 mr-2 shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M20 12H4M12 4v16"></path></svg>
                            <span className="truncate flex-1">
                                {chat.title}
                            </span>
                        </button>
                        
                        {/* Delete Button (Visible on hover) */}
                        <button
                            onClick={(e) => { e.stopPropagation(); handleDeleteChat(chat.id); }}
                            className={`p-1 rounded transition ml-2 shrink-0 opacity-0 group-hover:opacity-100`}
                            title="Delete Chat"
                            style={{ 
                                color: chat.id === currentChatId ? 'var(--ai-bubble-text)' : 'var(--accent-error)',
                                backgroundColor: chat.id === currentChatId ? 'var(--accent-primary-hover)' : 'transparent',
                            }}
                        >
                            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    </div>
                ))}
            </div>
            
            {/* Footer Area - Collapsible Settings and Auth */}
            <div className="pt-4 border-t mt-4 space-y-2" style={{borderColor: 'var(--sidebar-border)'}}>
                 
                 {/* Settings Toggle Button */}
                 <button 
                    className="w-full flex items-center justify-between p-2 rounded-lg font-semibold transition"
                    onClick={() => setIsSettingsCollapsed(prev => !prev)}
                    style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--text-primary)'}}
                 >
                    <span className="flex items-center gap-2">
                        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-primary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.942 3.333.9 2.456 2.456a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.942 1.543-.9 3.333-2.456 2.456a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.942-3.333-.9-2.456-2.456a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.942-1.543.9-3.333 2.456-2.456a1.724 1.724 0 002.572-1.065z"></path><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                        Settings
                    </span>
                    <svg className={`w-4 h-4 transition-transform ${isSettingsCollapsed ? 'transform rotate-0' : 'transform rotate-180'}`} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 9l-7 7-7-7"></path></svg>
                </button>

                {/* Collapsible Settings Content */}
                <div className={`space-y-3 overflow-hidden transition-all duration-300 ${isSettingsCollapsed ? 'max-h-0' : 'max-h-[800px]'}`}>

                    {/* Quick Prompt/Template Access */}
                    <button 
                        className="w-full text-left text-sm p-2 rounded-lg transition"
                        onClick={() => { setIsPromptManagerOpen(true); if(isMobileView) onCloseMobile(); }} // Close sidebar when opening manager
                        style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-secondary)'}}
                    >
                        <span className="font-semibold flex items-center gap-2">
                             <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-2.414-2.414A1 1 0 0015.586 6H7a2 2 0 00-2 2v11a2 2 0 002 2zM17 17H7m10-4H7m4-4H7"></path></svg>
                             Manage Prompts & API Key
                        </span>
                    </button>

                    {/* Model Selector */}
                    <div>
                        <label className="block text-xs font-medium uppercase mb-1" style={{color: 'var(--text-secondary)'}}>AI Model</label>
                        <select
                            value={settings?.globalModel || AVAILABLE_MODELS[0].id}
                            onChange={handleModelChange}
                            className="w-full p-2 rounded-lg border text-sm"
                            style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                        >
                            {AVAILABLE_MODELS.map(model => (
                                <option key={model.id} value={model.id}>{model.name}</option>
                            ))}
                        </select>
                    </div>

                    {/* Theme Selector (Uses the expanded list from ThemeContext) */}
                    <div>
                        <label className="block text-xs font-medium uppercase mb-1" style={{color: 'var(--text-secondary)'}}>Theme</label>
                        <select
                            value={themeName}
                            onChange={handleThemeChange}
                            className="w-full p-2 rounded-lg border text-sm"
                            style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                        >
                            {availableThemes.map(theme => (
                                <option key={theme.id} value={theme.id}>{theme.name}</option>
                            ))}
                        </select>
                    </div>

                    {/* Dark/Light Mode Toggle */}
                    <div className="flex items-center justify-between text-sm py-2">
                         <span style={{color: 'var(--text-secondary)'}}>Dark Mode ({themeMode})</span>
                         <label className="relative inline-block w-12 h-6">
                            <input type="checkbox" checked={themeMode === 'dark'} onChange={handleModeToggle} className="opacity-0 w-0 h-0" />
                            <span className="absolute cursor-pointer top-0 left-0 right-0 bottom-0 rounded-full before:absolute before:content-[''] before:h-4 before:w-4 before:left-1 before:bottom-1 before:rounded-full transition duration-400" 
                                style={{
                                    backgroundColor: themeMode === 'dark' ? 'var(--accent-primary)' : 'var(--text-secondary)',
                                    '--tw-translate-x': themeMode === 'dark' ? '24px' : '0',
                                    transition: 'background-color 0.4s, transform 0.4s'
                                } as React.CSSProperties}
                            ></span>
                        </label>
                    </div>

                    {/* Streaming Toggle - Renamed Label */}
                     <div className="flex items-center justify-between text-sm py-2">
                         <span style={{color: 'var(--text-secondary)'}}>AI Response: {settings?.streamingEnabled ? 'Typing (Stream)' : 'Instant (Full)'}</span>
                         <label className="relative inline-block w-12 h-6">
                            <input 
                                type="checkbox" 
                                checked={settings?.streamingEnabled ?? true} 
                                onChange={handleStreamingToggle} 
                                className="opacity-0 w-0 h-0" 
                            />
                            <span className="absolute cursor-pointer top-0 left-0 right-0 bottom-0 rounded-full before:absolute before:content-[''] before:h-4 before:w-4 before:left-1 before:bottom-1 before:rounded-full transition duration-400" 
                                style={{
                                    backgroundColor: (settings?.streamingEnabled ?? true) ? 'var(--accent-primary)' : 'var(--text-secondary)',
                                    '--tw-translate-x': (settings?.streamingEnabled ?? true) ? '24px' : '0',
                                    transition: 'background-color 0.4s, transform 0.4s'
                                } as React.CSSProperties}
                            ></span>
                        </label>
                    </div>


                    {/* Data Management Buttons */}
                    <div className="pt-3 border-t space-y-2" style={{borderColor: 'var(--sidebar-border)'}}>
                        <button 
                            className="w-full text-left text-sm p-2 rounded-lg transition"
                            onClick={handleDeleteAllChats}
                            style={{backgroundColor: 'var(--accent-error)', color: 'white'}}
                        >
                            <span className="font-semibold flex items-center gap-2">
                                <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                Delete All Chats
                            </span>
                        </button>
                        <button 
                            className="w-full text-left text-sm p-2 rounded-lg transition"
                            onClick={handleClearLocalStorage}
                            style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--text-secondary)', border: '1px solid var(--border-color)'}}
                        >
                            <span className="font-semibold flex items-center gap-2">
                                <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M4 7v10m0 0h16M4 17l4-4m-4 4l4 4M20 7v10m0 0H4m16 0l-4-4m4 4l-4 4M12 5v14"></path></svg>
                                Clear Local Cache
                            </span>
                        </button>
                    </div>
                </div>

                {/* Authentication Status */}
                <div className="text-sm border-t pt-4 mt-4" style={{color: 'var(--text-secondary)', borderColor: 'var(--sidebar-border)'}}>
                    <div className="truncate mb-2" style={{color: 'var(--text-primary)'}}>
                         Logged in as: {user?.email || "User"}
                    </div>
                </div>
                <button 
                    className="w-full text-left text-sm p-2 rounded-lg transition hover:bg-red-900/50"
                    onClick={handleSignOut}
                    style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-error)'}}
                >
                    Log out
                </button>
            </div>
        </div>
    );
}

--- END FILE: components\Sidebar.tsx ---

--- START FILE: components\providers\AuthProvider.tsx ---

// components/providers/AuthProvider.tsx
'use client';

import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { User, onAuthStateChanged, signOut as firebaseSignOut } from 'firebase/auth';
import { auth } from '@/utils/firebase';

interface AuthContextType {
  user: User | null;
  loading: boolean;
  getIdToken: () => Promise<string | null>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
      setUser(currentUser);
      setLoading(false);
    });
    return () => unsubscribe();
  }, []);

  const getIdToken = async (): Promise<string | null> => {
    if (user) {
      return await user.getIdToken();
    }
    return null;
  };

  const signOut = async () => {
    await firebaseSignOut(auth);
    // Optionally wipe local state here if needed
  };

  return (
    <AuthContext.Provider value={{ user, loading, getIdToken, signOut }}>
      {children}
    </AuthContext.Provider>
  );
};

--- END FILE: components\providers\AuthProvider.tsx ---

--- START FILE: components\providers\ThemeContext.tsx ---

// components/providers/ThemeContext.tsx
'use client';

import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import { useAuth } from './AuthProvider';
import { UserSettings } from '@/types/chat';

interface ThemeContextType {
  themeName: string;
  themeMode: 'light' | 'dark';
  currentTheme: string; // themeName-themeMode
  settings: UserSettings | null;
  setTheme: (name: string) => void;
  setMode: (mode: 'light' | 'dark') => void;
  updateSettings: (partialSettings: Partial<UserSettings>) => Promise<void>;
  loadingSettings: boolean;
  availableThemes: { id: string; name: string }[];
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Define available themes based on globals.css integration (FULL LIST MERGED)
const THEMES = [
    { id: 'default', name: 'Big AI v2 (Default)' },
    { id: 'celestial-horizon', name: 'Celestial Horizon' },
    { id: 'verdant-calm', name: 'Verdant Calm' },
    { id: 'cybernetic-pulse', name: 'Cybernetic Pulse' },
    { id: 'urban-pulse', name: 'Urban Pulse' },
    { id: 'rustic-ember', name: 'Rustic Ember' },
    { id: 'neon-mirage', name: 'Neon Mirage' },
    { id: 'ivory-bloom', name: 'Ivory Bloom' },
    { id: 'obsidian-night', name: 'Obsidian Night' },
    { id: 'solar-dawn', name: 'Solar Dawn' },
    { id: 'aurora-drift', name: 'Aurora Drift' },
    { id: 'timeless-echo', name: 'Timeless Echo' },
    { id: 'mystic-void', name: 'Mystic Void' },
    { id: 'darkest-bw', name: 'The Darkest Night' },
    { id: 'coder', name: "Coder's Theme" },
    { id: 'cyberpunk', name: 'Cyberpunk Neon' },
    { id: 'matrix', name: 'Matrix Code' },
    { id: 'solarized', name: 'Solarized' },
    { id: 'dracula', name: 'Dracula' },
    { id: 'monokai', name: 'Monokai Pro' },
    { id: 'nord', name: 'Nord' },
    { id: 'gruvbox', name: 'Gruvbox' },
    { id: 'catppuccin', name: 'Catppuccin' },
    { id: 'cosmic-nexus', name: 'Cosmic Nexus' },
    { id: 'starship-minimal', name: 'Starship Minimal' },
    { id: 'offbeat-cosmic', name: 'Offbeat Cosmic Pastels' },
];

export const useTheme = () => {
// ... existing useTheme hook
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

interface ThemeProviderProps {
  children: ReactNode;
}

export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
// ... existing state and effects (fetchSettings, saveSettingsToDB, updateSettings)
  const { user, getIdToken, loading: authLoading } = useAuth();
  const [themeName, setThemeName] = useState<string>('default');
  const [themeMode, setThemeMode] = useState<'light' | 'dark'>('dark');
  const [settings, setSettings] = useState<UserSettings | null>(null);
  const [loadingSettings, setLoadingSettings] = useState(true);

  const currentTheme = `${themeName}-${themeMode}`;
  
  // --- Persistence & Fetching (Same as before) ---
  const fetchSettings = useCallback(async () => {
    // ... (existing implementation)
    if (!user) {
      setLoadingSettings(false);
      return;
    }

    try {
      const token = await getIdToken();
      const response = await fetch('/api/settings', {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (response.ok) {
        const data: UserSettings = await response.json();
        setSettings(data);
        // FIX: Ensure themeName/themeMode default correctly if null from DB
        setThemeName(data.themeName || 'default');
        setThemeMode(data.themeMode || 'dark');
      } else {
        console.error("Failed to fetch user settings.");
      }
    } catch (error) {
      console.error("Error fetching settings:", error);
    } finally {
      setLoadingSettings(false);
    }
  }, [user, getIdToken]);

  const saveSettingsToDB = useCallback(async (partialSettings: Partial<UserSettings>) => {
    // ... (existing implementation)
    if (!user) return;
    try {
      const token = await getIdToken();
      await fetch('/api/settings', {
        method: 'POST',
        headers: { 
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(partialSettings),
      });
    } catch (error) {
      console.error('Failed to save settings to DB:', error);
    }
  }, [user, getIdToken]);

  const updateSettings = useCallback(async (partialSettings: Partial<UserSettings>) => {
    // 1. Update local state
    setSettings(prev => {
        if (!prev) return null;
        const newSettings = { ...prev, ...partialSettings };
        
        // Ensure state updates only happen if values actually change
        if (partialSettings.themeName && partialSettings.themeName !== prev.themeName) setThemeName(partialSettings.themeName);
        if (partialSettings.themeMode && partialSettings.themeMode !== prev.themeMode) setThemeMode(partialSettings.themeMode);

        return newSettings;
    });

    // 3. Persist to database
    await saveSettingsToDB(partialSettings);
  }, [saveSettingsToDB]);


  // --- Theme Controls (Same as before) ---

  const handleSetTheme = useCallback((name: string) => {
    setThemeName(name);
    updateSettings({ themeName: name });
  }, [updateSettings]);

  const handleSetMode = useCallback((mode: 'light' | 'dark') => {
    setThemeMode(mode);
    updateSettings({ themeMode: mode });
  }, [updateSettings]);

  // --- Effects ---

  // 1. Fetch settings on user change/initial load
  useEffect(() => {
    if (user && !authLoading) {
        fetchSettings();
    } else if (!user && !authLoading) {
        // Reset state for non-logged-in users, but keep loading state false
        setSettings(null);
        setThemeName('default');
        setThemeMode('dark');
        setLoadingSettings(false);
    }
  }, [user, authLoading, fetchSettings]);

  // 2. Apply theme to body (CRITICAL FIX: This needs to apply the class name)
  useEffect(() => {
    if (document.body) {
         document.body.setAttribute('data-theme', currentTheme);
    }
  }, [currentTheme]);


  const value = {
    themeName,
    themeMode,
    currentTheme,
    settings,
    loadingSettings,
    setTheme: handleSetTheme,
    setMode: handleSetMode,
    updateSettings,
    availableThemes: THEMES,
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};

--- END FILE: components\providers\ThemeContext.tsx ---

--- START FILE: components\ui\AuthGate.tsx ---

// components/ui/AuthGate.tsx
'use client';

import { useState } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { signInWithEmailAndPassword, createUserWithEmailAndPassword, GoogleAuthProvider, signInWithPopup } from 'firebase/auth';
import { FirebaseError } from 'firebase/app';
import { auth } from '@/utils/firebase';

export default function AuthGate() {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [isRegister, setIsRegister] = useState(false);
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const { loading: authLoading } = useAuth();


    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        try {
            if (isRegister) {
                await createUserWithEmailAndPassword(auth, email, password);
            } else {
                await signInWithEmailAndPassword(auth, email, password);
            }
        } catch (err) {
            console.error(err);
            // FIX: Check if error is a FirebaseError for better typing
            const errorMessage = err instanceof FirebaseError ? err.message : 'Authentication failed.';
            setError(errorMessage);
        } finally {
            setLoading(false);
        }
    };

    const handleGoogleSignIn = async () => {
        setLoading(true);
        setError('');
        try {
            const provider = new GoogleAuthProvider();
            await signInWithPopup(auth, provider);
        } catch (err) {
            const errorMessage = err instanceof FirebaseError ? err.message : 'Google Sign-In failed.';
             setError(errorMessage);
        } finally {
             setLoading(false);
        }
    };

    if (authLoading) {
        return <div className="flex h-screen items-center justify-center bg-gray-900 text-white">Loading Auth...</div>
    }

    return (
        <div className="flex h-screen items-center justify-center bg-gray-900 text-white">
            <div className="w-full max-w-md p-8 space-y-6 bg-gray-800 rounded-xl shadow-2xl">
                <h2 className="text-2xl font-bold text-center">
                    {isRegister ? 'Sign Up for Big AI' : 'Sign In to Big AI'}
                </h2>
                {error && <p className="text-red-400 text-center">{error}</p>}
                
                <form onSubmit={handleSubmit} className="space-y-4">
                    <input
                        type="email"
                        placeholder="Email"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        className="w-full p-3 border border-gray-700 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500"
                        required
                    />
                    <input
                        type="password"
                        placeholder="Password"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        className="w-full p-3 border border-gray-700 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500"
                        required
                    />
                    <button
                        type="submit"
                        disabled={loading}
                        className="w-full p-3 text-white bg-blue-600 rounded-lg hover:bg-blue-700 transition duration-200 disabled:bg-blue-400"
                    >
                        {loading ? 'Processing...' : isRegister ? 'Register' : 'Sign In'}
                    </button>
                </form>

                <div className="relative flex items-center justify-center">
                    <span className="absolute px-3 bg-gray-800 text-gray-400 text-sm">OR</span>
                    <div className="w-full border-t border-gray-700"></div>
                </div>

                <button
                    onClick={handleGoogleSignIn}
                    disabled={loading}
                    className="w-full p-3 flex items-center justify-center gap-2 border border-gray-700 rounded-lg text-gray-300 hover:bg-gray-700 transition disabled:opacity-50"
                >
                    <svg width="20" height="20" viewBox="0 0 48 48"><path fill="#FFC107" d="M43.6 24c0-1.6-.2-3.3-.5-4.9H24v9.2h10.9c-.6 2.9-2.2 5.4-4.7 7.2v6.4h8.2c4.7-4.4 7.4-10.9 7.4-18z"/><path fill="#FF3D00" d="M24 48c6.6 0 12.3-2.2 16.4-6L31.9 35.6c-2.3 1.5-5.2 2.4-8 2.4-6.4 0-11.8-4.3-13.7-10.1h-8.5v6.6C4.8 41.7 13.7 48 24 48z"/><path fill="#4CAF50" d="M10.3 28.5c-.5-1.5-.8-3.1-.8-4.5s.3-3 .8-4.5V13H1.8C.6 15.6 0 18.5 0 24c0 5.5.6 8.4 1.8 11L10.3 28.5z"/><path fill="#1976D2" d="M24 9.6c3.4 0 6.4 1.2 8.8 3.5l7.3-7.3C36.3 3.4 30.5 0 24 0c-10.3 0-19.2 6.3-22.3 15.6l8.5 6.6C12.2 13.9 17.6 9.6 24 9.6z"/></svg>
                    Sign in with Google
                </button>

                <button
                    onClick={() => setIsRegister(p => !p)}
                    className="w-full text-sm text-center text-gray-400 hover:text-blue-500 transition"
                >
                    {isRegister ? 'Already have an account? Sign In' : 'Need an account? Register'}
                </button>
            </div>
        </div>
    );
}

--- END FILE: components\ui\AuthGate.tsx ---

--- START FILE: hooks\useSpeechRecognition.ts ---

// hooks/useSpeechRecognition.ts
import { useState, useEffect, useCallback, useRef } from 'react';

// Define the API global object (must be window.SpeechRecognition or window.webkitSpeechRecognition)
declare global {
    interface Window {
        SpeechRecognition?: SpeechRecognitionAPI;
        webkitSpeechRecognition?: SpeechRecognitionAPI;
    }
}

interface SpeechRecognitionAPI {
    new (): SpeechRecognitionInstance;
}

interface SpeechRecognitionInstance {
    continuous: boolean;
    interimResults: boolean;
    lang: string;
    onstart: ((event: Event) => void) | null;
    onresult: ((event: Event) => void) | null;
    onerror: ((event: Event) => void) | null;
    onend: ((event: Event) => void) | null;
    start(): void;
    stop(): void;
}

const SpeechRecognition = typeof window !== 'undefined' ? window.SpeechRecognition || window.webkitSpeechRecognition : null;

interface SpeechRecognitionOptions {
    continuous?: boolean;
    interimResults?: boolean;
    lang?: string;
    onFinalTranscript?: (transcript: string) => void;
    onInterimTranscript?: (transcript: string) => void;
    onStart?: () => void;
    onEnd?: () => void;
    onError?: (error: string) => void;
}

interface SpeechRecognitionResultItem {
    transcript: string;
    confidence: number;
}

interface SpeechRecognitionResultList {
    [index: number]: SpeechRecognitionResult;
    length: number;
}

interface SpeechRecognitionResult {
    [index: number]: SpeechRecognitionResultItem;
    isFinal: boolean;
    length: number;
}

interface SpeechRecognitionEventResult extends Event {
    resultIndex: number;
    results: SpeechRecognitionResultList;
}

const useSpeechRecognition = (options: SpeechRecognitionOptions = {}) => {
    const {
        continuous = true,
        interimResults = true,
        lang = 'en-US',
        onFinalTranscript,
        onInterimTranscript,
        onStart,
        onEnd,
        onError,
    } = options;

    const recognitionSupported = SpeechRecognition !== null;
    const [isListening, setIsListening] = useState(false);
    const [transcript, setTranscript] = useState('');
    const recognitionRef = useRef<SpeechRecognitionInstance | null>(null);
    const finalTranscriptRef = useRef('');

    const resetTranscript = useCallback(() => {
        setTranscript('');
        finalTranscriptRef.current = '';
    }, []);

    useEffect(() => {
        if (!recognitionSupported || !SpeechRecognition) return;

        const recognition = new SpeechRecognition();
        recognition.continuous = continuous;
        recognition.interimResults = interimResults;
        recognition.lang = lang;

        recognition.onstart = () => {
            setIsListening(true);
            finalTranscriptRef.current = '';
            onStart?.();
        };

        recognition.onresult = (event: Event) => {
            const speechEvent = event as SpeechRecognitionEventResult;
            let interim = '';
            let final = '';

            for (let i = speechEvent.resultIndex; i < speechEvent.results.length; ++i) {
                const result = speechEvent.results[i];
                if (result.isFinal) {
                    final += result[0].transcript + ' ';
                } else {
                    interim += result[0].transcript;
                }
            }

            if (final) {
                finalTranscriptRef.current += final;
                onFinalTranscript?.(finalTranscriptRef.current.trim());
            }
            
            // Update the main transcript state with both final and interim results
            setTranscript((finalTranscriptRef.current + interim).trim());
            onInterimTranscript?.(interim.trim());
        };
        recognition.onerror = (event: Event) => {
            const errorEvent = event as ErrorEvent;
            console.error('Speech recognition error:', event);
            setIsListening(false);
            onError?.(errorEvent.error);
        };

        recognition.onend = () => {
            setIsListening(false);
            // Ensure the final transcript is processed one last time if not already
            if (finalTranscriptRef.current && finalTranscriptRef.current.trim() !== '' && !continuous) {
                onFinalTranscript?.(finalTranscriptRef.current.trim());
            }
            onEnd?.();
        };

        recognitionRef.current = recognition;

        // Cleanup
        return () => {
            recognition.onstart = null;
            recognition.onresult = null;
            recognition.onerror = null;
            recognition.onend = null;
            if (isListening) {
                recognition.stop();
            }
        };
    }, [recognitionSupported, continuous, interimResults, lang, onStart, onEnd, onError, onFinalTranscript, onInterimTranscript]);

    const startListening = useCallback((initialText: string = '') => {
        if (recognitionRef.current && !isListening) {
            // If the user has pre-filled text, treat it as the base
            if (initialText.trim()) {
                 finalTranscriptRef.current = initialText.trim() + ' ';
                 setTranscript(initialText.trim());
            } else {
                 resetTranscript();
            }
            
            try {
                recognitionRef.current.start();
            } catch (e: unknown) {
                // Ignore InvalidStateError if recognition is already running (rare but happens)
                const error = e as Error;
                if (error.name !== 'InvalidStateError') {
                    console.error("Error starting recognition:", e);
                    recognitionRef.current.stop();
                    onError?.(error.message);
                }
            }
        }
    }, [isListening, resetTranscript, onError]);

    const stopListening = useCallback(() => {
        if (recognitionRef.current && isListening) {
            recognitionRef.current.stop();
        }
    }, [isListening]);

    return {
        isListening,
        transcript,
        startListening,
        stopListening,
        recognitionSupported,
        resetTranscript,
    };
};

export default useSpeechRecognition;

--- END FILE: hooks\useSpeechRecognition.ts ---

--- START FILE: lib\firebaseAdmin.ts ---

// lib/firebaseAdmin.ts
import * as admin from 'firebase-admin';
import { NextRequest } from 'next/server';

// Initialize the Admin SDK only if it hasn't been initialized already
if (!admin.apps.length) {
  try {
    const serviceAccountJson = process.env.FIREBASE_SERVICE_ACCOUNT_JSON;
    
    if (!serviceAccountJson) {
        // This is the source of the 500s if db or admin.auth() is called before a return path.
        console.error("CRITICAL: FIREBASE_SERVICE_ACCOUNT_JSON environment variable is NOT set. Server-side persistence will fail.");
    } else {
        const serviceAccount = JSON.parse(serviceAccountJson);
        
        admin.initializeApp({
            credential: admin.credential.cert(serviceAccount),
        });
        console.log("Firebase Admin Initialized successfully.");
    }
  } catch (error) {
    console.error("FATAL: Firebase Admin initialization error. Check FIREBASE_SERVICE_ACCOUNT_JSON format.", error);
    // If initialization fails here, subsequent calls to getAuthId or db will throw.
  }
}

// Check if app is initialized before accessing services
const isInitialized = admin.apps.length > 0;
const db = isInitialized ? admin.firestore() : { collection: () => ({ where: () => ({ orderBy: () => ({ limit: () => ({ get: () => Promise.resolve({ docs: [] }) }) }) }), doc: () => ({ get: () => Promise.resolve(null), set: () => Promise.resolve(), update: () => Promise.resolve() }) }) } as unknown as admin.firestore.Firestore;

// Utility function to verify the user ID from the request
export async function getAuthId(req: NextRequest): Promise<string | null> {
    if (!isInitialized) {
        console.error("Authentication failed: Firebase Admin not initialized.");
        return null;
    }

    const authHeader = req.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return null;
    }
    const token = authHeader.split(' ')[1];
    
    try {
        const decodedToken = await admin.auth().verifyIdToken(token);
        return decodedToken.uid;
    } catch (error) {
        console.error("Token verification failed:", error);
        return null;
    }
}


// Exporting both db and admin
export { db, admin };

--- END FILE: lib\firebaseAdmin.ts ---

--- START FILE: lib\gemini.ts ---

// lib/gemini.ts
import { GoogleGenAI } from '@google/genai';
import { GeminiContent, ChatMessage, TextPart, InlineDataPart } from '@/types/chat'; // Import new specific part types

// We use a specific, high-capability model as requested (though slightly modified name for stability)
const MODEL_NAME = 'gemini-2.5-flash-preview-09-2025'; // <-- UPDATED DEFAULT MODEL NAME

// Initialize Gemini Client
const ai = new GoogleGenAI({});

// Helper function to convert client ChatMessage to GeminiContent
function chatMessageToGeminiContent(msg: ChatMessage): GeminiContent {
    // Use imported types for parts array
    const parts: (TextPart | InlineDataPart)[] = []; 

    // 1. Add text part
    if (msg.text) {
        parts.push({ text: msg.text });
    }

    // 2. Add file parts (multimodal)
    if (msg.files && msg.files.length > 0) {
        msg.files.forEach(file => {
            parts.push({
                inlineData: {
                    data: file.base64Data,
                    mimeType: file.mimeType,
                }
            }); 
        });
    }

    // Now returns the correct structure matching the updated GeminiContent interface
    return {
        role: msg.role,
        parts: parts,
    };
}


/**
 * Transforms client/storage messages into the format the Gemini API expects
 * and generates streaming content.
 * 
 * @param history A list of previous messages in the conversation (including the latest user prompt).
 * @returns A ReadableStream of text chunks.
 */
export async function generateStreamingResponse(
    history: ChatMessage[],
    systemInstruction?: string,
): Promise<ReadableStream<Uint8Array>> {
    
    // 1. Prepare contents array (convert ChatMessages to GeminiContent)
    const contents: GeminiContent[] = history.map(chatMessageToGeminiContent);

    // 2. Call the streaming API
    const responseStream = await ai.models.generateContentStream({
        model: MODEL_NAME, // Uses the updated model constant
        contents: contents,
        config: systemInstruction ? { systemInstruction } : undefined,
    });

    // 3. Convert the response stream to a standard Node.js/Next.js ReadableStream
    const encoder = new TextEncoder();
    
    const stream = new ReadableStream({
        async start(controller) {
            for await (const chunk of responseStream) {
                const text = chunk.text;
                if (text) {
                    controller.enqueue(encoder.encode(text));
                }
            }
            controller.close();
        },
    });

    return stream;
}

--- END FILE: lib\gemini.ts ---

--- START FILE: lib\history.ts ---

// lib/history.ts
import { db, admin } from './firebaseAdmin'; 
import { Conversation, ChatMessage, Role, FileAttachment } from '@/types/chat'; 
import { v4 as uuidv4 } from 'uuid';

const CONVERSATIONS_COLLECTION = 'conversations';

// Define the stored structure (using number for timestamp)
interface FirestoreMessage {
    id: string;
    text: string;
    role: Role;
    timestamp: number;
    files?: FileAttachment[];
}

// Helper to generate a conversational title
function generateTitle(firstMessage: string): string {
    const words = firstMessage.split(/\s+/).slice(0, 6);
    let title = words.join(' ');
    if (words.length > 5) {
        title += '...';
    }
    return title || "New Chat";
}

// Helper function to prepare a ChatMessage for Firestore serialization
function serializeMessage(message: ChatMessage): FirestoreMessage {
    const serialized: FirestoreMessage = {
        id: message.id,
        text: message.text,
        role: message.role,
        timestamp: message.timestamp instanceof Date ? message.timestamp.getTime() : (typeof message.timestamp === 'number' ? message.timestamp : Date.now()),
    };
    
    // CRITICAL: Only include the 'files' field if files exist
    if (message.files && message.files.length > 0) {
        serialized.files = message.files;
    }

    return serialized;
}


/**
 * Retrieves a conversation by its ID.
 */
export async function getConversation(chatId: string, userId: string): Promise<Conversation | null> {
    const docRef = db.collection(CONVERSATIONS_COLLECTION).doc(chatId);
    const doc = await docRef.get();

    if (!doc.exists) {
        return null;
    }
    
    const data = doc.data() as Omit<Conversation, 'messages' | 'createdAt' | 'updatedAt'> & { 
        messages: FirestoreMessage[],
        createdAt: number,
        updatedAt: number,
    };

    // Security check: Ensure the conversation belongs to the authenticated user
    if (data.userId !== userId) {
        console.warn(`Access denied: User ${userId} attempted to access chat ${chatId} belonging to ${data.userId}`);
        return null;
    }
    
    const conversation: Conversation = {
        ...data,
        messages: data.messages.map(m => ({
            ...m,
            timestamp: new Date(m.timestamp), 
        })),
        createdAt: new Date(data.createdAt),
        updatedAt: new Date(data.updatedAt),
    };

    return conversation;
}

/**
 * Creates a new conversation and adds the first message.
 */
export async function createConversation(
    userId: string, 
    firstMessage: string, 
    files: FileAttachment[] = [],
    model?: string, // NEW PARAMETER
    systemPrompt?: string // NEW PARAMETER
): Promise<Conversation> {
    const chatId = uuidv4();
    const now = Date.now();
    
    const userMessage: ChatMessage = {
        id: uuidv4(),
        text: firstMessage,
        role: 'user' as Role,
        timestamp: now,
        files: files.length > 0 ? files : undefined,
    };
    
    const serializedUserMessage = serializeMessage(userMessage);

    // Initial conversation object for Firestore
    const newConversation = {
        id: chatId,
        userId,
        createdAt: now,
        updatedAt: now,
        title: generateTitle(firstMessage), 
        messages: [serializedUserMessage], 
        model: model || 'gemini-2.5-flash-preview-09-2025', 
        ...(systemPrompt && { systemPrompt: systemPrompt }), // Only include if defined
    };

    await db.collection(CONVERSATIONS_COLLECTION).doc(chatId).set(newConversation);

    // Return the client-side Conversation object (with Date objects)
    return {
        ...newConversation,
        messages: [userMessage],
        createdAt: new Date(now),
        updatedAt: new Date(now),
    } as Conversation;
}

/**
 * Appends a new user message and the subsequent AI response to an existing conversation.
 */
export async function updateConversation(
    chatId: string, 
    userText: string, 
    modelText: string,
    userId: string, // Require User ID for security
    files: FileAttachment[] = [],
    isFirstExchange: boolean = false
): Promise<void> {
    
    // First, verify access (Essential Security Check)
    const docRef = db.collection(CONVERSATIONS_COLLECTION).doc(chatId);
    const doc = await docRef.get();
    if (!doc.exists || doc.data()?.userId !== userId) {
        throw new Error("Unauthorized chat update attempt.");
    }
    
    const now = Date.now();
    
    const userMessage: ChatMessage = {
        id: uuidv4(),
        text: userText,
        role: 'user' as Role,
        timestamp: now,
        files: files.length > 0 ? files : undefined,
    };
    
    const modelMessage: ChatMessage = {
        id: uuidv4(),
        text: modelText,
        role: 'model' as Role,
        timestamp: now,
    };

    const serializedUserMessage = serializeMessage(userMessage);
    const serializedModelMessage = serializeMessage(modelMessage);

    const updateData: { messages: admin.firestore.FieldValue; updatedAt: number; title?: string } = {
        messages: admin.firestore.FieldValue.arrayUnion(serializedUserMessage, serializedModelMessage),
        updatedAt: now,
    };

    if (isFirstExchange) {
        updateData.title = generateTitle(userText);
    }
    
    await docRef.update(updateData);
}

/**
 * Deletes a single conversation by its ID. (NEW)
 */
export async function deleteConversation(chatId: string, userId: string): Promise<void> {
    const docRef = db.collection(CONVERSATIONS_COLLECTION).doc(chatId);
    
    // Security check: Verify ownership before deletion
    const doc = await docRef.get();
    if (!doc.exists || doc.data()?.userId !== userId) {
        throw new Error("Unauthorized chat deletion attempt.");
    }

    await docRef.delete();
}


/**
 * Deletes all chats for a user. (Used by the new DELETE /api/chats route)
 */
export async function deleteAllUserConversations(userId: string): Promise<void> {
    const batch = db.batch();
    const snapshot = await db.collection(CONVERSATIONS_COLLECTION)
        .where('userId', '==', userId)
        .get();

    snapshot.docs.forEach(doc => {
        batch.delete(doc.ref);
    });

    await batch.commit();
}

--- END FILE: lib\history.ts ---

--- START FILE: lib\settings.ts ---

// lib/settings.ts
import { db } from './firebaseAdmin';
import { UserSettings, PromptTemplate } from '@/types/chat';

const SETTINGS_COLLECTION = 'user_settings';
const DEFAULT_MODEL = 'gemini-2.5-flash-preview-09-2025';

const DEFAULT_SETTINGS: UserSettings = {
    userId: 'default', 
    globalModel: DEFAULT_MODEL,
    globalSystemPrompt: 'You are Big AI, a helpful and large-scale language model developed by Google. Respond concisely and professionally.',
    themeName: 'default', // NEW
    themeMode: 'dark', // NEW
    apiKey: null, // NEW
    templates: [], // NEW
    streamingEnabled: true, // <-- UPDATED DEFAULT
}

/**
 * Retrieves the global settings for a user, merging with defaults if necessary.
 */
export async function getSettings(userId: string): Promise<UserSettings> {
    const docRef = db.collection(SETTINGS_COLLECTION).doc(userId);
    const doc = await docRef.get();

    if (doc.exists) {
        const storedSettings = doc.data() as UserSettings;
        return { 
            ...DEFAULT_SETTINGS, 
            ...storedSettings, 
            userId,
            globalModel: storedSettings.globalModel || DEFAULT_MODEL, 
            themeMode: storedSettings.themeMode || 'dark',
            themeName: storedSettings.themeName || 'default',
            templates: storedSettings.templates || [],
            apiKey: storedSettings.apiKey || null,
            streamingEnabled: storedSettings.streamingEnabled ?? true, // <-- Handle potential undefined/null
        };
    }

    // If no settings exist, return defaults
    return { ...DEFAULT_SETTINGS, userId };
}

/**
 * Saves or updates the global settings for a user.
 * It uses { merge: true } to prevent overwriting other fields.
 */
export async function saveSettings(userId: string, settings: Partial<UserSettings>): Promise<void> {
    const docRef = db.collection(SETTINGS_COLLECTION).doc(userId);
    
    // Explicitly construct the payload to ensure only defined fields are updated
    const updatePayload: Partial<UserSettings> = {
        userId: userId,
    };
    
    if (settings.globalModel !== undefined) updatePayload.globalModel = settings.globalModel;
    if (settings.globalSystemPrompt !== undefined) updatePayload.globalSystemPrompt = settings.globalSystemPrompt;
    if (settings.themeName !== undefined) updatePayload.themeName = settings.themeName;
    if (settings.themeMode !== undefined) updatePayload.themeMode = settings.themeMode;
    if (settings.apiKey !== undefined) updatePayload.apiKey = settings.apiKey;
    if (settings.templates !== undefined) updatePayload.templates = settings.templates;
    if (settings.streamingEnabled !== undefined) updatePayload.streamingEnabled = settings.streamingEnabled; // <-- NEW
    
    await docRef.set(updatePayload, { merge: true });
}


--- END FILE: lib\settings.ts ---

--- START FILE: public\file.svg ---

<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

--- END FILE: public\file.svg ---

--- START FILE: public\globe.svg ---

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

--- END FILE: public\globe.svg ---

--- START FILE: public\next.svg ---

<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

--- END FILE: public\next.svg ---

--- START FILE: public\vercel.svg ---

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

--- END FILE: public\vercel.svg ---

--- START FILE: public\window.svg ---

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

--- END FILE: public\window.svg ---

--- START FILE: types\chat.ts ---

// types/chat.ts

export type Role = 'user' | 'model';

export interface FileAttachment {
    base64Data: string; // Base64 encoded file content
    mimeType: string;
    filename: string;
    size: number; // File size in bytes
}

export interface ChatMessage {
    id: string; // UUID for message
    text: string;
    role: Role;
    timestamp: Date | number; // Use number (milliseconds) for Firestore
    files?: FileAttachment[]; // NEW: Optional files sent with the message
}

export interface Conversation {
    id: string; // UUID for conversation
    userId: string; // Required when Auth is implemented
    createdAt: Date | number;
    updatedAt: Date | number;
    title: string;
    messages: ChatMessage[];
    model?: string;
    systemPrompt?: string;
}

// NEW: Prompt Template structure
export interface PromptTemplate {
    id: string;
    name: string;
    content: string;
    model?: string;
}

// Global User Settings
export interface UserSettings {
    userId: string;
    globalModel: string;
    globalSystemPrompt: string;
    themeName: string; // NEW
    themeMode: 'light' | 'dark'; // NEW
    apiKey?: string | null; // NEW: Stored Gemini API Key
    templates?: PromptTemplate[]; // NEW: Stored templates
    streamingEnabled: boolean; // <-- ADDED: Controls typewriter effect
}

// --- Gemini Types ---
export interface TextPart {
    text: string;
}

export interface InlineDataPart {
    inlineData: {
        data: string; // Base64 content
        mimeType: string;
    };
}

export interface GeminiContent {
    role: 'user' | 'model';
    parts: (TextPart | InlineDataPart)[]; 
}


--- END FILE: types\chat.ts ---

--- START FILE: utils\firebase.ts ---

// utils/firebase.ts
import { initializeApp, getApps, getApp } from 'firebase/app';
import { getFirestore } from 'firebase/firestore';
import { getAuth } from 'firebase/auth';

// Ensure all environment variables are present for client-side config
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,
};

// Initialize Firebase for Client Use
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();
export const db = getFirestore(app);
export const auth = getAuth(app);
// Expose the app instance if needed for context
export { app };


--- END FILE: utils\firebase.ts ---

-------------------------------------------------------------------------------------------------

AI: This is a great set of feedback! Addressing these issues will significantly improve the usability and robustness of the application.

Here are the necessary code changes and explanations for each point.

### Summary of Fixes

1.  **Sidebar Toggle:** Implemented full desktop sidebar collapse functionality using the hamburger menu.
2.  **First Message Bug:** Fixed the logic flow in both the client (`ChatArea.tsx`) and the server (`lib/history.ts`) to prevent the chat from reloading after the first message and to stop message duplication in the database.
3.  **Chat Bubble Overflow:** Added essential CSS properties to ensure long code blocks scroll horizontally without breaking the main chat layout.
4.  **User Avatar Contrast:** Fixed the user avatar's text color using CSS variables to ensure high contrast against its background across all themes.

---

## 1. Core Structural Changes (app & sidebar)

We need to change how `app/page.tsx` and `components/Sidebar.tsx` handle the sidebar state to allow desktop collapsing, and modify `ChatArea.tsx` to ensure the toggle button is always present.

### `app/page.tsx`

The sidebar state management is updated to default to `open` on desktop and uses the `isSidebarOpen` state universally.

```tsx
// app/page.tsx
'use client';

import { useState, useEffect } from 'react';
import ChatArea from '@/components/ChatArea';
import Sidebar from '@/components/Sidebar';
import { useAuth } from '@/components/providers/AuthProvider';
import AuthGate from '@/components/ui/AuthGate';
import ConversationModeOverlay from '@/components/ConversationModeOverlay';
import { useTheme } from '@/components/providers/ThemeContext';

export default function HomePage() {
  const { user, loading: authLoading } = useAuth();
  const { loadingSettings } = useTheme();

  const [currentChatId, setCurrentChatId] = useState<string | undefined>(undefined);
  const [refreshSidebarToggle, setRefreshSidebarToggle] = useState(false);
  const [isConversationModeOpen, setIsConversationModeOpen] = useState(false);
  
  // === RESPONSIVENESS STATE ===
  const [isMobile, setIsMobile] = useState(false);
  // Default to true (open) for desktop load, will be set via effect if mobile
  const [isSidebarOpen, setIsSidebarOpen] = useState(true); 

  // Effect to determine screen size and manage sidebar visibility default
  useEffect(() => {
    const handleResize = () => {
      const mobile = window.innerWidth < 768; 
      setIsMobile(mobile);
      
      // If initialized or resized to mobile, set sidebar closed by default
      if (mobile && window.innerWidth < 768 && isSidebarOpen) {
          // If we were previously open on desktop, don't force close on resize.
          // We rely on the initial state and user clicks for dynamic behavior.
      }
    };

    window.addEventListener('resize', handleResize);
    handleResize(); // Initial check
    
    // Set initial state based on window size (if client side render)
    if (typeof window !== 'undefined') {
        const initialMobile = window.innerWidth < 768;
        setIsMobile(initialMobile);
        setIsSidebarOpen(!initialMobile); // Open on desktop by default
    }

    return () => window.removeEventListener('resize', handleResize);
  }, []); 
  // ===================================

  const handleSelectChat = (chatId: string | undefined) => {
    setCurrentChatId(chatId);
    if (isConversationModeOpen) setIsConversationModeOpen(false);
    
    if (isMobile) setIsSidebarOpen(false); 
  };
  
  const handleNewMessageSent = () => {
    setRefreshSidebarToggle(prev => !prev);
  }

  if (authLoading || loadingSettings) {
    return <div className="flex h-screen items-center justify-center text-xl" style={{color: 'var(--text-primary)'}}>Loading application...</div>
  }

  if (!user) {
    return <AuthGate />;
  }

  // Main application view
  return (
    // FIX: Ensure the main container is hidden overflow to prevent scroll issues
    <div className="flex h-screen overflow-hidden relative" style={{ backgroundColor: 'var(--bg-primary)' }}>
      
      {/* 1. Sidebar - Updated props and class logic moved to Sidebar.tsx */}
      <Sidebar 
        onSelectChat={handleSelectChat} 
        currentChatId={currentChatId}
        onNewMessageSent={handleNewMessageSent}
        onOpenConversationMode={() => { 
            setIsConversationModeOpen(true); 
            if (isMobile) setIsSidebarOpen(false);
        }} 
        key={refreshSidebarToggle.toString()} 
        
        isSidebarOpen={isSidebarOpen} // Universal state for open/closed
        onCloseSidebar={() => setIsSidebarOpen(false)} // Clearer name for close handler
        isMobileView={isMobile}
      />
      
      {/* 2. Main Chat Area */}
      {/* Note: Flex-1 ensures ChatArea takes the remaining space, adjusting dynamically as Sidebar width changes */}
      <main className="flex-1 flex flex-col min-w-0 w-full h-full"> 
        <ChatArea 
          chatId={currentChatId}
          onChatIdChange={setCurrentChatId}
          onNewMessageSent={handleNewMessageSent}
          onOpenConversationMode={() => setIsConversationModeOpen(true)}
          
          onToggleSidebar={() => setIsSidebarOpen(prev => !prev)}
          isMobileView={isMobile}
        />
      </main>
      
      {/* 3. Mobile Overlay Backdrop */}
      {isMobile && isSidebarOpen && (
        <div 
          className="fixed inset-0 bg-black/50 z-20 md:hidden" 
          onClick={() => setIsSidebarOpen(false)}
        />
      )}
      
      {/* 4. Conversation Mode Overlay */}
      {isConversationModeOpen && (
        <ConversationModeOverlay
          chatId={currentChatId}
          onChatIdChange={setCurrentChatId}
          onClose={() => setIsConversationModeOpen(false)}
          onNewMessageSent={handleNewMessageSent}
        />
      )}
    </div>
  );
}
```

### `components/Sidebar.tsx`

The props are renamed, and the class application logic is updated to handle desktop collapse (`w-0 p-0 overflow-hidden`).

```tsx
// components/Sidebar.tsx
'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { useTheme } from '@/components/providers/ThemeContext';
import PromptManager from './PromptManager'; 

interface ChatHistoryItem {
    id: string;
    title: string;
    updatedAt: number;
}

interface SidebarProps {
    onSelectChat: (chatId: string | undefined) => void;
    currentChatId: string | undefined;
    onNewMessageSent: () => void; 
    onOpenConversationMode: () => void; 
    isSidebarOpen: boolean; // Universal state for open/closed
    onCloseSidebar: () => void; // Universal close handler
    isMobileView: boolean;
}

// Available Models list (Kept the same)
const AVAILABLE_MODELS = [
    { id: 'gemini-3-pro-preview', name: 'Gemini 3.0 Pro' },
    { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro' },
    { id: 'gemini-2.5-flash-preview-09-2025', name: 'Gemini 2.5 Flash (Recommended)' },
    { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash (Stable)' },
    { id: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash Lite' },
];

export default function Sidebar({ onSelectChat, currentChatId, onNewMessageSent, onOpenConversationMode, isSidebarOpen, onCloseSidebar, isMobileView }: SidebarProps) {
    const { user, signOut, getIdToken } = useAuth();
    const { themeName, themeMode, setMode, setTheme, settings, updateSettings, availableThemes } = useTheme();
    
    const [history, setHistory] = useState<ChatHistoryItem[]>([]);
    const [loading, setLoading] = useState(true);
    const [isPromptManagerOpen, setIsPromptManagerOpen] = useState(false); 
    const [isSettingsCollapsed, setIsSettingsCollapsed] = useState(true); 
// ... (fetchHistory, other handlers remain the same)

    const handleSignOut = async () => {
        if (confirm("Are you sure you want to sign out?")) {
            await signOut();
        }
    };
    
// ... (other handlers remain the same)


    return (
        <div 
            className={`
                flex flex-col h-screen shadow-2xl shrink-0 transition-all duration-300 ease-in-out
                ${isMobileView 
                    ? `fixed z-30 inset-y-0 w-full max-w-[80%] p-3 ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}`
                    : isSidebarOpen ? 'w-64 relative translate-x-0 p-3' : 'w-0 p-0 overflow-hidden' // Desktop collapse logic
                }
            `} 
            style={{backgroundColor: 'var(--sidebar-bg)', color: 'var(--text-primary)', borderRight: isSidebarOpen ? '1px solid var(--sidebar-border)' : 'none'}}
        >
            
            {isPromptManagerOpen && (
                <PromptManager onClose={() => { setIsPromptManagerOpen(false); onNewMessageSent(); }} />
            )}
            
            {/* Only render content if sidebar is visibly open */}
            {isSidebarOpen ? (
                <>
                    <div className="flex items-center justify-between pb-4 border-b mb-4" style={{borderColor: 'var(--sidebar-border)'}}>
                        <h2 className="text-xl font-bold flex items-center gap-2" style={{color: 'var(--text-primary)'}}>
                            <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-primary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M4.343 19.657l.707-.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                            Big AI
                        </h2>
                        
                        {/* Mobile Close Button */}
                        {isMobileView && (
                            <button 
                                onClick={onCloseSidebar} 
                                className="p-1 rounded-full hover:bg-[var(--sidebar-item-hover)]"
                                style={{color: 'var(--text-primary)'}}
                            >
                                <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12"></path></svg>
                            </button>
                        )}
                    </div>
                    
                    {/* ... Rest of Sidebar content ... */}
                    
                    <button
                        onClick={handleNewChat}
                        className="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors mb-4"
                        style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}} 
                    >
                        <svg className="w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M12 4v16m8-8H4"></path></svg> 
                        Start New Chat
                    </button>


                    {/* Conversation Mode Button */}
                    <button
                        onClick={onOpenConversationMode}
                        className="w-full flex items-center justify-center p-3 rounded-xl font-semibold transition-colors mb-4"
                        style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-primary)', border: '1px solid var(--sidebar-border)'}}
                        title="Start Voice Conversation"
                    >
                        <svg className="w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                        Conversation Mode
                    </button>


                    {/* History List */}
                    <div className="flex-1 overflow-y-auto space-y-2 pr-1">
                        <h3 className="text-sm font-semibold uppercase sticky top-0 py-1" style={{color: 'var(--text-secondary)', backgroundColor: 'var(--sidebar-bg)'}}>
                            History ({history.length})
                        </h3>
                        {loading && <div className="text-sm p-3" style={{color: 'var(--text-secondary)'}}>Loading history...</div>}
                        
                        {history.length === 0 && !loading && (
                            <div className="text-sm p-3" style={{color: 'var(--text-secondary)'}}>No history found.</div>
                        )}
                        
                        {history.map((chat) => (
                            <div 
                                key={chat.id}
                                className={`group flex items-center justify-between p-3 rounded-lg text-sm transition duration-150 ${
                                    chat.id === currentChatId 
                                        ? 'font-semibold' 
                                        : 'hover:opacity-80'
                                }`}
                                style={{
                                    backgroundColor: chat.id === currentChatId ? 'var(--accent-primary)' : 'var(--bg-secondary)',
                                    color: chat.id === currentChatId ? 'var(--ai-bubble-text)' : 'var(--text-primary)',
                                    cursor: 'pointer'
                                }}
                                title={chat.title}
                            >
                                {/* Title Section (Clickable area to select chat) */}
                                <button
                                    onClick={() => onSelectChat(chat.id)}
                                    className="flex items-center flex-1 min-w-0 pr-2 text-left"
                                    style={{ color: 'inherit', background: 'none', border: 'none', padding: 0 }}
                                >
                                    <svg className="w-4 h-4 mr-2 shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M20 12H4M12 4v16"></path></svg>
                                    <span className="truncate flex-1">
                                        {chat.title}
                                    </span>
                                </button>
                                
                                {/* Delete Button (Visible on hover) */}
                                <button
                                    onClick={(e) => { e.stopPropagation(); handleDeleteChat(chat.id); }}
                                    className={`p-1 rounded transition ml-2 shrink-0 opacity-0 group-hover:opacity-100`}
                                    title="Delete Chat"
                                    style={{ 
                                        color: chat.id === currentChatId ? 'var(--ai-bubble-text)' : 'var(--accent-error)',
                                        backgroundColor: chat.id === currentChatId ? 'var(--accent-primary-hover)' : 'transparent',
                                    }}
                                >
                                    <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                </button>
                            </div>
                        ))}
                    </div>
                    
                    {/* Footer Area - Collapsible Settings and Auth */}
                    <div className="pt-4 border-t mt-4 space-y-2" style={{borderColor: 'var(--sidebar-border)'}}>
                        
                        {/* Settings Toggle Button */}
                        <button 
                            className="w-full flex items-center justify-between p-2 rounded-lg font-semibold transition"
                            onClick={() => setIsSettingsCollapsed(prev => !prev)}
                            style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--text-primary)'}}
                        >
                            <span className="flex items-center gap-2">
                                <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-primary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.942 3.333.9 2.456 2.456a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.942 1.543-.9 3.333-2.456 2.456a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.942-3.333-.9-2.456-2.456a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.942-1.543.9-3.333 2.456-2.456a1.724 1.724 0 002.572-1.065z"></path><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                                Settings
                            </span>
                            <svg className={`w-4 h-4 transition-transform ${isSettingsCollapsed ? 'transform rotate-0' : 'transform rotate-180'}`} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 9l-7 7-7-7"></path></svg>
                        </button>

                        {/* Collapsible Settings Content */}
                        <div className={`space-y-3 overflow-hidden transition-all duration-300 ${isSettingsCollapsed ? 'max-h-0' : 'max-h-[800px]'}`}>

                            {/* Quick Prompt/Template Access */}
                            <button 
                                className="w-full text-left text-sm p-2 rounded-lg transition"
                                onClick={() => { setIsPromptManagerOpen(true); if(isMobileView) onCloseSidebar(); }} // Close sidebar when opening manager
                                style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-secondary)'}}
                            >
                                <span className="font-semibold flex items-center gap-2">
                                    <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-2.414-2.414A1 1 0 0015.586 6H7a2 2 0 00-2 2v11a2 2 0 002 2zM17 17H7m10-4H7m4-4H7"></path></svg>
                                    Manage Prompts & API Key
                                </span>
                            </button>

                            {/* Model Selector */}
                            <div>
                                <label className="block text-xs font-medium uppercase mb-1" style={{color: 'var(--text-secondary)'}}>AI Model</label>
                                <select
                                    value={settings?.globalModel || AVAILABLE_MODELS[0].id}
                                    onChange={handleModelChange}
                                    className="w-full p-2 rounded-lg border text-sm"
                                    style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                                >
                                    {AVAILABLE_MODELS.map(model => (
                                        <option key={model.id} value={model.id}>{model.name}</option>
                                    ))}
                                </select>
                            </div>

                            {/* Theme Selector (Uses the expanded list from ThemeContext) */}
                            <div>
                                <label className="block text-xs font-medium uppercase mb-1" style={{color: 'var(--text-secondary)'}}>Theme</label>
                                <select
                                    value={themeName}
                                    onChange={handleThemeChange}
                                    className="w-full p-2 rounded-lg border text-sm"
                                    style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                                >
                                    {availableThemes.map(theme => (
                                        <option key={theme.id} value={theme.id}>{theme.name}</option>
                                    ))}
                                </select>
                            </div>

                            {/* Dark/Light Mode Toggle */}
                            <div className="flex items-center justify-between text-sm py-2">
                                <span style={{color: 'var(--text-secondary)'}}>Dark Mode ({themeMode})</span>
                                <label className="relative inline-block w-12 h-6">
                                    <input type="checkbox" checked={themeMode === 'dark'} onChange={handleModeToggle} className="opacity-0 w-0 h-0" />
                                    <span className="absolute cursor-pointer top-0 left-0 right-0 bottom-0 rounded-full before:absolute before:content-[''] before:h-4 before:w-4 before:left-1 before:bottom-1 before:rounded-full transition duration-400" 
                                        style={{
                                            backgroundColor: themeMode === 'dark' ? 'var(--accent-primary)' : 'var(--text-secondary)',
                                            '--tw-translate-x': themeMode === 'dark' ? '24px' : '0',
                                            transition: 'background-color 0.4s, transform 0.4s'
                                        } as React.CSSProperties}
                                    ></span>
                                </label>
                            </div>

                            {/* Streaming Toggle - Renamed Label */}
                            <div className="flex items-center justify-between text-sm py-2">
                                <span style={{color: 'var(--text-secondary)'}}>AI Response: {settings?.streamingEnabled ? 'Typing (Stream)' : 'Instant (Full)'}</span>
                                <label className="relative inline-block w-12 h-6">
                                    <input 
                                        type="checkbox" 
                                        checked={settings?.streamingEnabled ?? true} 
                                        onChange={handleStreamingToggle} 
                                        className="opacity-0 w-0 h-0" 
                                    />
                                    <span className="absolute cursor-pointer top-0 left-0 right-0 bottom-0 rounded-full before:absolute before:content-[''] before:h-4 before:w-4 before:left-1 before:bottom-1 before:rounded-full transition duration-400" 
                                        style={{
                                            backgroundColor: (settings?.streamingEnabled ?? true) ? 'var(--accent-primary)' : 'var(--text-secondary)',
                                            '--tw-translate-x': (settings?.streamingEnabled ?? true) ? '24px' : '0',
                                            transition: 'background-color 0.4s, transform 0.4s'
                                        } as React.CSSProperties}
                                    ></span>
                                </label>
                            </div>


                            {/* Data Management Buttons */}
                            <div className="pt-3 border-t space-y-2" style={{borderColor: 'var(--sidebar-border)'}}>
                                <button 
                                    className="w-full text-left text-sm p-2 rounded-lg transition"
                                    onClick={handleDeleteAllChats}
                                    style={{backgroundColor: 'var(--accent-error)', color: 'white'}}
                                >
                                    <span className="font-semibold flex items-center gap-2">
                                        <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                        Delete All Chats
                                    </span>
                                </button>
                                <button 
                                    className="w-full text-left text-sm p-2 rounded-lg transition"
                                    onClick={handleClearLocalStorage}
                                    style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--text-secondary)', border: '1px solid var(--sidebar-border)'}}
                                >
                                    <span className="font-semibold flex items-center gap-2">
                                        <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M4 7v10m0 0h16M4 17l4-4m-4 4l4 4M20 7v10m0 0H4m16 0l-4-4m4 4l-4 4M12 5v14"></path></svg>
                                        Clear Local Cache
                                    </span>
                                </button>
                            </div>
                        </div>

                        {/* Authentication Status */}
                        <div className="text-sm border-t pt-4 mt-4" style={{color: 'var(--text-secondary)', borderColor: 'var(--sidebar-border)'}}>
                            <div className="truncate mb-2" style={{color: 'var(--text-primary)'}}>
                                Logged in as: {user?.email || "User"}
                            </div>
                        </div>
                        <button 
                            className="w-full text-left text-sm p-2 rounded-lg transition hover:bg-red-900/50"
                            onClick={handleSignOut}
                            style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-error)'}}
                        >
                            Log out
                        </button>
                </>
            ) : null}
        </div>
    );
}
```

### `components/ChatArea.tsx`

Ensure the sidebar toggle button is visible on both mobile and desktop.

```tsx
// components/ChatArea.tsx (Header section)
// ... (around line 170)

      <header className="p-4 border-b shadow-sm flex justify-between items-center" style={{backgroundColor: 'var(--header-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}>
        
        {/* === SIDEBAR TOGGLE BUTTON (Visible on all screens now) === */}
        {/* Removed md:hidden to allow desktop toggle */}
        <button
            onClick={onToggleSidebar}
            className="p-2 rounded-lg transition mr-2 md:block" 
            title="Toggle Sidebar"
            disabled={isLoading || isHistoryLoading}
            style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-primary)', border: '1px solid var(--border-color)'}}
        >
             <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M4 6h16M4 12h16M4 18h7"></path></svg>
        </button>
        {/* ================================== */}

        <h1 className="font-semibold truncate max-w-[calc(100%-80px)]">
// ...
```

---

## 2. First Message Reload and Duplication Fix

This requires changes in three files: `ChatArea.tsx`, `lib/history.ts`, and `app/api/chat/route.ts`.

### `components/ChatArea.tsx` (Preventing Reload)

We introduce `isInitialExchange` state to signal the `useEffect` that the history is already current and a fetch/clear is unnecessary.

```tsx
// components/ChatArea.tsx
// ... (imports)

// ... (interface)

export default function ChatArea({ chatId, onChatIdChange, onNewMessageSent, onOpenConversationMode, onToggleSidebar, isMobileView }: ChatAreaProps) {
  const { user, getIdToken } = useAuth();
  const { settings } = useTheme();
  
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isHistoryLoading, setIsHistoryLoading] = useState(false);
  const [attachments, setAttachments] = useState<File[]>([]); 
  
  const chatEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);
  
  // NEW STATE: Tracks if the current chat ID change was due to sending the first message.
  const [isInitialExchange, setIsInitialExchange] = useState(false); 
  
// ... (useSpeechRecognition hook)

// ... (Dynamic Input Height Adjustment)


  // --- History Loading Effect ---
  useEffect(() => {
    if (!user) return;

    if (chatId) {
      
      // FIX 1: Prevent clearing/fetching if this ID change was triggered by the first message being sent.
      if (isInitialExchange) {
        setIsInitialExchange(false); // Reset flag
        setIsHistoryLoading(false);
        // Do NOT clear messages or fetch history, as local state is already accurate.
        return; 
      }

      setIsHistoryLoading(true);
      setMessages([]); // Clear old messages
      
      const fetchChatHistory = async () => {
        try {
// ... (rest of fetchChatHistory function remains the same)
          const token = await getIdToken();
          const response = await fetch(`/api/chat?chatId=${chatId}`, {
              headers: { 'Authorization': `Bearer ${token}` }
          });
          
          if (response.ok) {
            const conversation: Conversation = await response.json();
            const clientMessages: ChatMessage[] = conversation.messages.map(m => ({
                ...m,
                timestamp: new Date(m.timestamp),
            }));
            setMessages(clientMessages);
          } else {
            console.error("Failed to load conversation:", chatId);
            setMessages([{ id: uuidvv4(), text: 'Failed to load conversation history. Check console for details.', role: 'model', timestamp: new Date() } as ChatMessage]);
          }
        } catch (error) {
          console.error("Error fetching chat history:", error);
        } finally {
          setIsHistoryLoading(false);
        }
      };
      fetchChatHistory();
    } else {
      // New chat state
      setMessages([]);
      setAttachments([]); 
      setIsHistoryLoading(false);
    }
  }, [chatId, user, getIdToken, isInitialExchange]); // Add isInitialExchange to dependency array

// ... (updateBotStreamingMessage, finalizeBotMessage remain the same)

  // --- Main Send Handler ---

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
// ... (input validation, attachment conversion, setting up user/pending messages)

    addMessage(userMessage);
    addMessage({ 
        id: BOT_PENDING_ID, 
        text: '...', 
        role: 'model', 
        timestamp: new Date() 
    } as ChatMessage);
    
    setInput('');
    setAttachments([]); 
    setIsLoading(true);

    try {
// ... (API call setup)

      const response = await fetch('/api/chat', {
// ... (API call body/headers)
      });
      
      // ... (Error handling)

      const newChatId = response.headers.get('X-Chat-ID');
      if (newChatId && newChatId !== chatId) {
          // FIX 2: Set flag before updating parent state
          setIsInitialExchange(true); 
          onChatIdChange(newChatId); 
      }

// ... (stream reading and finalization)

    } catch (error) {
// ...
    } finally {
      setIsLoading(false);
    }
  };
  
// ... (rest of component)
```

### `lib/history.ts` (Preventing Duplication)

We modify `updateConversation` to detect `isFirstExchange` and skip appending the user's message, as it was already saved during `createConversation`.

```typescript
// lib/history.ts

// ... (imports, helpers)

/**
 * Appends a new user message and the subsequent AI response to an existing conversation.
 */
export async function updateConversation(
    chatId: string, 
    userText: string, 
    modelText: string,
    userId: string, // Require User ID for security
    files: FileAttachment[] = [],
    isFirstExchange: boolean = false // <-- This flag determines the fix
): Promise<void> {
    
    // First, verify access (Essential Security Check)
    const docRef = db.collection(CONVERSATIONS_COLLECTION).doc(chatId);
    const doc = await docRef.get();
    if (!doc.exists || doc.data()?.userId !== userId) {
        throw new Error("Unauthorized chat update attempt.");
    }
    
    const now = Date.now();
    
    const userMessage: ChatMessage = {
        id: uuidv4(),
        text: userText,
        role: 'user' as Role,
        timestamp: now,
        files: files.length > 0 ? files : undefined,
    };
    
    const modelMessage: ChatMessage = {
        id: uuidv4(),
        text: modelText,
        role: 'model' as Role,
        timestamp: now,
    };

    const serializedUserMessage = serializeMessage(userMessage);
    const serializedModelMessage = serializeMessage(modelMessage);

    let messagesToAppend: FirestoreMessage[];

    if (isFirstExchange) {
        // FIX: If it's the first exchange, the user message is already stored by createConversation.
        // We only append the model response.
        messagesToAppend = [serializedModelMessage];
    } else {
        // Normal exchange: append both user message and model response.
        messagesToAppend = [serializedUserMessage, serializedModelMessage];
    }

    const updateData: { messages: admin.firestore.FieldValue; updatedAt: number; title?: string } = {
        messages: admin.firestore.FieldValue.arrayUnion(...messagesToAppend),
        updatedAt: now,
    };

    if (isFirstExchange) {
        updateData.title = generateTitle(userText);
    }
    
    await docRef.update(updateData);
}
// ... (rest of file remains the same)
```

### `app/api/chat/route.ts` (Ensuring `isFirstExchange` is correct)

This file already correctly sets `isFirstExchange = true` when `incomingChatId` is missing, and passes this flag to `updateConversation`. No changes needed here, as the previous file handles the duplication logic.

---

## 3. Chat Bubble Overflow Fix

This is a CSS fix to ensure code blocks respect their container width and enable horizontal scrolling internally.

### `app\globals.css`

```css
/* app/globals.css */
/* ... (existing styles) ... */

/* Markdown and Code Styling Overrides */

/* Code block wrapper (created by custom renderer) */
.code-block-container {
    background-color: var(--code-block-bg) !important;
    border: 1px solid var(--code-block-border) !important;
    border-radius: 0.5rem !important;
    margin-top: 1rem !important;
    margin-bottom: 1rem !important;
    overflow: hidden; /* Contains children border radius */
    max-width: 100%; /* FIX 1: Constrain the wrapper */
}

/* Code block container (standard markdown pre tag) */
.message-content pre {
    /* Remove default markdown styles from PRE */
    background-color: var(--code-block-bg) !important;
    border: none !important;
    margin: 0 !important;
    padding: 0 !important;
    border-radius: 0 !important;
    overflow-x: auto; /* FIX: Enable horizontal scroll */
    max-width: 100%; /* FIX 2: Ensure pre respects parent constraint */
}

/* Code content inside pre (Prism.js applies most styling here) */
.message-content pre code {
    /* Override Prism's default padding/margin/background/text settings */
    color: var(--text-primary); /* Use theme color for text */
    display: block;
    padding: 1rem !important; /* Padding for the code content */
    background: transparent !important; /* Use container background, not code background */
    min-width: 100%; /* Important for horizontal scrolling */
    box-sizing: border-box;
    /* FIX: Force content not to wrap for horizontal scrolling */
    white-space: pre !important; 
    max-width: 1000px; /* This line is harmless, but the overflow-x fix is crucial */
}

/* ... (rest of file remains the same) */
```

---

## 4. User Avatar Contrast Fix

We modify the user avatar element to use dynamically contrasting colors based on the theme variables (`--text-primary` for background, and `--bg-primary` for text).

### `components/ChatBubble.tsx`

```tsx
// components/ChatBubble.tsx
// ... (around line 300)

    return (
        // Added 'group' class here to enable CSS hover effects for message actions
        <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} group`}>
            <div className="flex items-start max-w-[75%]">
                {/* Avatar / Role Indicator (AI) */}
                <div className={`p-2 rounded-full text-white mr-3 shrink-0 self-start ${isUser ? 'hidden' : 'bg-blue-600'}`} style={{backgroundColor: isUser ? 'var(--text-primary)' : 'var(--accent-primary)'}}>
                    {isUser ? '' : 'AI'}
                </div>
                
                {/* Bubble Content */}
                <div
                    className={`p-3 rounded-xl shadow-md transition duration-300 ease-in-out break-words relative w-full ${ // w-full added previously, ensures bubble maximizes its 75% width
                        isUser
                            ? 'rounded-bl-none'
                            : 'rounded-tr-none border'
                    }`}
                    style={{
                        backgroundColor: isUser ? 'var(--user-bubble-bg)' : 'var(--ai-bubble-bg)',
                        color: isUser ? 'var(--user-bubble-text)' : 'var(--ai-bubble-text)',
                        borderColor: isUser ? 'transparent' : 'var(--border-color)'
                    }}
                >
                    {/* Render Multimodal Attachments first */}
                    {message.files && renderAttachments(message.files)}

                    {/* Render Text Content */}
                    <div 
                        ref={contentRef}
                        className={`message-content ${isUser ? '' : 'prose max-w-none'}`} 
                        dangerouslySetInnerHTML={{ __html: sanitizedHtml }}
                    />
                    
                    {/* ... (Message Actions) ... */}
                </div>
                
                {/* User Avatar / Role Indicator (User) */}
                {/* FIX: Removed conflicting Tailwind classes (text-white, bg-gray-500) and forced dynamic contrast */}
                <div 
                    className={`p-2 rounded-full ml-3 shrink-0 self-start ${isUser ? '' : 'hidden'}`} 
                    style={{
                        // Background is the theme's primary text color (e.g., light gray in dark mode)
                        backgroundColor: 'var(--text-primary)', 
                        // Text color is the theme's primary background color (e.g., near black in dark mode)
                        color: 'var(--bg-primary)' 
                    }}
                >
                    {isUser ? 'You' : ''}
                </div>
            </div>
        </div>
    );
}

export default ChatBubble;
```

---

By applying these changes, you will have a collapsible sidebar interface, a reliable initial chat workflow without duplication, robust handling for wide content, and improved contrast for the user avatar across all themes.

-------------------------

send me the full updated codes by making the suggested changes.