part 1 : 

--- START FILE: .gitignore ---

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
package-lock.json

--- END FILE: .gitignore ---

--- START FILE: eslint.config.mjs ---

import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;


--- END FILE: eslint.config.mjs ---

--- START FILE: netlify.toml ---

# Configuration file for Netlify deployment

[build]
  command = "npm run build"
  publish = ".next"

# Tell Netlify's secrets scanner to ignore the public Firebase keys
# These are necessary for the client-side application to work and are 
# intentionally exposed in the browser bundle.
[context.production.environment]
  SECRETS_SCAN_OMIT_KEYS = "NEXT_PUBLIC_FIREBASE_API_KEY,NEXT_PUBLIC_FIREBASE_APP_ID,NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,NEXT_PUBLIC_FIREBASE_PROJECT_ID,NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET"

# If you use the Netlify Next.js plugin, it usually handles redirects 
# and headers, but adding basic cache control is always good practice.
[[headers]]
  for = "/_next/static/*"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

--- END FILE: netlify.toml ---

--- START FILE: next-env.d.ts ---

/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


--- END FILE: next-env.d.ts ---

--- START FILE: next.config.ts ---

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


--- END FILE: next.config.ts ---

--- START FILE: package.json ---

{
  "name": "big-ai",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@google/genai": "^1.31.0",
    "@types/uuid": "^11.0.0",
    "firebase": "^12.6.0",
    "firebase-admin": "^13.6.0",
    "next": "16.0.7",
    "react": "19.2.1",
    "react-dom": "19.2.1",
    "uuid": "^13.0.0",
    "marked": "^17.0.1",
    "dompurify": "^3.3.0",
    "prismjs": "^1.30.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^24",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/dompurify": "^3.2.0",
    "@types/prismjs": "^1.26.5",
    "eslint": "^9",
    "eslint-config-next": "16.0.7",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}


--- END FILE: package.json ---

--- START FILE: postcss.config.mjs ---

const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;


--- END FILE: postcss.config.mjs ---

--- START FILE: README.md ---

websiet link : https://big-ai-chatbot.netlify.app/

--- END FILE: README.md ---

--- START FILE: tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}


--- END FILE: tsconfig.json ---

--- START FILE: app\globals.css ---

/* app/globals.css */
@import "tailwindcss";

/*
 * --- Global Default Variables (Small AI v2 Default Light) ---
 */
:root {
  --bg-primary: #f3f4f6;
  --bg-secondary: #ffffff;
  --text-primary: #1f2937;
  --text-secondary: #4b5563;
  --border-color: #e5e7eb;
  --card-bg: #ffffff;
  --card-border: #e5e7eb; /* NEW */
  --header-bg: #f9fafb;
  --accent-primary: #2563eb; /* blue-600 */
  --accent-primary-hover: #1d4ed8; /* blue-700 */
  --accent-secondary: #fcd34d; /* amber-300 */
  --accent-error: #ef4444; /* red-500 */
  --accent-success: #22c55e; /* green-500 */
  --user-bubble-bg: #bfdbfe; /* blue-200 */
  --user-bubble-text: #1e40af; /* blue-700 */
  --ai-bubble-bg: #f3f4f6; /* gray-100 */
  --ai-bubble-text: #374151; /* gray-700 */
  --sidebar-bg: #ffffff;
  --sidebar-border: #e5e7eb;
  --sidebar-item-hover: #f3f4f6;
  --loader-dot-color: var(--accent-primary);
  --code-block-bg: #f5f7fa;
  --code-block-header-bg: #e8ebf0;
  --code-block-border: #e2e4e8;
  --conversation-indicator: var(--accent-primary);
  --main-chat-window-bg: rgba(255, 255, 255, 0.8); /* NEW */
  --conversation-bg: rgba(255, 255, 255, 0.95); /* NEW */
  --conversation-text: #1f2937; /* NEW */
}

/*
 * --- Default Dark Mode (Fallback/Original) ---
 */
[data-theme$="-dark"] {
  :root {
    --bg-primary: #0a0a0a;
    --bg-secondary: #171717;
    --text-primary: #e5e7eb;
    --text-secondary: #a1a1aa;
    --border-color: #2d3748;
    --card-bg: #1f2937;
    --card-border: #2d3748;
    --header-bg: #1f2937;
    --accent-primary: #60a5fa; /* blue-400 */
    --accent-primary-hover: #3b82f6; /* blue-500 */
    --accent-secondary: #fcd34d; /* amber-300 */
    --accent-error: #f87171; /* red-400 */
    --accent-success: #4ade80; /* green-400 */
    --user-bubble-bg: #1e3a8a; /* blue-800 */
    --user-bubble-text: #e0f2fe; /* blue-100 */
    --ai-bubble-bg: #374151; /* gray-700 */
    --ai-bubble-text: #f9fafb; /* gray-50 */
    --sidebar-bg: #0a0a0a;
    --sidebar-border: #2d3748;
    --sidebar-item-hover: #171717;
    --code-block-bg: #1f2937;
    --code-block-header-bg: #171717;
    --code-block-border: #2d3748;
    --main-chat-window-bg: rgba(19, 19, 26, 0.9);
    --conversation-bg: rgba(19, 19, 26, 0.95);
    --conversation-text: #e5e7eb;
    --conversation-indicator: #818cf8;
  }
}

@media (prefers-color-scheme: dark) {
  :root {
    --bg-primary: #0a0a0a;
    --bg-secondary: #171717;
    --text-primary: #e5e7eb;
    --text-secondary: #a1a1aa;
    --border-color: #2d3748;
    --card-bg: #1f2937;
    --card-border: #2d3748;
    --header-bg: #1f2937;
    --accent-primary: #60a5fa; /* blue-400 */
    --accent-primary-hover: #3b82f6; /* blue-500 */
    --accent-secondary: #fcd34d; /* amber-300 */
    --accent-error: #f87171; /* red-400 */
    --accent-success: #4ade80; /* green-400 */
    --user-bubble-bg: #1e3a8a; /* blue-800 */
    --user-bubble-text: #e0f2fe; /* blue-100 */
    --ai-bubble-bg: #374151; /* gray-700 */
    --ai-bubble-text: #f9fafb; /* gray-50 */
    --sidebar-bg: #0a0a0a;
    --sidebar-border: #2d3748;
    --sidebar-item-hover: #171717;
    --code-block-bg: #1f2937;
    --code-block-header-bg: #171717;
    --code-block-border: #2d3748;
    --main-chat-window-bg: rgba(19, 19, 26, 0.9);
    --conversation-bg: rgba(19, 19, 26, 0.95);
    --conversation-text: #e5e7eb;
    --conversation-indicator: #818cf8;
  }
}

/* --- MERGED THEMES FROM PART 2 START --- */
/* Celestial Horizon Theme: Dark Mode (Existing, standardized) */
[data-theme="celestial-horizon-dark"] {
    --bg-primary: #0D1117;
    --bg-secondary: #161B22;
    --text-primary: #C9D1D9;
    --text-secondary: #8B949E;
    --border-color: #30363D;
    --card-bg: #1F2633;
    --card-border: #30363D;
    --header-bg: #161B22;
    --accent-primary: #58A6FF;
    --accent-primary-hover: #388BF2;
    --accent-secondary: #B1B8C1;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #253B64;
    --user-bubble-text: #E0F2FE;
    --ai-bubble-bg: #1F2633;
    --ai-bubble-text: #C9D1D9;
    --sidebar-bg: #161B22;
    --sidebar-border: #30363D;
    --sidebar-item-hover: #1F2633;
    --code-block-bg: #1F2633;
    --code-block-header-bg: #161B22;
    --code-block-border: #30363D;
    --conversation-indicator: #58A6FF;
    --main-chat-window-bg: rgba(22, 27, 34, 0.9);
    --conversation-bg: rgba(22, 27, 34, 0.95);
    --conversation-text: #C9D1D9;
}

/* Celestial Horizon Theme: Light Mode */
[data-theme="celestial-horizon-light"] {
    --bg-primary: #F0F4F8;
    --bg-secondary: #FFFFFF;
    --text-primary: #2D3748;
    --text-secondary: #718096;
    --border-color: #E2E8F0;
    --card-bg: #FFFFFF;
    --card-border: #E2E8F0;
    --header-bg: #EDF2F7;
    --accent-primary: #3B82F6;
    --accent-primary-hover: #2563EB;
    --accent-secondary: #60A5FA;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #DBEAFE;
    --user-bubble-text: #1E40AF;
    --ai-bubble-bg: #EBF4FF;
    --ai-bubble-text: #2D3748;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E2E8F0;
    --sidebar-item-hover: #F0F4F8;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2D3748;
    --conversation-indicator: #3B82F6;
    --code-block-bg: #EBF4FF;
    --code-block-header-bg: #EDF2F7;
    --code-block-border: #E2E8F0;
}

/* Verdant Calm Theme: Dark Mode */
[data-theme="verdant-calm-dark"] {
    --bg-primary: #1a2a22;
    --bg-secondary: #21362d;
    --text-primary: #e0f2e8;
    --text-secondary: #99bbaa;
    --border-color: #3f544c;
    --card-bg: #294237;
    --card-border: #4a6356;
    --header-bg: #2c493c;
    --accent-primary: #3cb878;
    --accent-primary-hover: #2fa163;
    --accent-secondary: #60c58e;
    --accent-error: #f87171;
    --accent-success: #4ade80;
    --user-bubble-bg: #1e8449;
    --user-bubble-text: #e0f2e8;
    --ai-bubble-bg: #34495e;
    --ai-bubble-text: #e0f2e8;
    --sidebar-bg: #21362d;
    --sidebar-border: #3f544c;
    --sidebar-item-hover: #2c493c;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(33, 54, 45, 0.9);
    --conversation-bg: rgba(33, 54, 45, 0.95);
    --conversation-text: #e0f2e8;
    --conversation-indicator: #3cb878;
    --code-block-bg: #34495e;
    --code-block-header-bg: #2c493c;
    --code-block-border: #3f544c;
}

/* Verdant Calm Theme: Light Mode */
[data-theme="verdant-calm-light"] {
    --bg-primary: #edf9f5;
    --bg-secondary: #ffffff;
    --text-primary: #2d3f35;
    --text-secondary: #5e7d6b;
    --border-color: #dbeae5;
    --card-bg: #ffffff;
    --card-border: #dbeae5;
    --header-bg: #f5fcf9;
    --accent-primary: #3cb878;
    --accent-primary-hover: #2fa163;
    --accent-secondary: #60c58e;
    --accent-error: #ef4444;
    --accent-success: #22c55e;
    --user-bubble-bg: #c8e6c9;
    --user-bubble-text: #1b5e20;
    --ai-bubble-bg: #e8f5e9;
    --ai-bubble-text: #388e3c;
    --sidebar-bg: #ffffff;
    --sidebar-border: #dbeae5;
    --sidebar-item-hover: #edf9f5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2d3f35;
    --conversation-indicator: #3cb878;
    --code-block-bg: #e8f5e9;
    --code-block-header-bg: #f5fcf9;
    --code-block-border: #dbeae5;
}

/* Cybernetic Pulse Theme: Dark Mode */
[data-theme="cybernetic-pulse-dark"] {
    --bg-primary: #0a0e1a;
    --bg-secondary: #161c28;
    --text-primary: #e2e8f0;
    --text-secondary: #94a3b8;
    --border-color: #2f3e52;
    --card-bg: #1f2a3a;
    --card-border: #3a4b5e;
    --header-bg: #1f2a3a;
    --accent-primary: #0ea5e9;
    --accent-primary-hover: #0284c7;
    --accent-secondary: #38bdf8;
    --accent-error: #f87171;
    --accent-success: #4ade80;
    --user-bubble-bg: #0c4a6e;
    --user-bubble-text: #e0f2fe;
    --ai-bubble-bg: #2d3748;
    --ai-bubble-text: #f0f8ff;
    --sidebar-bg: #161c28;
    --sidebar-border: #2f3e52;
    --sidebar-item-hover: #1f2a3a;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(22, 28, 40, 0.9);
    --conversation-bg: rgba(22, 28, 40, 0.95);
    --conversation-text: #e2e8f0;
    --conversation-indicator: #0ea5e9;
    --code-block-bg: #2d3748;
    --code-block-header-bg: #1f2a3a;
    --code-block-border: #2f3e52;
}

/* Cybernetic Pulse Theme: Light Mode */
[data-theme="cybernetic-pulse-light"] {
    --bg-primary: #f8fafc;
    --bg-secondary: #ffffff;
    --text-primary: #1e293b;
    --text-secondary: #475569;
    --border-color: #e0e7f2;
    --card-bg: #ffffff;
    --card-border: #e0e7f2;
    --header-bg: #f1f5f9;
    --accent-primary: #0ea5e9;
    --accent-primary-hover: #0284c7;
    --accent-secondary: #38bdf8;
    --accent-error: #ef4444;
    --accent-success: #22c55e;
    --user-bubble-bg: #bfdbfe;
    --user-bubble-text: #1e3a8a;
    --ai-bubble-bg: #e0f2fe;
    --ai-bubble-text: #0284c7;
    --sidebar-bg: #ffffff;
    --sidebar-border: #e0e7f2;
    --sidebar-item-hover: #f1f5f9;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #1e293b;
    --conversation-indicator: #0ea5e9;
    --code-block-bg: #e0f2fe;
    --code-block-header-bg: #f1f5f9;
    --code-block-border: #e0e7f2;
}

/* Urban Pulse Theme: Dark Mode */
[data-theme="urban-pulse-dark"] {
    --bg-primary: #1A1A1D;
    --bg-secondary: #242426;
    --text-primary: #F0F0F0;
    --text-secondary: #A0A0A0;
    --border-color: #38383B;
    --card-bg: #242426;
    --card-border: #38383B;
    --header-bg: #1A1A1D;
    --accent-primary: #00BFFF;
    --accent-primary-hover: #009ACD;
    --accent-secondary: #66CCFF;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #0F4C81;
    --user-bubble-text: #E0FFFF;
    --ai-bubble-bg: #36454F;
    --ai-bubble-text: #F0F0F0;
    --sidebar-bg: #1A1A1D;
    --sidebar-border: #38383B;
    --sidebar-item-hover: #242426;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(36, 36, 38, 0.9);
    --conversation-bg: rgba(36, 36, 38, 0.95);
    --conversation-text: #F0F0F0;
    --conversation-indicator: #00BFFF;
    --code-block-bg: #36454F;
    --code-block-header-bg: #1A1A1D;
    --code-block-border: #38383B;
}

/* Urban Pulse Theme: Light Mode */
[data-theme="urban-pulse-light"] {
    --bg-primary: #F2F4F8;
    --bg-secondary: #FFFFFF;
    --text-primary: #333333;
    --text-secondary: #777777;
    --border-color: #DDE2E8;
    --card-bg: #FFFFFF;
    --card-border: #DDE2E8;
    --header-bg: #E8ECF2;
    --accent-primary: #1E90FF;
    --accent-primary-hover: #107EEB;
    --accent-secondary: #63B2FF;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #CCE5FF;
    --user-bubble-text: #003F8C;
    --ai-bubble-bg: #E8F0F5;
    --ai-bubble-text: #333333;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #DDE2E8;
    --sidebar-item-hover: #E8F0F5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #333333;
    --conversation-indicator: #1E90FF;
    --code-block-bg: #E8F0F5;
    --code-block-header-bg: #E8ECF2;
    --code-block-border: #DDE2E8;
}

/* Rustic Ember Theme: Dark Mode */
[data-theme="rustic-ember-dark"] {
    --bg-primary: #3E2723;
    --bg-secondary: #4E342E;
    --text-primary: #FBE9E7;
    --text-secondary: #BCAAA4;
    --border-color: #5D4037;
    --card-bg: #4E342E;
    --card-border: #5D4037;
    --header-bg: #3E2723;
    --accent-primary: #D84315;
    --accent-primary-hover: #BF360C;
    --accent-secondary: #FF8A65;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #8D6E63;
    --user-bubble-text: #FBE9E7;
    --ai-bubble-bg: #5D4037;
    --ai-bubble-text: #FBE9E7;
    --sidebar-bg: #3E2723;
    --sidebar-border: #5D4037;
    --sidebar-item-hover: #4E342E;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(78, 52, 46, 0.9);
    --conversation-bg: rgba(78, 52, 46, 0.95);
    --conversation-text: #FBE9E7;
    --conversation-indicator: #D84315;
    --code-block-bg: #5D4037;
    --code-block-header-bg: #3E2723;
    --code-block-border: #5D4037;
}

/* Rustic Ember Theme: Light Mode */
[data-theme="rustic-ember-light"] {
    --bg-primary: #F5E8DC;
    --bg-secondary: #FFFFFF;
    --text-primary: #4E342E;
    --text-secondary: #8D6E63;
    --border-color: #E6DCCD;
    --card-bg: #FFFFFF;
    --card-border: #E6DCCD;
    --header-bg: #F8EFE5;
    --accent-primary: #E65100;
    --accent-primary-hover: #D84315;
    --accent-secondary: #FFB74D;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #FFCCBC;
    --user-bubble-text: #BF360C;
    --ai-bubble-bg: #FBE9E7;
    --ai-bubble-text: #4E342E;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E6DCCD;
    --sidebar-item-hover: #F8EFE5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #4E342E;
    --conversation-indicator: #E65100;
    --code-block-bg: #FBE9E7;
    --code-block-header-bg: #F8EFE5;
    --code-block-border: #E6DCCD;
}

/* Neon Mirage Theme: Dark Mode */
[data-theme="neon-mirage-dark"] {
    --bg-primary: #05001C;
    --bg-secondary: #120033;
    --text-primary: #E0FFFF;
    --text-secondary: #8A2BE2;
    --border-color: #2F004F;
    --card-bg: #1A0040;
    --card-border: #2F004F;
    --header-bg: #120033;
    --accent-primary: #FF1493;
    --accent-primary-hover: #C7007C;
    --accent-secondary: #00BFFF;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #4B0082;
    --user-bubble-text: #E0FFFF;
    --ai-bubble-bg: #2E0854;
    --ai-bubble-text: #E0FFFF;
    --sidebar-bg: #120033;
    --sidebar-border: #2F004F;
    --sidebar-item-hover: #1A0040;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(26, 0, 64, 0.9);
    --conversation-bg: rgba(26, 0, 64, 0.95);
    --conversation-text: #E0FFFF;
    --conversation-indicator: #FF1493;
    --code-block-bg: #2E0854;
    --code-block-header-bg: #120033;
    --code-block-border: #2F004F;
}

/* Neon Mirage Theme: Light Mode */
[data-theme="neon-mirage-light"] {
    --bg-primary: #F8F0FF;
    --bg-secondary: #FFFFFF;
    --text-primary: #330066;
    --text-secondary: #663399;
    --border-color: #EBD9FC;
    --card-bg: #FFFFFF;
    --card-border: #EBD9FC;
    --header-bg: #F2E0FF;
    --accent-primary: #FF69B4;
    --accent-primary-hover: #E0509B;
    --accent-secondary: #87CEEB;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #FCE4EC;
    --user-bubble-text: #C2185B;
    --ai-bubble-bg: #F3E5F5;
    --ai-bubble-text: #330066;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #EBD9FC;
    --sidebar-item-hover: #F2E0FF;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #330066;
    --conversation-indicator: #FF69B4;
    --code-block-bg: #F3E5F5;
    --code-block-header-bg: #F2E0FF;
    --code-block-border: #EBD9FC;
}

/* Ivory Bloom Theme: Dark Mode */
[data-theme="ivory-bloom-dark"] {
    --bg-primary: #2B2D42;
    --bg-secondary: #4A4E69;
    --text-primary: #DCDCDC;
    --text-secondary: #A0A4B8;
    --border-color: #5D607E;
    --card-bg: #4A4E69;
    --card-border: #5D607E;
    --header-bg: #373A50;
    --accent-primary: #9B59B6;
    --accent-primary-hover: #8E44AD;
    --accent-secondary: #66CCFF;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #7C4F9B;
    --user-bubble-text: #FFFFFF;
    --ai-bubble-bg: #5D607E;
    --ai-bubble-text: #DCDCDC;
    --sidebar-bg: #2B2D42;
    --sidebar-border: #5D607E;
    --sidebar-item-hover: #373A50;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(74, 78, 105, 0.9);
    --conversation-bg: rgba(74, 78, 105, 0.95);
    --conversation-text: #DCDCDC;
    --conversation-indicator: #9B59B6;
    --code-block-bg: #5D607E;
    --code-block-header-bg: #373A50;
    --code-block-border: #5D607E;
}

/* Ivory Bloom Theme: Light Mode */
[data-theme="ivory-bloom-light"] {
    --bg-primary: #FDFDFD;
    --bg-secondary: #FFFFFF;
    --text-primary: #333333;
    --text-secondary: #777777;
    --border-color: #EAEAEA;
    --card-bg: #FFFFFF;
    --card-border: #EAEAEA;
    --header-bg: #F5F5F5;
    --accent-primary: #8E44AD;
    --accent-primary-hover: #7F3C9E;
    --accent-secondary: #BA68C8;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #F2E6F7;
    --user-bubble-text: #5D2C7B;
    --ai-bubble-bg: #EAE0F0;
    --ai-bubble-text: #333333;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #EAEAEA;
    --sidebar-item-hover: #F5F5F5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #333333;
    --conversation-indicator: #8E44AD;
    --code-block-bg: #EAE0F0;
    --code-block-header-bg: #F5F5F5;
    --code-block-border: #EAEAEA;
}

/* Obsidian Night Theme: Dark Mode */
[data-theme="obsidian-night-dark"] {
    --bg-primary: #121212;
    --bg-secondary: #1E1E1E;
    --text-primary: #F0F0F0;
    --text-secondary: #A0A0A0;
    --border-color: #333333;
    --card-bg: #1E1E1E;
    --card-border: #333333;
    --header-bg: #121212;
    --accent-primary: #BB86FC;
    --accent-primary-hover: #9E65E2;
    --accent-secondary: #03DAC6;
    --accent-error: #CF6679;
    --accent-success: #03DAC6;
    --user-bubble-bg: #3700B3;
    --user-bubble-text: #FFFFFF;
    --ai-bubble-bg: #2C2C2C;
    --ai-bubble-text: #F0F0F0;
    --sidebar-bg: #121212;
    --sidebar-border: #333333;
    --sidebar-item-hover: #1E1E1E;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(30, 30, 30, 0.9);
    --conversation-bg: rgba(30, 30, 30, 0.95);
    --conversation-text: #F0F0F0;
    --conversation-indicator: #BB86FC;
    --code-block-bg: #2C2C2C;
    --code-block-header-bg: #121212;
    --code-block-border: #333333;
}

/* Obsidian Night Theme: Light Mode */
[data-theme="obsidian-night-light"] {
    --bg-primary: #E0E0E0;
    --bg-secondary: #FFFFFF;
    --text-primary: #2C2C2C;
    --text-secondary: #6B6B6B;
    --border-color: #C0C0C0;
    --card-bg: #FFFFFF;
    --card-border: #C0C0C0;
    --header-bg: #D0D0D0;
    --accent-primary: #6200EE;
    --accent-primary-hover: #5B00D9;
    --accent-secondary: #018786;
    --accent-error: #B00020;
    --accent-success: #018786;
    --user-bubble-bg: #BBDEFB;
    --user-bubble-text: #1A237E;
    --ai-bubble-bg: #E0E0E0;
    --ai-bubble-text: #2C2C2C;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #C0C0C0;
    --sidebar-item-hover: #D0D0D0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2C2C2C;
    --conversation-indicator: #6200EE;
    --code-block-bg: #E0E0E0;
    --code-block-header-bg: #D0D0D0;
    --code-block-border: #C0C0C0;
}

/* Solar Dawn Theme: Dark Mode */
[data-theme="solar-dawn-dark"] {
    --bg-primary: #1A0E2A;
    --bg-secondary: #2C1840;
    --text-primary: #FCE8D8;
    --text-secondary: #D8BFD8;
    --border-color: #40265B;
    --card-bg: #2C1840;
    --card-border: #40265B;
    --header-bg: #1A0E2A;
    --accent-primary: #FF5722;
    --accent-primary-hover: #E64A19;
    --accent-secondary: #FFCC80;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #7C4F9B;
    --user-bubble-text: #FCE8D8;
    --ai-bubble-bg: #40265B;
    --ai-bubble-text: #FCE8D8;
    --sidebar-bg: #1A0E2A;
    --sidebar-border: #40265B;
    --sidebar-item-hover: #2C1840;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(44, 24, 64, 0.9);
    --conversation-bg: rgba(44, 24, 64, 0.95);
    --conversation-text: #FCE8D8;
    --conversation-indicator: #FF5722;
    --code-block-bg: #40265B;
    --code-block-header-bg: #1A0E2A;
    --code-block-border: #40265B;
}

/* Solar Dawn Theme: Light Mode */
[data-theme="solar-dawn-light"] {
    --bg-primary: #FFFBEA;
    --bg-secondary: #FFFFFF;
    --text-primary: #3E2723;
    --text-secondary: #8D6E63;
    --border-color: #FFE0B2;
    --card-bg: #FFFFFF;
    --card-border: #FFE0B2;
    --header-bg: #FFF3E0;
    --accent-primary: #FF8F00;
    --accent-primary-hover: #FF6F00;
    --accent-secondary: #FFD54F;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #FFE0B2;
    --user-bubble-text: #E65100;
    --ai-bubble-bg: #FFF3E0;
    --ai-bubble-text: #3E2723;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #FFE0B2;
    --sidebar-item-hover: #FFF3E0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #3E2723;
    --conversation-indicator: #FF8F00;
    --code-block-bg: #FFF3E0;
    --code-block-header-bg: #FFFBEA;
    --code-block-border: #FFE0B2;
}

/* Aurora Drift Theme: Dark Mode */
[data-theme="aurora-drift-dark"] {
    --bg-primary: #0A192F;
    --bg-secondary: #172A45;
    --text-primary: #E6F0FF;
    --text-secondary: #A0B3D6;
    --border-color: #2F476D;
    --card-bg: #172A45;
    --card-border: #2F476D;
    --header-bg: #0A192F;
    --accent-primary: #66CCCC;
    --accent-primary-hover: #55B3B3;
    --accent-secondary: #99CCFF;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #336699;
    --user-bubble-text: #E6F0FF;
    --ai-bubble-bg: #2F476D;
    --ai-bubble-text: #E6F0FF;
    --sidebar-bg: #0A192F;
    --sidebar-border: #2F476D;
    --sidebar-item-hover: #172A45;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(23, 42, 69, 0.9);
    --conversation-bg: rgba(23, 42, 69, 0.95);
    --conversation-text: #E6F0FF;
    --conversation-indicator: #66CCCC;
    --code-block-bg: #2F476D;
    --code-block-header-bg: #0A192F;
    --code-block-border: #2F476D;
}

/* Aurora Drift Theme: Light Mode */
[data-theme="aurora-drift-light"] {
    --bg-primary: #E0F2F7;
    --bg-secondary: #FFFFFF;
    --text-primary: #2B4550;
    --text-secondary: #5E7A8A;
    --border-color: #B2EBF2;
    --card-bg: #FFFFFF;
    --card-border: #B2EBF2;
    --header-bg: #CCEEF0;
    --accent-primary: #00BCD4;
    --accent-primary-hover: #00ACC1;
    --accent-secondary: #4DD0E1;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #B2EBF2;
    --user-bubble-text: #006064;
    --ai-bubble-bg: #CCEEF0;
    --ai-bubble-text: #2B4550;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #B2EBF2;
    --sidebar-item-hover: #CCEEF0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2B4550;
    --conversation-indicator: #00BCD4;
    --code-block-bg: #CCEEF0;
    --code-block-header-bg: #E0F2F7;
    --code-block-border: #B2EBF2;
}

/* Timeless Echo Theme: Dark Mode */
[data-theme="timeless-echo-dark"] {
    --bg-primary: #2C2C2C;
    --bg-secondary: #3D3D3D;
    --text-primary: #E0E0E0;
    --text-secondary: #B0B0B0;
    --border-color: #555555;
    --card-bg: #3D3D3D;
    --card-border: #555555;
    --header-bg: #2C2C2C;
    --accent-primary: #A57C52;
    --accent-primary-hover: #8B653D;
    --accent-secondary: #C8A87C;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #785A3D;
    --user-bubble-text: #E0E0E0;
    --ai-bubble-bg: #555555;
    --ai-bubble-text: #E0E0E0;
    --sidebar-bg: #2C2C2C;
    --sidebar-border: #555555;
    --sidebar-item-hover: #3D3D3D;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(61, 61, 61, 0.9);
    --conversation-bg: rgba(61, 61, 61, 0.95);
    --conversation-text: #E0E0E0;
    --conversation-indicator: #A57C52;
    --code-block-bg: #555555;
    --code-block-header-bg: #2C2C2C;
    --code-block-border: #555555;
}

/* Timeless Echo Theme: Light Mode */
[data-theme="timeless-echo-light"] {
    --bg-primary: #FDF7E5;
    --bg-secondary: #FFFFFF;
    --text-primary: #4A4A4A;
    --text-secondary: #808080;
    --border-color: #E6E0D3;
    --card-bg: #FFFFFF;
    --card-border: #E6E0D3;
    --header-bg: #F5EFEB;
    --accent-primary: #8D6E63;
    --accent-primary-hover: #795548;
    --accent-secondary: #BCAAA4;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #D7CCC8;
    --user-bubble-text: #5D4037;
    --ai-bubble-bg: #EFEBE9;
    --ai-bubble-text: #4A4A4A;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E6E0D3;
    --sidebar-item-hover: #F5EFEB;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #4A4A4A;
    --conversation-indicator: #8D6E63;
    --code-block-bg: #EFEBE9;
    --code-block-header-bg: #F5EFEB;
    --code-block-border: #E6E0D3;
}

/* Mystic Void Theme: Dark Mode */
[data-theme="mystic-void-dark"] {
    --bg-primary: #110B1D;
    --bg-secondary: #1F1731;
    --text-primary: #ECE4F7;
    --text-secondary: #B29BCE;
    --border-color: #372A4F;
    --card-bg: #1F1731;
    --card-border: #372A4F;
    --header-bg: #110B1D;
    --accent-primary: #9400D3;
    --accent-primary-hover: #7B00B0;
    --accent-secondary: #8A2BE2;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #5B2C7B;
    --user-bubble-text: #ECE4F7;
    --ai-bubble-bg: #372A4F;
    --ai-bubble-text: #ECE4F7;
    --sidebar-bg: #110B1D;
    --sidebar-border: #372A4F;
    --sidebar-item-hover: #1F1731;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(31, 23, 49, 0.9);
    --conversation-bg: rgba(31, 23, 49, 0.95);
    --conversation-text: #ECE4F7;
    --conversation-indicator: #9400D3;
    --code-block-bg: #372A4F;
    --code-block-header-bg: #110B1D;
    --code-block-border: #372A4F;
}

/* Mystic Void Theme: Light Mode */
[data-theme="mystic-void-light"] {
    --bg-primary: #F7EDFF;
    --bg-secondary: #FFFFFF;
    --text-primary: #330066;
    --text-secondary: #663399;
    --border-color: #EBD9FC;
    --card-bg: #FFFFFF;
    --card-border: #EBD9FC;
    --header-bg: #F2E0FF;
    --accent-primary: #8A2BE2;
    --accent-primary-hover: #7B1FB2;
    --accent-secondary: #9370DB;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #E6D2F2;
    --user-bubble-text: #4B0082;
    --ai-bubble-bg: #F0E6F8;
    --ai-bubble-text: #330066;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #EBD9FC;
    --sidebar-item-hover: #F2E0FF;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #330066;
    --conversation-indicator: #8A2BE2;
    --code-block-bg: #F0E6F8;
    --code-block-header-bg: #F2E0FF;
    --code-block-border: #EBD9FC;
}

/* Darkest Black & White Theme: Dark Mode */
[data-theme="darkest-bw-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #111111;
    --text-primary: #FFFFFF;
    --text-secondary: #AAAAAA;
    --border-color: #333333;
    --card-bg: #111111;
    --card-border: #333333;
    --header-bg: #0A0A0A;
    --accent-primary: #E0E0E0;
    --accent-primary-hover: #FFFFFF;
    --accent-secondary: #888888;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #222222;
    --user-bubble-text: #FFFFFF;
    --ai-bubble-bg: #333333;
    --ai-bubble-text: #FFFFFF;
    --sidebar-bg: #000000;
    --sidebar-border: #333333;
    --sidebar-item-hover: #111111;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: #000000;
    --conversation-bg: #000000;
    --conversation-text: #FFFFFF;
    --conversation-indicator: #FFFFFF;
    --code-block-bg: #333333;
    --code-block-header-bg: #0A0A0A;
    --code-block-border: #333333;
}

/* Darkest Black & White Theme: Light Mode */
[data-theme="darkest-bw-light"] {
    --bg-primary: #FFFFFF;
    --bg-secondary: #F0F0F0;
    --text-primary: #000000;
    --text-secondary: #555555;
    --border-color: #DDDDDD;
    --card-bg: #F0F0F0;
    --card-border: #DDDDDD;
    --header-bg: #F5F5F5;
    --accent-primary: #333333;
    --accent-primary-hover: #000000;
    --accent-secondary: #777777;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #EEEEEE;
    --user-bubble-text: #000000;
    --ai-bubble-bg: #DDDDDD;
    --ai-bubble-text: #000000;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #DDDDDD;
    --sidebar-item-hover: #F0F0F0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: #F0F0F0;
    --conversation-bg: #FFFFFF;
    --conversation-text: #000000;
    --conversation-indicator: #000000;
    --code-block-bg: #DDDDDD;
    --code-block-header-bg: #F5F5F5;
    --code-block-border: #DDDDDD;
}

/* Coder's Dark Theme */
[data-theme="coder-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #0A0A0A;
    --text-primary: #00BCD4;
    --text-secondary: #8B949E;
    --border-color: #30363D;
    --card-bg: #0A0A0A;
    --card-border: #30363D;
    --header-bg: #000000;
    --accent-primary: #00BCD4;
    --accent-primary-hover: #0097A7;
    --accent-secondary: #8A2BE2;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #2C3E50;
    --user-bubble-text: #E0E0E0;
    --ai-bubble-bg: #1A1A1A;
    --ai-bubble-text: #E0E0E0;
    --sidebar-bg: #000000;
    --sidebar-border: #30363D;
    --sidebar-item-hover: #0A0A0A;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #00BCD4;
    --conversation-indicator: #00BCD4;
    --code-block-bg: #1A1A1A;
    --code-block-header-bg: #27272A;
    --code-block-border: #3F3F46;
}

/* Coder's Light Theme */
[data-theme="coder-light"] {
    --bg-primary: #F0F2F5;
    --bg-secondary: #FFFFFF;
    --text-primary: #008C9D;
    --text-secondary: #718096;
    --border-color: #DDE2E8;
    --card-bg: #FFFFFF;
    --card-border: #DDE2E8;
    --header-bg: #E8EDF2;
    --accent-primary: #008C9D;
    --accent-primary-hover: #006D7D;
    --accent-secondary: #6A1B9A;
    --accent-error: #D32F2F;
    --accent-success: #388E3C;
    --user-bubble-bg: #E0F7FA;
    --user-bubble-text: #004D40;
    --ai-bubble-bg: #F0F4F8;
    --ai-bubble-text: #2C2C30;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #DDE2E8;
    --sidebar-item-hover: #F0F2F5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #004D40;
    --conversation-indicator: #008C9D;
    --code-block-bg: #F5F5F5;
    --code-block-header-bg: #ECEFF1;
    --code-block-border: #CFD8DC;
}

/* Cyberpunk Theme: Dark Mode (Existing, standardized) */
[data-theme="cyberpunk-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #1A0F24;
    --text-primary: #00FFFF;
    --text-secondary: #A08AB2;
    --border-color: #3A1D4D;
    --card-bg: #1A0F24;
    --card-border: #3A1D4D;
    --header-bg: #0A050F;
    --accent-primary: #00FFFF;
    --accent-primary-hover: #00CED1;
    --accent-secondary: #FF1493;
    --accent-error: #FF4500;
    --accent-success: #32CD32;
    --user-bubble-bg: #3A204D;
    --user-bubble-text: #E0E0E0;
    --ai-bubble-bg: #100814;
    --ai-bubble-text: #E0E0E0;
    --sidebar-bg: #000000;
    --sidebar-border: #3A1D4D;
    --sidebar-item-hover: #1A0F24;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(10, 5, 15, 0.9);
    --conversation-bg: rgba(10, 5, 15, 0.95);
    --conversation-text: #00FFFF;
    --conversation-indicator: #00FFFF;
    --code-block-bg: #100814;
    --code-block-header-bg: #20102A;
    --code-block-border: #3A1D4D;
}
[data-theme="cyberpunk-light"] {
    --bg-primary: #F0F8FF;
    --bg-secondary: #FFFFFF;
    --text-primary: #00CED1;
    --text-secondary: #6A5ACD;
    --border-color: #ADD8E6;
    --card-bg: #FFFFFF;
    --card-border: #ADD8E6;
    --header-bg: #E0F2F7;
    --accent-primary: #00CED1;
    --accent-primary-hover: #00BFFF;
    --accent-secondary: #FF69B4;
    --accent-error: #DC143C;
    --accent-success: #3CB371;
    --user-bubble-bg: #E0FFFF;
    --user-bubble-text: #2F4F4F;
    --ai-bubble-bg: #F0F8FF;
    --ai-bubble-text: #4169E1;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #ADD8E6;
    --sidebar-item-hover: #E0F2F7;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2F4F4F;
    --conversation-indicator: #00CED1;
    --code-block-bg: #E0FFFF;
    --code-block-header-bg: #ADD8E6;
    --code-block-border: #87CEEB;
}

/* Matrix Code Theme */
[data-theme="matrix-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #0A0A0A;
    --text-primary: #00FF00;
    --text-secondary: #008000;
    --border-color: #004000;
    --card-bg: #0A0A0A;
    --card-border: #004000;
    --header-bg: #000000;
    --accent-primary: #00FF00;
    --accent-primary-hover: #00CC00;
    --accent-secondary: #00FFFF;
    --accent-error: #FF0000;
    --accent-success: #00FF00;
    --user-bubble-bg: #001A00;
    --user-bubble-text: #00FF00;
    --ai-bubble-bg: #000500;
    --ai-bubble-text: #00FF00;
    --sidebar-bg: #000000;
    --sidebar-border: #004000;
    --sidebar-item-hover: #001500;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #00FF00;
    --conversation-indicator: #00FF00;
    --code-block-bg: #000A00;
    --code-block-header-bg: #001000;
    --code-block-border: #002000;
}
[data-theme="matrix-light"] {
    --bg-primary: #FFFFFF;
    --bg-secondary: #F0F0F0;
    --text-primary: #008000;
    --text-secondary: #404040;
    --border-color: #D0D0D0;
    --card-bg: #F0F0F0;
    --card-border: #D0D0D0;
    --header-bg: #E0E0E0;
    --accent-primary: #008000;
    --accent-primary-hover: #006000;
    --accent-secondary: #00AAAA;
    --accent-error: #CC0000;
    --accent-success: #00AA00;
    --user-bubble-bg: #E0FFE0;
    --user-bubble-text: #202020;
    --ai-bubble-bg: #F0FFF0;
    --ai-bubble-text: #303030;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #D0D0D0;
    --sidebar-item-hover: #E0E0E0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #202020;
    --conversation-indicator: #008000;
    --code-block-bg: #F5FFF5;
    --code-block-header-bg: #E0FFE0;
    --code-block-border: #C0D0C0;
}

/* Solarized Theme */
[data-theme="solarized-light"] {
    --bg-primary: #FDF6E3;
    --bg-secondary: #EEE8D5;
    --text-primary: #2AA198;
    --text-secondary: #657B83;
    --border-color: #93A1A1;
    --card-bg: #EEE8D5;
    --card-border: #93A1A1;
    --header-bg: #FDF6E3;
    --accent-primary: #2AA198;
    --accent-primary-hover: #268BD2;
    --accent-secondary: #DC322F;
    --accent-error: #DC322F;
    --accent-success: #859900;
    --user-bubble-bg: #839496;
    --user-bubble-text: #FDF6E3;
    --ai-bubble-bg: #E0E0D0;
    --ai-bubble-text: #586E75;
    --sidebar-bg: #FDF6E3;
    --sidebar-border: #93A1A1;
    --sidebar-item-hover: #EEE8D5;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #586E75;
    --conversation-indicator: #2AA198;
    --code-block-bg: #EEE8D5;
    --code-block-header-bg: #FDF6E3;
    --code-block-border: #D0D0C0;
}
[data-theme="solarized-dark"] {
    --bg-primary: #002B36;
    --bg-secondary: #073642;
    --text-primary: #2AA198;
    --text-secondary: #839496;
    --border-color: #586E75;
    --card-bg: #073642;
    --card-border: #586E75;
    --header-bg: #002B36;
    --accent-primary: #2AA198;
    --accent-primary-hover: #268BD2;
    --accent-secondary: #DC322F;
    --accent-error: #DC322F;
    --accent-success: #859900;
    --user-bubble-bg: #586E75;
    --user-bubble-text: #FDF6E3;
    --ai-bubble-bg: #073642;
    --ai-bubble-text: #93A1A1;
    --sidebar-bg: #002B36;
    --sidebar-border: #586E75;
    --sidebar-item-hover: #073642;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 43, 54, 0.9);
    --conversation-bg: rgba(0, 43, 54, 0.95);
    --conversation-text: #FDF6E3;
    --conversation-indicator: #2AA198;
    --code-block-bg: #073642;
    --code-block-header-bg: #002B36;
    --code-block-border: #586E75;
}

/* Dracula Theme */
[data-theme="dracula-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #282A36;
    --text-primary: #BD93F9;
    --text-secondary: #6272A4;
    --border-color: #44475A;
    --card-bg: #282A36;
    --card-border: #44475A;
    --header-bg: #000000;
    --accent-primary: #BD93F9;
    --accent-primary-hover: #FF79C6;
    --accent-secondary: #50FA7B;
    --accent-error: #FF5555;
    --accent-success: #50FA7B;
    --user-bubble-bg: #44475A;
    --user-bubble-text: #F8F8F2;
    --ai-bubble-bg: #1A1C25;
    --ai-bubble-text: #F8F8F2;
    --sidebar-bg: #000000;
    --sidebar-border: #44475A;
    --sidebar-item-hover: #282A36;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #F8F8F2;
    --conversation-indicator: #BD93F9;
    --code-block-bg: #1A1C25;
    --code-block-header-bg: #2F313E;
    --code-block-border: #44475A;
}
[data-theme="dracula-light"] {
    --bg-primary: #F8F8F2;
    --bg-secondary: #F0F0E0;
    --text-primary: #FF79C6;
    --text-secondary: #6272A4;
    --border-color: #CCDEF2;
    --card-bg: #F0F0E0;
    --card-border: #CCDEF2;
    --header-bg: #E8E8E0;
    --accent-primary: #FF79C6;
    --accent-primary-hover: #BD93F9;
    --accent-secondary: #50FA7B;
    --accent-error: #FF5555;
    --accent-success: #50FA7B;
    --user-bubble-bg: #CCDEF2;
    --user-bubble-text: #282A36;
    --ai-bubble-bg: #E8E8E0;
    --ai-bubble-text: #303240;
    --sidebar-bg: #F8F8F2;
    --sidebar-border: #CCDEF2;
    --sidebar-item-hover: #F0F0E0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #282A36;
    --conversation-indicator: #FF79C6;
    --code-block-bg: #E8E8E0;
    --code-block-header-bg: #D8D8D0;
    --code-block-border: #C2C2C0;
}

/* Monokai Pro Theme */
[data-theme="monokai-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #2D2A2E;
    --text-primary: #A6E22E;
    --text-secondary: #75715E;
    --border-color: #49483E;
    --card-bg: #2D2A2E;
    --card-border: #49483E;
    --header-bg: #000000;
    --accent-primary: #A6E22E;
    --accent-primary-hover: #E6DB74;
    --accent-secondary: #FD971F;
    --accent-error: #F92672;
    --accent-success: #A6E22E;
    --user-bubble-bg: #49483E;
    --user-bubble-text: #FCFCFA;
    --ai-bubble-bg: #1A1A1A;
    --ai-bubble-text: #FCFCFA;
    --sidebar-bg: #000000;
    --sidebar-border: #49483E;
    --sidebar-item-hover: #2D2A2E;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #FCFCFA;
    --conversation-indicator: #A6E22E;
    --code-block-bg: #1A1A1A;
    --code-block-header-bg: #27252A;
    --code-block-border: #3F3C38;
}
[data-theme="monokai-light"] {
    --bg-primary: #FCFCFA;
    --bg-secondary: #F5F5F0;
    --text-primary: #F92672;
    --text-secondary: #75715E;
    --border-color: #D0D0CB;
    --card-bg: #F5F5F0;
    --card-border: #D0D0CB;
    --header-bg: #EEEEEC;
    --accent-primary: #F92672;
    --accent-primary-hover: #A6E22E;
    --accent-secondary: #FD971F;
    --accent-error: #CC3333;
    --accent-success: #A6E22E;
    --user-bubble-bg: #E0E0D8;
    --user-bubble-text: #30302E;
    --ai-bubble-bg: #EEEEEC;
    --ai-bubble-text: #40403C;
    --sidebar-bg: #FCFCFA;
    --sidebar-border: #D0D0CB;
    --sidebar-item-hover: #F5F5F0;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #30302E;
    --conversation-indicator: #F92672;
    --code-block-bg: #EEEEEC;
    --code-block-header-bg: #E0E0D8;
    --code-block-border: #C0C0B8;
}

/* Nord Theme (Existing, standardized) */
[data-theme="nord-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #2E3440;
    --text-primary: #88C0D0;
    --text-secondary: #ECEFF4;
    --border-color: #4C566A;
    --card-bg: #2E3440;
    --card-border: #4C566A;
    --header-bg: #000000;
    --accent-primary: #88C0D0;
    --accent-primary-hover: #81A1C1;
    --accent-secondary: #B48EAD;
    --accent-error: #BF616A;
    --accent-success: #A3BE8C;
    --user-bubble-bg: #4C566A;
    --user-bubble-text: #D8DEE9;
    --ai-bubble-bg: #1A1D23;
    --ai-bubble-text: #D8DEE9;
    --sidebar-bg: #000000;
    --sidebar-border: #4C566A;
    --sidebar-item-hover: #2E3440;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #D8DEE9;
    --conversation-indicator: #88C0D0;
    --code-block-bg: #1A1D23;
    --code-block-header-bg: #242933;
    --code-block-border: #4C566A;
}
[data-theme="nord-light"] {
    --bg-primary: #ECEFF4;
    --bg-secondary: #D8DEE9;
    --text-primary: #5E81AC;
    --text-secondary: #4C566A;
    --border-color: #B4BFCD;
    --card-bg: #D8DEE9;
    --card-border: #B4BFCD;
    --header-bg: #DEE3EB;
    --accent-primary: #5E81AC;
    --accent-primary-hover: #81A1C1;
    --accent-secondary: #B48EAD;
    --accent-error: #BF616A;
    --accent-success: #A3BE8C;
    --user-bubble-bg: #AABECF;
    --user-bubble-text: #2E3440;
    --ai-bubble-bg: #DEE3EB;
    --ai-bubble-text: #3B4252;
    --sidebar-bg: #ECEFF4;
    --sidebar-border: #B4BFCD;
    --sidebar-item-hover: #D8DEE9;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #2E3440;
    --conversation-indicator: #5E81AC;
    --code-block-bg: #DEE3EB;
    --code-block-header-bg: #C0C7D1;
    --code-block-border: #B4BFCD;
}

/* Gruvbox Theme */
[data-theme="gruvbox-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #282828;
    --text-primary: #83A598;
    --text-secondary: #A89984;
    --border-color: #504945;
    --card-bg: #282828;
    --card-border: #504945;
    --header-bg: #000000;
    --accent-primary: #83A598;
    --accent-primary-hover: #B8BB26;
    --accent-secondary: #FABD2F;
    --accent-error: #FB4934;
    --accent-success: #B8BB26;
    --user-bubble-bg: #504945;
    --user-bubble-text: #EBDBB2;
    --ai-bubble-bg: #1D2021;
    --ai-bubble-text: #EBDBB2;
    --sidebar-bg: #000000;
    --sidebar-border: #504945;
    --sidebar-item-hover: #282828;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #EBDBB2;
    --conversation-indicator: #83A598;
    --code-block-bg: #1D2021;
    --code-block-header-bg: #32302F;
    --code-block-border: #504945;
}
[data-theme="gruvbox-light"] {
    --bg-primary: #FBF1C7;
    --bg-secondary: #FEF6E4;
    --text-primary: #427B58;
    --text-secondary: #7C6F64;
    --border-color: #BDAEAA;
    --card-bg: #FEF6E4;
    --card-border: #BDAEAA;
    --header-bg: #EBDBB2;
    --accent-primary: #427B58;
    --accent-primary-hover: #8EC07C;
    --accent-secondary: #D79921;
    --accent-error: #CC241D;
    --accent-success: #8EC07C;
    --user-bubble-bg: #D5C4A1;
    --user-bubble-text: #3C3836;
    --ai-bubble-bg: #EBDBB2;
    --ai-bubble-text: #504945;
    --sidebar-bg: #FBF1C7;
    --sidebar-border: #BDAEAA;
    --sidebar-item-hover: #EBDBB2;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #3C3836;
    --conversation-indicator: #427B58;
    --code-block-bg: #EBDBB2;
    --code-block-header-bg: #D5C4A1;
    --code-block-border: #BDAEAA;
}

/* Catppuccin Theme */
[data-theme="catppuccin-dark"] {
    --bg-primary: #000000;
    --bg-secondary: #24273A;
    --text-primary: #8BD5CA;
    --text-secondary: #A5ADCE;
    --border-color: #494D64;
    --card-bg: #24273A;
    --card-border: #494D64;
    --header-bg: #000000;
    --accent-primary: #8BD5CA;
    --accent-primary-hover: #B7BFEF;
    --accent-secondary: #F4B8E4;
    --accent-error: #ED8796;
    --accent-success: #A6DA95;
    --user-bubble-bg: #494D64;
    --user-bubble-text: #CAD3F5;
    --ai-bubble-bg: #1A1D2A;
    --ai-bubble-text: #CAD3F5;
    --sidebar-bg: #000000;
    --sidebar-border: #494D64;
    --sidebar-item-hover: #24273A;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(0, 0, 0, 0.9);
    --conversation-bg: rgba(0, 0, 0, 0.95);
    --conversation-text: #CAD3F5;
    --conversation-indicator: #8BD5CA;
    --code-block-bg: #1A1D2A;
    --code-block-header-bg: #2E3243;
    --code-block-border: #494D64;
}
[data-theme="catppuccin-light"] {
    --bg-primary: #EFF1F5;
    --bg-secondary: #E6E9EF;
    --text-primary: #179299;
    --text-secondary: #5C5F77;
    --border-color: #CBD0E1;
    --card-bg: #E6E9EF;
    --card-border: #CBD0E1;
    --header-bg: #EAECEF;
    --accent-primary: #179299;
    --accent-primary-hover: #7287FD;
    --accent-secondary: #EA76CB;
    --accent-error: #E64553;
    --accent-success: #40A02B;
    --user-bubble-bg: #CBD0E1;
    --user-bubble-text: #4C4F69;
    --ai-bubble-bg: #EAECEF;
    --ai-bubble-text: #626880;
    --sidebar-bg: #EFF1F5;
    --sidebar-border: #CBD0E1;
    --sidebar-item-hover: #E6E9EF;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.8);
    --conversation-bg: rgba(255, 255, 255, 0.95);
    --conversation-text: #4C4F69;
    --conversation-indicator: #179299;
    --code-block-bg: #EAECEF;
    --code-block-header-bg: #D4D7E2;
    --code-block-border: #C8CDDD;
}

/* Cosmic Nexus Theme: Dark Mode */
[data-theme="cosmic-nexus-dark"] {
    --bg-primary: #05050A;
    --bg-secondary: #101018;
    --text-primary: #E6E6E6;
    --text-secondary: #94A3B8;
    --border-color: #2A2A3A;
    --card-bg: #101018;
    --card-border: #2A2A3A;
    --header-bg: #0A0A10;
    --accent-primary: #00F5FF;
    --accent-primary-hover: #00CED1;
    --accent-secondary: #D400FF;
    --accent-error: #FF4500;
    --accent-success: #0AFF9D;
    --user-bubble-bg: #003344;
    --user-bubble-text: #E0FFFF;
    --ai-bubble-bg: #18052A;
    --ai-bubble-text: #E6E6E6;
    --sidebar-bg: #101018;
    --sidebar-border: #2A2A3A;
    --sidebar-item-hover: #1A1A22;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(16, 16, 24, 0.9);
    --conversation-bg: rgba(5, 5, 10, 0.95);
    --conversation-text: #E6E6E6;
    --conversation-indicator: #00F5FF;
    --code-block-bg: #18052A;
    --code-block-header-bg: #0A0A10;
    --code-block-border: #2A2A3A;
}

/* Cosmic Nexus Theme: Light Mode */
[data-theme="cosmic-nexus-light"] {
    --bg-primary: #F0F8FF;
    --bg-secondary: #FFFFFF;
    --text-primary: #1F2937;
    --text-secondary: #4B5563;
    --border-color: #E5E7EB;
    --card-bg: #FFFFFF;
    --card-border: #E5E7EB;
    --header-bg: #EAF0F8;
    --accent-primary: #00CED1;
    --accent-primary-hover: #00BFFF;
    --accent-secondary: #9370DB;
    --accent-error: #FF4500;
    --accent-success: #0AFF9D;
    --user-bubble-bg: #E0FFFF;
    --user-bubble-text: #004D40;
    --ai-bubble-bg: #F3F8FF;
    --ai-bubble-text: #2F4F4F;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E5E7EB;
    --sidebar-item-hover: #EAF0F8;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.85);
    --conversation-bg: rgba(255, 255, 255, 0.9);
    --conversation-text: #1F2937;
    --conversation-indicator: #00CED1;
    --code-block-bg: #F3F8FF;
    --code-block-header-bg: #EAF0F8;
    --code-block-border: #E5E7EB;
}

/* Starship Minimal Theme: Dark Mode */
[data-theme="starship-minimal-dark"] {
    --bg-primary: #0D1117;
    --bg-secondary: #161B22;
    --text-primary: #F0F6FC;
    --text-secondary: #8B949E;
    --border-color: #30363D;
    --card-bg: #161B22;
    --card-border: #30363D;
    --header-bg: #0D1117;
    --accent-primary: #2F81F7;
    --accent-primary-hover: #1C6EDD;
    --accent-secondary: #58A6FF;
    --accent-error: #F87171;
    --accent-success: #4ADE80;
    --user-bubble-bg: #1F385B;
    --user-bubble-text: #DBEAFE;
    --ai-bubble-bg: #21262D;
    --ai-bubble-text: #F0F6FC;
    --sidebar-bg: #161B22;
    --sidebar-border: #30363D;
    --sidebar-item-hover: #21262D;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(13, 17, 23, 0.9);
    --conversation-bg: rgba(13, 17, 23, 0.95);
    --conversation-text: #F0F6FC;
    --conversation-indicator: #2F81F7;
    --code-block-bg: #21262D;
    --code-block-header-bg: #161B22;
    --code-block-border: #30363D;
}

/* Starship Minimal Theme: Light Mode */
[data-theme="starship-minimal-light"] {
    --bg-primary: #F0F4F8;
    --bg-secondary: #FFFFFF;
    --text-primary: #2D3748;
    --text-secondary: #718096;
    --border-color: #E2E8F0;
    --card-bg: #FFFFFF;
    --card-border: #E2E8F0;
    --header-bg: #EDF2F7;
    --accent-primary: #1E90FF;
    --accent-primary-hover: #107EEB;
    --accent-secondary: #63B2FF;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #DBEAFE;
    --user-bubble-text: #1E40AF;
    --ai-bubble-bg: #F3F8FF;
    --ai-bubble-text: #2D3748;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E2E8F0;
    --sidebar-item-hover: #F0F4F8;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.85);
    --conversation-bg: rgba(255, 255, 255, 0.9);
    --conversation-text: #2D3748;
    --conversation-indicator: #1E90FF;
    --code-block-bg: #F3F8FF;
    --code-block-header-bg: #EDF2F7;
    --code-block-border: #E2E8F0;
}

/* Offbeat Cosmic Pastels Theme: Dark Mode */
[data-theme="offbeat-cosmic-dark"] {
    --bg-primary: #0C0F16;
    --bg-secondary: #1A1E2B;
    --text-primary: #FDFDFD;
    --text-secondary: #A0A5B5;
    --border-color: #30354F;
    --card-bg: #1A1E2B;
    --card-border: #30354F;
    --header-bg: #0C0F16;
    --accent-primary: #5CE1E6;
    --accent-primary-hover: #45CCD1;
    --accent-secondary: #C780FF;
    --accent-error: #FF6347;
    --accent-success: #7FFF00;
    --user-bubble-bg: #3A2B5B;
    --user-bubble-text: #E0E0E0;
    --ai-bubble-bg: #2B1E40;
    --ai-bubble-text: #FDFDFD;
    --sidebar-bg: #1A1E2B;
    --sidebar-border: #30354F;
    --sidebar-item-hover: #212535;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(12, 15, 22, 0.9);
    --conversation-bg: rgba(12, 15, 22, 0.95);
    --conversation-text: #FDFDFD;
    --conversation-indicator: #5CE1E6;
    --code-block-bg: #2B1E40;
    --code-block-header-bg: #1A1E2B;
    --code-block-border: #30354F;
}

/* Offbeat Cosmic Pastels Theme: Light Mode */
[data-theme="offbeat-cosmic-light"] {
    --bg-primary: #F9FDFD;
    --bg-secondary: #FFFFFF;
    --text-primary: #2D3748;
    --text-secondary: #718096;
    --border-color: #E2E8F0;
    --card-bg: #FFFFFF;
    --card-border: #E2E8F0;
    --header-bg: #EEF8F8;
    --accent-primary: #00BCD4;
    --accent-primary-hover: #00ACC1;
    --accent-secondary: #A078E0;
    --accent-error: #EF4444;
    --accent-success: #22C55E;
    --user-bubble-bg: #DBFEFF;
    --user-bubble-text: #004D40;
    --ai-bubble-bg: #E0FFFF;
    --ai-bubble-text: #2D3748;
    --sidebar-bg: #FFFFFF;
    --sidebar-border: #E2E8F0;
    --sidebar-item-hover: #EEF8F8;
    --loader-dot-color: var(--accent-primary);
    --main-chat-window-bg: rgba(255, 255, 255, 0.85);
    --conversation-bg: rgba(255, 255, 255, 0.9);
    --conversation-text: #2D3748;
    --conversation-indicator: #00BCD4;
    --code-block-bg: #E0FFFF;
    --code-block-header-bg: #EEF8F8;
    --code-block-border: #E2E8F0;
}

/* --- MERGED THEMES FROM PART 2 END --- */

/* --- Base Application Styles --- */
body {
  background: var(--bg-primary); 
  color: var(--text-primary);
  font-family: 'Inter', Arial, Helvetica, sans-serif;
  height: 100vh;
  overflow: hidden;
  transition: background-color 0.6s ease, color 0.6s ease;
}

/* Custom scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-thumb {
  background: color-mix(in srgb, var(--accent-primary) 50%, transparent); 
  border-radius: 4px;
}
::-webkit-scrollbar-track {
  background: var(--bg-primary);
}

/* Markdown and Code Styling Overrides */

/* Code block container */
.message-content pre {
    /* Ensure no padding on the PRE itself, the padding goes on the CODE element */
    background-color: var(--code-block-bg) !important;
    border: 1px solid var(--code-block-border) !important;
    border-radius: 0.5rem !important;
    margin-top: 1rem !important;
    margin-bottom: 1rem !important;
    padding: 0 !important; 
    overflow-x: auto; /* FIX: Enable horizontal scroll */
}

/* Code block header */
.code-block-header {
    background-color: var(--code-block-header-bg);
    color: var(--text-secondary);
    padding: 0.5rem 1rem;
    border-bottom: 1px solid var(--code-block-border);
    font-size: 0.85em;
    border-top-left-radius: 0.5rem;
    border-top-right-radius: 0.5rem;
}

/* Code content inside pre */
.message-content pre code {
    color: var(--text-primary);
    display: block;
    padding: 1rem !important; /* Padding for the code content */
    background: none !important;
}

/* Inline code */
.message-content code:not(pre > code) {
    background-color: color-mix(in srgb, var(--accent-primary) 15%, transparent) !important;
    border-radius: 0.25rem;
    padding: 0.2em 0.4em;
    font-size: 0.9em;
    color: var(--accent-primary) !important;
}

/* Styling for button when Speech Recognition is active */
.voice-input-active {
    background-color: var(--accent-error) !important;
    animation: pulse-red 1s infinite cubic-bezier(0.4, 0, 0.6, 1);
}
@keyframes pulse-red {
    0%, 100% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--accent-error) 70%, transparent); }
    50% { box-shadow: 0 0 0 10px color-mix(in srgb, var(--accent-error) 0%, transparent); }
}

/* User Bubble Styles (Ensure they use the variables) */
.chat-message.user {
    background-color: var(--user-bubble-bg);
    color: var(--user-bubble-text);
}

/* AI Bubble Styles (Ensure they use the variables) */
.chat-message.model {
    background-color: var(--ai-bubble-bg);
    color: var(--ai-bubble-text);
    border: 1px solid var(--border-color);
}

--- END FILE: app\globals.css ---

--- START FILE: app\layout.tsx ---

// app/layout.tsx
import type { Metadata } from "next";
import "./globals.css";
import { AuthProvider } from '@/components/providers/AuthProvider';
import { ThemeProvider } from '@/components/providers/ThemeContext'; // NEW IMPORT


export const metadata: Metadata = {
  title: "Big AI Chatbot (Production)",
  description: "A large scale Gemini chat application.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // Theme is applied via CSS variables and the ThemeProvider context
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={`antialiased`}> 
        <AuthProvider>
          <ThemeProvider> {/* Wrap children with ThemeProvider */}
            {children}
          </ThemeProvider>
        </AuthProvider>
      </body>
    </html>
  );
}

--- END FILE: app\layout.tsx ---

--- START FILE: app\page.tsx ---

// app/page.tsx
'use client';

import { useState } from 'react';
import ChatArea from '@/components/ChatArea';
import Sidebar from '@/components/Sidebar';
import { useAuth } from '@/components/providers/AuthProvider';
import AuthGate from '@/components/ui/AuthGate';
import ConversationModeOverlay from '@/components/ConversationModeOverlay'; // NEW IMPORT
import { useTheme } from '@/components/providers/ThemeContext'; // NEW IMPORT

export default function HomePage() {
  const { user, loading: authLoading } = useAuth();
  const { loadingSettings } = useTheme(); // Wait for settings/theme to load
  
  const [currentChatId, setCurrentChatId] = useState<string | undefined>(undefined);
  const [refreshSidebarToggle, setRefreshSidebarToggle] = useState(false);
  
  // NEW STATE: Conversation Mode
  const [isConversationModeOpen, setIsConversationModeOpen] = useState(false);

  const handleSelectChat = (chatId: string | undefined) => {
    setCurrentChatId(chatId);
    // If conversation mode is open, close it upon switching chats
    if (isConversationModeOpen) setIsConversationModeOpen(false);
  };
  
  const handleNewMessageSent = () => {
    // Toggle state to force Sidebar to re-fetch history
    setRefreshSidebarToggle(prev => !prev);
  }

  // Show loading state if authentication or settings/theme is in progress
  if (authLoading || loadingSettings) {
    return <div className="flex h-screen items-center justify-center text-xl" style={{color: 'var(--text-primary)'}}>Loading application...</div>
  }

  // Show AuthGate if user is not logged in
  if (!user) {
    return <AuthGate />;
  }

  // Main application view
  return (
    <div className="flex h-screen" style={{ backgroundColor: 'var(--bg-primary)' }}>
      {/* 1. Sidebar */}
      <Sidebar 
        onSelectChat={handleSelectChat} 
        currentChatId={currentChatId}
        onNewMessageSent={handleNewMessageSent} // Allow sidebar to trigger refresh from settings panel saves
        onOpenConversationMode={() => setIsConversationModeOpen(true)} // Pass handler
        key={refreshSidebarToggle.toString()} // Force remount/refresh when a new message is sent
      />
      
      {/* 2. Main Chat Area */}
      <main className="flex-1 flex flex-col">
        <ChatArea 
          chatId={currentChatId}
          onChatIdChange={setCurrentChatId}
          onNewMessageSent={handleNewMessageSent}
          onOpenConversationMode={() => setIsConversationModeOpen(true)} // Pass handler
        />
      </main>
      
      {/* 3. Conversation Mode Overlay */}
      {isConversationModeOpen && (
        <ConversationModeOverlay
          chatId={currentChatId}
          onChatIdChange={setCurrentChatId}
          onClose={() => setIsConversationModeOpen(false)}
          onNewMessageSent={handleNewMessageSent}
        />
      )}
    </div>
  );
}

--- END FILE: app\page.tsx ---

--- START FILE: app\api\chat\route.ts ---

// app/api/chat/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { generateStreamingResponse } from '@/lib/gemini';
import { getConversation, createConversation, updateConversation, deleteConversation } from '@/lib/history';
import { getSettings } from '@/lib/settings';
import { ChatMessage, Conversation, FileAttachment } from '@/types/chat';
import { getAuthId } from '@/lib/firebaseAdmin';

export const runtime = 'nodejs'; 

interface ChatRequest {
    chatId?: string; 
    message: string;
    files?: FileAttachment[];
}

// --- GET: Load existing conversation history ---
export async function GET(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }

    try {
        const { searchParams } = new URL(req.url);
        const chatId = searchParams.get('chatId');

        if (!chatId) {
            return NextResponse.json({ error: 'chatId is required' }, { status: 400 });
        }

        // Use userId in getConversation for authorization check
        const conversation = await getConversation(chatId, userId);

        if (!conversation) {
             return NextResponse.json({ error: 'Conversation not found or unauthorized' }, { status: 404 });
        }

        return NextResponse.json(conversation);

    } catch (error) {
        console.error('API GET Error:', error);
        return NextResponse.json({ error: 'Failed to retrieve chat history' }, { status: 500 });
    }
}

// --- DELETE: Delete a specific conversation ---
export async function DELETE(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }
    
    try {
        const { searchParams } = new URL(req.url);
        const chatId = searchParams.get('chatId');

        if (!chatId) {
            return NextResponse.json({ error: 'chatId is required' }, { status: 400 });
        }
        
        await deleteConversation(chatId, userId);
        
        return NextResponse.json({ message: `Conversation ${chatId} deleted successfully` });

    } catch (error) {
        console.error('API DELETE Error:', error);
        if (error instanceof Error && error.message.includes('Unauthorized')) {
             return NextResponse.json({ error: 'Unauthorized or conversation not found' }, { status: 403 });
        }
        return NextResponse.json({ error: 'Failed to delete chat history' }, { status: 500 });
    }
}


// --- POST: Handle new message/streaming ---
export async function POST(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }

  try {
    const { message, chatId: incomingChatId, files = [] }: ChatRequest = await req.json();

    if (!message || message.trim() === '') {
        // Allow empty text if files are present (e.g., "Analyze this image")
        if (files.length === 0) {
            return NextResponse.json({ error: 'Message cannot be empty.' }, { status: 400 });
        }
    }

    let conversation: Conversation | null = null;
    let chatId = incomingChatId;
    let isFirstExchange = false;

    if (chatId) {
        conversation = await getConversation(chatId, userId);
        if (!conversation) {
            return NextResponse.json({ error: 'Conversation not found or unauthorized.' }, { status: 404 });
        }
    } else {
        // NEW: Fetch global settings for model and system prompt
        const userSettings = await getSettings(userId);
        
        // NEW: Create conversation with global settings context
        conversation = await createConversation(
            userId, 
            message, 
            files,
            userSettings.globalModel, // Pass global model
            userSettings.globalSystemPrompt // Pass global system prompt
        );
        chatId = conversation.id;
        isFirstExchange = true;
    }

    // 1. Prepare history and current prompt (including files)
    const history: ChatMessage[] = conversation?.messages || [];
    
    // The current exchange (user message + files) is added to the history context for Gemini
    const userMessageForContext: ChatMessage = { 
        id: 'temp', 
        text: message, 
        role: 'user', 
        timestamp: Date.now(),
        files: files.length > 0 ? files : undefined,
    } as ChatMessage;

    const fullHistoryContext: ChatMessage[] = [
        ...history,
        userMessageForContext
    ];
    
    // Optional: Pass system prompt from conversation settings
    const systemInstruction = conversation?.systemPrompt;

    // 2. Generate the streaming response
    const stream = await generateStreamingResponse(
        fullHistoryContext,
        systemInstruction
    );
    
    // 3. Read the entire stream response to save it to the database
    let fullBotResponse = '';
    
    // Use .tee() to create two identical streams: one for the client, one for history saving
    const [clientStream, historyStream] = stream.tee();
    
    const reader = historyStream.getReader();
    const decoder = new TextDecoder();
    
    // Asynchronously save history
    (async () => {
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                fullBotResponse += decoder.decode(value);
            }
            
            // 4. Persist the full exchange asynchronously
            if (chatId) {
                await updateConversation(chatId, message, fullBotResponse, userId, files, isFirstExchange);
            }
        } catch (dbError) {
            console.error('CRITICAL: Error saving history to Firestore:', dbError);
        }
    })();
    
    // 5. Send the streaming response back to the client immediately
    const response = new NextResponse(clientStream, {
        headers: {
            'Content-Type': 'text/plain',
            'X-Chat-ID': chatId,
        },
        status: 200,
    });
    
    return response;

  } catch (error) {
    console.error('FATAL API Error:', error);
    return NextResponse.json({ error: 'Failed to process chat request.' }, { status: 500 });
  }
}

--- END FILE: app\api\chat\route.ts ---

--- START FILE: app\api\chats\route.ts ---

// app/api/chats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { db, getAuthId } from '@/lib/firebaseAdmin';
import { Conversation } from '@/types/chat';
import { deleteAllUserConversations } from '@/lib/history'; // Server-side import

export const runtime = 'nodejs';

/**
 * Fetches a list of recent conversations for the current user.
 */
export async function GET(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }
    
    try {
        const snapshot = await db.collection('conversations')
            .where('userId', '==', userId) // Use real User ID
            .orderBy('updatedAt', 'desc')
            .limit(20) // Limit to 20 recent chats
            .get();

        const chats = snapshot.docs.map(doc => {
            const data = doc.data() as Conversation;
            
            // Return only necessary data for the sidebar
            return {
                id: data.id,
                title: data.title,
                updatedAt: data.updatedAt,
            };
        });

        return NextResponse.json(chats);

    } catch (error) {
        console.error('Error fetching chat list:', error);
        return NextResponse.json({ error: 'Failed to retrieve conversation list' }, { status: 500 });
    }
}

/**
 * Deletes all conversations for the current user.
 */
export async function DELETE(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized: Missing Authentication' }, { status: 401 });
    }
    
    try {
        await deleteAllUserConversations(userId);
        return NextResponse.json({ message: 'All conversations deleted successfully' });

    } catch (error) {
        console.error('Error deleting chat list:', error);
        return NextResponse.json({ error: 'Failed to delete conversations' }, { status: 500 });
    }
}

--- END FILE: app\api\chats\route.ts ---

--- START FILE: app\api\settings\route.ts ---

// app/api/settings/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getAuthId } from '@/lib/firebaseAdmin';
import { getSettings, saveSettings } from '@/lib/settings';
import { UserSettings, PromptTemplate } from '@/types/chat';

export const runtime = 'nodejs';

// --- GET: Load user settings ---
export async function GET(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    try {
        const settings = await getSettings(userId);
        // Ensure sensitive info (API Key) is only returned if explicitly requested or handled carefully.
        // For simplicity, we return the full settings object here as it's authenticated.
        return NextResponse.json(settings);
    } catch (error) {
        console.error('API GET Settings Error:', error);
        return NextResponse.json({ error: 'Failed to retrieve settings' }, { status: 500 });
    }
}

// --- POST: Save user settings ---
export async function POST(req: NextRequest) {
    const userId = await getAuthId(req);
    if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    try {
        const body: Partial<UserSettings> = await req.json();
        
        // Use the saveSettings logic from lib/settings, which handles merging
        await saveSettings(userId, body);

        return NextResponse.json({ message: 'Settings saved successfully' });
    } catch (error) {
        console.error('API POST Settings Error:', error);
        return NextResponse.json({ error: 'Failed to save settings' }, { status: 500 });
    }
}

--- END FILE: app\api\settings\route.ts ---

--- START FILE: components\ChatArea.tsx ---

// components/ChatArea.tsx
'use client';

import React, { useState, useCallback, useEffect, useRef, ChangeEvent, DragEvent as ReactDragEvent, KeyboardEvent } from 'react';
import { ChatMessage, Conversation, FileAttachment } from '@/types/chat';
import ChatBubble from './ChatBubble'; 
import { useAuth } from '@/components/providers/AuthProvider';
import { v4 as uuidvv4 } from 'uuid';
import { useTheme } from '@/components/providers/ThemeContext'; // NEW
import useSpeechRecognition from '@/hooks/useSpeechRecognition'; // NEW HOOK (to be created)

const BOT_PENDING_ID = 'bot-pending';

interface ChatAreaProps {
    chatId: string | undefined;
    onChatIdChange: (newChatId: string) => void;
    onNewMessageSent: () => void; // Trigger sidebar refresh
    onOpenConversationMode: () => void; // NEW
}

// Utility to convert file to Base64
const fileToBase64 = (file: File): Promise<FileAttachment> => {
    // ... (utility function remains the same as in part 1)
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
            const result = reader.result as string;
            const [, base64Data] = result.split(',');
            if (base64Data) {
                resolve({
                    base64Data: base64Data,
                    mimeType: file.type,
                    filename: file.name,
                    size: file.size,
                });
            } else {
                reject(new Error("Failed to read file data."));
            }
        };
        reader.onerror = (error) => reject(error);
    });
};


export default function ChatArea({ chatId, onChatIdChange, onNewMessageSent, onOpenConversationMode }: ChatAreaProps) {
  const { user, getIdToken } = useAuth();
  const { settings } = useTheme();
  
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isHistoryLoading, setIsHistoryLoading] = useState(false);
  const [attachments, setAttachments] = useState<File[]>([]); 
  
  const chatEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  // NEW: Speech Recognition Hook Integration
  const { isListening, transcript, startListening, stopListening, recognitionSupported, resetTranscript } = useSpeechRecognition({ 
      onFinalTranscript: (finalTranscript) => {
          setInput(prev => (prev.trim() + ' ' + finalTranscript).trim());
          resetTranscript();
      },
      onInterimTranscript: (interimTranscript) => {
        // Use interim transcript for instant visual feedback
        setInput(prev => (prev.split(' ')[0] + ' ' + interimTranscript).trim());
      },
      onStart: () => {
          // Temporarily disable sending when listening starts
          // We rely on the input state being updated by the hook
      },
      onEnd: () => {
         // Focus on input after listening stops
         inputRef.current?.focus();
      }
  });


  // Combine hook transcript with input state
  useEffect(() => {
    // If listening and transcript changes, we don't update input directly here, 
    // the hook manages it via onFinalTranscript and onInterimTranscript handlers provided above.
    // We update the placeholder dynamically based on listening state.
    if (inputRef.current) {
        inputRef.current.placeholder = isLoading 
            ? "Please wait..." 
            : (isListening 
                ? "Listening... Speak now." 
                : (attachments.length > 0 ? `Message Big AI about ${attachments.length} files...` : "Message Big AI..."));
    }
  }, [isLoading, isListening, attachments.length]);
  
  // Dynamic Input Height Adjustment 
  useEffect(() => {
    const textarea = inputRef.current;
    if (textarea) {
      textarea.style.height = 'auto'; 
      textarea.style.height = `${textarea.scrollHeight}px`;
    }
  }, [input]);


  // --- History Loading Effect ---
  useEffect(() => {
    // ... (History loading logic remains the same, using settings data for potential conversation config is done in the API route)
    if (!user) return;

    if (chatId) {
      setIsHistoryLoading(true);
      setMessages([]); // Clear old messages
      
      const fetchChatHistory = async () => {
        try {
          const token = await getIdToken();
          const response = await fetch(`/api/chat?chatId=${chatId}`, {
              headers: { 'Authorization': `Bearer ${token}` }
          });
          
          if (response.ok) {
            const conversation: Conversation = await response.json();
            const clientMessages: ChatMessage[] = conversation.messages.map(m => ({
                ...m,
                timestamp: new Date(m.timestamp),
            }));
            setMessages(clientMessages);
          } else {
            console.error("Failed to load conversation:", chatId);
            setMessages([{ id: uuidvv4(), text: 'Failed to load conversation history. Check console for details.', role: 'model', timestamp: new Date() } as ChatMessage]);
          }
        } catch (error) {
          console.error("Error fetching chat history:", error);
        } finally {
          setIsHistoryLoading(false);
        }
      };
      fetchChatHistory();
    } else {
      // New chat state
      setMessages([]);
      setAttachments([]); 
      setIsHistoryLoading(false);
    }
  }, [chatId, user, getIdToken]);

  // --- Utility Functions ---
  const addMessage = useCallback((msg: ChatMessage) => {
    setMessages((prev) => [...prev, msg]);
  }, []);

  const updateBotStreamingMessage = useCallback((text: string) => {
    setMessages((prev) => {
      const lastMessage = prev[prev.length - 1];
      if (lastMessage && lastMessage.id === BOT_PENDING_ID) {
        return [
          ...prev.slice(0, -1),
          { ...lastMessage, text: lastMessage.text + text },
        ];
      }
      return [...prev, { id: BOT_PENDING_ID, text, role: 'model', timestamp: new Date() } as ChatMessage];
    });
  }, []);

  const finalizeBotMessage = useCallback((finalText: string) => {
    setMessages((prev) => {
      const finalIndex = prev.findIndex(m => m.id === BOT_PENDING_ID);
      if (finalIndex !== -1) {
        const finalBotMessage: ChatMessage = {
            id: uuidvv4(), 
            text: finalText,
            role: 'model',
            timestamp: new Date(),
          };
        return [...prev.slice(0, finalIndex), finalBotMessage];
      }
      return prev;
    });
    onNewMessageSent(); // Notify parent to refresh sidebar
  }, [onNewMessageSent]);

  // --- Input and UI Handlers ---
  
  const handleKeyPress = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      // Stop listening if Enter is pressed
      if (isListening) stopListening();
      handleSendMessage(e as unknown as React.FormEvent);
    }
  };

  type FileEvent = ChangeEvent<HTMLInputElement> | ReactDragEvent<HTMLDivElement> | React.ClipboardEvent<HTMLTextAreaElement>;
  
  const handleFileSelect = (e: FileEvent) => {
      // ... (file selection logic remains the same as in part 1)
      const selectedFiles: File[] = [];
  
      if ('clipboardData' in e) {
          if (e.clipboardData?.files) {
              selectedFiles.push(...Array.from(e.clipboardData.files));
          }
      } else if ('dataTransfer' in e) { // ReactDragEvent<HTMLDivElement>
          if (e.dataTransfer?.files) {
              selectedFiles.push(...Array.from(e.dataTransfer.files));
          }
      } else if ('target' in e && (e.target as HTMLInputElement).files) { // ChangeEvent<HTMLInputElement>
          const target = e.target as HTMLInputElement;
          if (target.files) {
              selectedFiles.push(...Array.from(target.files));
          }
      }
      
      const validFiles: File[] = selectedFiles.filter((file) => 
        (file.type.startsWith('image/') || file.type === 'application/pdf' || file.type.startsWith('text/') || file.type.startsWith('audio/') || file.type.startsWith('video/')) && file.size < 20 * 1024 * 1024 // 20MB limit
      );
  
      if (validFiles.length > 0) {
        setAttachments(prev => [...prev, ...validFiles]);
      }
  };

  const removeAttachment = (index: number) => {
    setAttachments(prev => prev.filter((_, i) => i !== index));
  };
  
  const handleVoiceInputToggle = () => {
      if (isLoading || isHistoryLoading) return;
      if (isListening) {
          stopListening();
      } else {
          // Clear current text if no attachments exist, otherwise append
          if (attachments.length === 0) {
              setInput('');
          }
          startListening(input);
      }
  };


  // --- Main Send Handler ---

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (isListening) stopListening();
    
    const trimmedInput = input.trim();
    
    if ((!trimmedInput && attachments.length === 0) || isLoading || isHistoryLoading) return;

    // 1. Convert attachments to Base64 payload
    const base64Attachments: FileAttachment[] = await Promise.all(
        attachments.map(file => fileToBase64(file))
    );
    
    // Check if the user's current settings include a system prompt to be passed to the API
    const globalSystemPrompt = settings?.globalSystemPrompt;
    
    const userMessage: ChatMessage = {
      id: uuidvv4(),
      text: trimmedInput,
      role: 'user',
      timestamp: new Date(),
      files: base64Attachments.length > 0 ? base64Attachments : undefined,
    };

    addMessage(userMessage);
    addMessage({ 
        id: BOT_PENDING_ID, 
        text: '...', 
        role: 'model', 
        timestamp: new Date() 
    } as ChatMessage);
    
    setInput('');
    setAttachments([]); 
    setIsLoading(true);

    try {
      const token = await getIdToken();
      
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`, 
        },
        body: JSON.stringify({
          message: trimmedInput,
          chatId: chatId, 
          files: base64Attachments, 
          // Pass the system prompt if this is a NEW chat (API route will use it if chatId is missing)
          globalSystemPrompt: chatId ? undefined : globalSystemPrompt, 
        }),
      });

      if (response.status === 401) {
          finalizeBotMessage('Session expired. Please log out and log back in.');
          return;
      }
      if (!response.ok || !response.body) {
        // Attempt to read error body if available
        let errorMsg = 'Sorry, Big AI ran into an internal error.';
        try {
            const errorData = await response.json();
            errorMsg = errorData.error || errorMsg;
        } catch {}
        finalizeBotMessage(errorMsg);
        return; 
      }
      
      const newChatId = response.headers.get('X-Chat-ID');
      if (newChatId && newChatId !== chatId) {
          onChatIdChange(newChatId); 
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let accumulatedText = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        accumulatedText += chunk;
        updateBotStreamingMessage(chunk); 
      }

      finalizeBotMessage(accumulatedText);

    } catch (error) {
      console.error('Error fetching AI response:', error);
      finalizeBotMessage('Sorry, Big AI ran into a communication error.');
    } finally {
      setIsLoading(false);
    }
  };
  
  // Scroll Anchor Effect
  useEffect(() => {
    if (!isHistoryLoading) {
        chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages, isHistoryLoading]);

  // --- Render ---

  if (isHistoryLoading) {
    return (
        <div className="flex flex-col h-full items-center justify-center" style={{backgroundColor: 'var(--bg-primary)', color: 'var(--text-secondary)'}}>
            <svg className="animate-spin h-8 w-8" style={{color: 'var(--accent-primary)'}} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <p className="mt-4">Loading conversation...</p>
        </div>
    );
  }

  return (
    <div className="flex flex-col h-full w-full" style={{backgroundColor: 'var(--bg-primary)'}}>
      <header className="p-4 border-b shadow-sm flex justify-between items-center" style={{backgroundColor: 'var(--header-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}>
        <h1 className="font-semibold truncate max-w-[calc(100%-80px)]">
            {chatId ? messages[0]?.text.substring(0, 50) + '...' : 'New Conversation'}
        </h1>
        {/* NEW: Conversation Mode Button in Header */}
        <button
            onClick={onOpenConversationMode}
            className="p-2 rounded-lg transition"
            title="Start Conversation Mode (Voice Chat)"
            disabled={isLoading || isHistoryLoading}
            style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-primary)', border: '1px solid var(--border-color)'}}
        >
             <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
        </button>
      </header>
      
      {/* Chat Messages Display */}
      <div 
        className="flex-1 overflow-y-auto p-4 space-y-6"
        style={{backgroundColor: 'var(--bg-primary)'}}
        onDrop={(e) => { e.preventDefault(); handleFileSelect(e); }}
        onDragOver={(e) => { e.preventDefault(); e.currentTarget.style.boxShadow = `0 0 10px var(--accent-primary)`; }}
        onDragLeave={(e) => { e.preventDefault(); e.currentTarget.style.boxShadow = 'none'; }}
      >
        {messages.length === 0 && (
            <div className='flex flex-col items-center justify-center h-full text-gray-500' style={{color: 'var(--text-secondary)'}}>
                <h1 className='text-3xl font-bold mb-4' style={{color: 'var(--accent-primary)'}}>Big AI</h1>
                <p>Start a new conversation or drag files here!</p>
            </div>
        )}
        {messages.map((msg, index) => (
          <ChatBubble 
            key={msg.id + index} 
            message={msg} 
            isPending={msg.id === BOT_PENDING_ID} 
          />
        ))}
        {/* Scroll Anchor */}
        <div ref={chatEndRef} />
      </div>

      {/* Input Form Area */}
      <div className="p-4 border-t flex flex-col items-center" style={{backgroundColor: 'var(--header-bg)', borderColor: 'var(--border-color)'}}>
        
        {/* File Preview Area */}
        {attachments.length > 0 && (
            <div className='w-full max-w-2xl mb-3 flex flex-wrap gap-2 p-3 border rounded-lg' style={{borderColor: 'var(--border-color)', backgroundColor: 'var(--bg-secondary)'}}>
                {attachments.map((file, index) => (
                    <div key={index} className='relative flex items-center p-2 rounded-md text-sm' style={{backgroundColor: 'var(--ai-bubble-bg)', color: 'var(--text-primary)'}}>
                        <span className='truncate max-w-[150px]'>{file.name}</span>
                        <button 
                            type="button" 
                            onClick={() => removeAttachment(index)} 
                            className='ml-2 text-red-500 hover:text-red-700'
                        >
                            &times;
                        </button>
                    </div>
                ))}
            </div>
        )}


        <form onSubmit={handleSendMessage} className="flex w-full max-w-2xl border rounded-xl shadow-lg" style={{borderColor: 'var(--border-color)', backgroundColor: 'var(--card-bg)'}}>
            
            {/* Voice Input Button */}
            {recognitionSupported && (
                <button
                    type="button"
                    onClick={handleVoiceInputToggle}
                    className={`p-3 transition flex items-center justify-center shrink-0 ${isListening ? 'voice-input-active' : ''}`}
                    title={isListening ? "Stop Listening" : "Start Voice Input (STT)"}
                    disabled={isLoading || isHistoryLoading}
                    style={{color: isListening ? 'white' : 'var(--text-secondary)', borderRadius: '0.75rem 0 0 0.75rem'}}
                >
                    <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 11a7 7 0 01-7 7v0a7 7 0 01-7-7v0a7 7 0 0114 0zM12 18v3m4 0H8m6-12a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                </button>
            )}

            {/* File Upload Button */}
            <label htmlFor="file-upload" className="p-3 text-gray-500 hover:text-blue-500 cursor-pointer flex items-center justify-center shrink-0" style={{color: 'var(--text-secondary)', borderLeft: recognitionSupported ? '1px solid var(--border-color)' : 'none'}}>
                <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13.5"></path></svg>
                <input 
                    id="file-upload" 
                    type="file" 
                    multiple 
                    onChange={handleFileSelect as (e: ChangeEvent<HTMLInputElement>) => void}
                    className="hidden" 
                    disabled={isLoading || isHistoryLoading || isListening}
                />
            </label>

            <textarea
                ref={inputRef}
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleKeyPress}
                onPaste={handleFileSelect as (e: React.ClipboardEvent<HTMLTextAreaElement>) => void} 
                placeholder={isListening ? "Listening..." : "Message Big AI..."}
                className="flex-1 p-3 bg-transparent focus:outline-none resize-none overflow-y-auto max-h-[200px]"
                style={{ minHeight: '48px', color: 'var(--text-primary)' }}
                disabled={isLoading || isHistoryLoading || isListening}
                rows={1}
                autoFocus
            />
            
            {/* Send Button */}
            <button
              type="submit"
              className="px-4 py-3 text-white rounded-r-xl hover:opacity-90 transition disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
              disabled={isLoading || isHistoryLoading || isListening || (!input.trim() && attachments.length === 0)}
              style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}} // Use AI text color for contrast on accent background
            >
              <svg className="w-5 h-5 transform rotate-45 -mt-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
            </button>
        </form>
      </div>
    </div>
  );
}

--- END FILE: components\ChatArea.tsx ---

--- START FILE: components\ChatBubble.tsx ---

// components/ChatBubble.tsx
'use client';

import React, { useEffect, useMemo, useRef } from 'react';
import { ChatMessage, FileAttachment } from '@/types/chat';

// External Libraries for Markdown Rendering
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
import 'prismjs/themes/prism-dark.css'; 

// Import specific Prism languages needed
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-markup';


// --- TTS / DICTATION UTILITY (Client-side implementation) ---
// Global state for TTS to ensure only one message is speaking at a time
let isSpeaking = false;
let currentUtterance: SpeechSynthesisUtterance | null = null;
let currentButtonRef: React.MutableRefObject<HTMLButtonElement | null> | null = null;

const startSpeech = (text: string, buttonRef: React.MutableRefObject<HTMLButtonElement | null>) => {
    if (!window.speechSynthesis) return console.error('Speech synthesis not supported.');

    // Cancel any current speaking message
    if (window.speechSynthesis.speaking || window.speechSynthesis.paused) {
        window.speechSynthesis.cancel();
    }
    
    // Reset icon on the previously speaking button, if applicable
    if (currentButtonRef && currentButtonRef.current) {
        const iconSpan = currentButtonRef.current.querySelector('[data-icon="tts"]');
        // Reset to Speak icon (volume-2 equivalent)
        if (iconSpan) iconSpan.innerHTML = `<svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M15.536 8.464l-2.071 2.071-2.071-2.071m4.142 4.142l-2.071 2.071m0 0l-2.071-2.071M12 21a9 9 0 110-18 9 9 0 010 18z"></path></svg>`;
    }

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'en-US';

    utterance.onstart = () => {
        isSpeaking = true;
        currentUtterance = utterance;
        currentButtonRef = buttonRef;
        const iconSpan = buttonRef.current?.querySelector('[data-icon="tts"]');
        // Change to Pause icon (stop circle equivalent)
        if (iconSpan) iconSpan.innerHTML = `<svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`; 
    };
    utterance.onend = () => {
        isSpeaking = false;
        currentUtterance = null;
        currentButtonRef = null;
        const iconSpan = buttonRef.current?.querySelector('[data-icon="tts"]');
        // Reset to Speak icon
        if (iconSpan) iconSpan.innerHTML = `<svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M15.536 8.464l-2.071 2.071-2.071-2.071m4.142 4.142l-2.071 2.071m0 0l-2.071-2.071M12 21a9 9 0 110-18 9 9 0 010 18z"></path></svg>`; 
    };
    utterance.onerror = (event) => {
        console.error('Speech synthesis error:', event.error);
        isSpeaking = false;
        currentUtterance = null;
        currentButtonRef = null;
    };

    window.speechSynthesis.speak(utterance);
}

const toggleSpeech = (text: string, buttonRef: React.MutableRefObject<HTMLButtonElement | null>) => {
    if (!window.speechSynthesis) return;

    if (isSpeaking && currentUtterance?.text === text) {
        if (window.speechSynthesis.paused) {
            window.speechSynthesis.resume();
        } else {
            window.speechSynthesis.pause();
        }
    } else {
        startSpeech(text, buttonRef);
    }
};

// --- MARKED CUSTOM RENDERER ---
const renderer = new marked.Renderer();

// Custom code block renderer
renderer.code = ({ text, lang, escaped }: { text: string; lang?: string; escaped?: boolean }): string => {
    const language = lang || 'plaintext';
    // Marked escapes HTML entities; we need to unescape for Prism to work correctly.
    const unescapedCode = text.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    
    const header = `
        <div class="code-block-header flex justify-between items-center">
            <span class="text-xs font-semibold uppercase" style="color: var(--text-secondary);">${language}</span>
            <button type="button" class="copy-button p-1 rounded transition flex items-center gap-1 text-xs" 
                data-code="${encodeURIComponent(unescapedCode)}" 
                style="color: var(--text-secondary); padding: 0.25rem 0.5rem;">
                <span data-icon="clipboard">
                    <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5v-2a2 2 0 012-2h2a2 2 0 012 2v2m-3 7h3m-3 4h3"></path></svg>
                </span>
                <span data-text="Copy">Copy</span>
            </button>
        </div>
    `;

    return `
        <div class="code-block-container" data-lang="${language}">
            ${header}
            <pre><code class="language-${language}">${unescapedCode}</code></pre>
        </div>
    `;
};


marked.setOptions({
    breaks: true,
    renderer: renderer,
    gfm: true,
});

// --- REACT COMPONENT ---

interface ChatBubbleProps {
    message: ChatMessage;
    isPending: boolean;
}

const ChatBubble: React.FC<ChatBubbleProps> = ({ message, isPending }) => {
    const contentRef = useRef<HTMLDivElement>(null);
    const copyButtonRef = useRef<HTMLButtonElement | null>(null);
    const dictateButtonRef = useRef<HTMLButtonElement | null>(null);
    const isUser = message.role === 'user';

    // Parse and sanitize markdown content
    const sanitizedHtml = useMemo(() => {
        if (isUser) {
            // Only convert simple line breaks to <p> tags for cleaner display of user input
            // NOTE: Must sanitize before applying manual line breaks if using DOMPurify
            const safeText = DOMPurify.sanitize(message.text);
            return `<p>${safeText.replace(/\n/g, '<br/>')}</p>`;
        }
        
        const html = marked.parse(message.text);
        // DOMPurify sanitizes the entire generated HTML
        return DOMPurify.sanitize(html as string);
    }, [message.text, isUser]);

    // Apply syntax highlighting and copy listeners after rendering
    useEffect(() => {
        if (contentRef.current && !isUser) {
            // 1. Syntax highlighting
            contentRef.current.querySelectorAll('pre code').forEach((block) => {
                try {
                    // This is client-side code, Prism should be globally available via imported modules
                    Prism.highlightElement(block);
                } catch (e) {
                    console.error("Prism highlighting failed:", e);
                }
            });
            
            // 2. Setup Copy Listeners for code blocks
            contentRef.current.querySelectorAll('.copy-button').forEach(button => {
                const encodedCode = button.getAttribute('data-code');
                if (!encodedCode) return;

                const code = decodeURIComponent(encodedCode);
                
                // Use functional component lifecycle to manage event listeners for cleanliness
                const handleCopy = (e: Event) => {
                    e.preventDefault();
                    navigator.clipboard.writeText(code).then(() => {
                        const iconSpan = button.querySelector('[data-icon="clipboard"]');
                        const textSpan = button.querySelector('[data-text]');
                        
                        // Checkmark icon
                        if (iconSpan) iconSpan.innerHTML = `<svg class="w-4 h-4 text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7"></path></svg>`;
                        if (textSpan) textSpan.textContent = "Copied!";

                        setTimeout(() => {
                            // Clipboard icon
                            if (iconSpan) iconSpan.innerHTML = `<svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5v-2a2 2 0 012-2h2a2 2 0 012 2v2m-3 7h3m-3 4h3"></path></svg>`;
                            if (textSpan) textSpan.textContent = "Copy";
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                    });
                };
                
                // Ensure listener is added only once
                button.removeEventListener('click', handleCopy as EventListener); 
                button.addEventListener('click', handleCopy as EventListener);
            });
        }
    }, [sanitizedHtml, isUser]);

    // Cleanup TTS on unmount
    useEffect(() => {
        return () => {
            // Check if this component's button was the one currently speaking
            if (currentButtonRef === dictateButtonRef && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                isSpeaking = false;
                currentUtterance = null;
                currentButtonRef = null;
            }
        };
    }, []);

    const handleCopyText = () => {
        navigator.clipboard.writeText(message.text)
            .then(() => {
                 // Provide visual feedback by temporarily changing the icon
                 const iconSpan = copyButtonRef.current?.querySelector('svg');
                 if (iconSpan && copyButtonRef.current) {
                     // Checkmark icon
                     copyButtonRef.current.style.color = 'var(--accent-success)';
                     iconSpan.outerHTML = `<svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7"></path></svg>`;
                     
                     setTimeout(() => {
                         // Clipboard icon
                         if (copyButtonRef.current) {
                             copyButtonRef.current.style.color = 'var(--text-secondary)';
                         }
                         iconSpan.outerHTML = `<svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5v-2a2 2 0 012-2h2a2 2 0 012 2v2m-3 7h3m-3 4h3"></path></svg>`;
                     }, 2000);
                 }
            })
            .catch(err => console.error("Copy failed:", err));
    };


    const renderAttachments = (files: FileAttachment[]) => (
        <div className="flex flex-wrap gap-2 mt-2">
            {files.map((file, index) => {
                const isImage = file.mimeType.startsWith('image/');
                const isTooLarge = file.size > 1024 * 1024 * 5; // 5MB heuristic
                
                return (
                    <div key={index} className="flex flex-col items-center p-2 rounded-lg max-w-[150px]" style={{border: '1px solid var(--border-color)', backgroundColor: 'var(--bg-primary)'}}>
                        {isImage && !isTooLarge ? (
                            <img 
                                src={`data:${file.mimeType};base64,${file.base64Data}`}
                                alt={file.filename}
                                className="w-full h-auto object-cover rounded-md max-h-24"
                            />
                        ) : (
                            // File icon placeholder
                            <svg className="w-8 h-8" style={{color: 'var(--accent-secondary)'}} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="1.5"><path strokeLinecap="round" strokeLinejoin="round" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-2.414-2.414A1 1 0 0015.586 6H7a2 2 0 00-2 2v11a2 2 0 002 2zM17 17H7m10-4H7m4-4H7"></path></svg>
                        )}
                        <span className="text-xs truncate w-full text-center mt-1" style={{color: 'var(--text-secondary)'}}>
                            {file.filename}
                        </span>
                    </div>
                );
            })}
        </div>
    );

    return (
        // Added 'group' class here to enable CSS hover effects for message actions
        <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} group`}>
            <div className="flex items-start max-w-[75%]">
                {/* Avatar / Role Indicator (AI) */}
                <div className={`p-2 rounded-full text-white mr-3 shrink-0 self-start ${isUser ? 'hidden' : 'bg-blue-600'}`} style={{backgroundColor: isUser ? 'var(--text-primary)' : 'var(--accent-primary)'}}>
                    {isUser ? '' : 'AI'}
                </div>
                
                {/* Bubble Content */}
                <div
                    className={`p-3 rounded-xl shadow-md transition duration-300 ease-in-out break-words relative ${
                        isUser
                            ? 'rounded-bl-none'
                            : 'rounded-tr-none border'
                    }`}
                    style={{
                        backgroundColor: isUser ? 'var(--user-bubble-bg)' : 'var(--ai-bubble-bg)',
                        color: isUser ? 'var(--user-bubble-text)' : 'var(--ai-bubble-text)',
                        borderColor: isUser ? 'transparent' : 'var(--border-color)'
                    }}
                >
                    {/* Render Multimodal Attachments first */}
                    {message.files && renderAttachments(message.files)}

                    {/* Render Text Content */}
                    <div 
                        ref={contentRef}
                        className={`message-content ${isUser ? '' : 'prose max-w-none'}`} 
                        dangerouslySetInnerHTML={{ __html: sanitizedHtml }}
                    />

                    {/* Message Actions (Copy/Dictate) */}
                    <div className="absolute bottom-1 flex space-x-2 opacity-0 group-hover:opacity-100 transition-opacity p-1 rounded-lg" 
                        style={{
                            backgroundColor: 'var(--header-bg)', 
                            border: '1px solid var(--border-color)',
                            // Use ternary operator to position the action buttons correctly
                            right: isUser ? '10px' : 'auto',
                            left: isUser ? 'auto' : '10px',
                            bottom: '10px',
                        }}
                    >
                        
                        {/* Copy Button */}
                        <button 
                            ref={copyButtonRef}
                            onClick={handleCopyText} 
                            title="Copy Message"
                            className="p-1 rounded transition hover:bg-[var(--sidebar-item-hover)]"
                            style={{color: 'var(--text-secondary)'}}
                        >
                            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5v-2a2 2 0 012-2h2a2 2 0 012 2v2m-3 7h3m-3 4h3"></path></svg>
                        </button>

                        {/* Dictate Button (Only when not pending) */}
                        {!isPending && (
                             <button
                                ref={dictateButtonRef}
                                onClick={() => toggleSpeech(message.text, dictateButtonRef)}
                                title="Dictate Message (TTS)"
                                className="p-1 rounded transition hover:bg-[var(--sidebar-item-hover)]"
                                style={{color: 'var(--text-secondary)'}}
                            >
                                <span data-icon="tts">
                                    {/* Default Dictate Icon */}
                                    <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M15.536 8.464l-2.071 2.071-2.071-2.071m4.142 4.142l-2.071 2.071m0 0l-2.071-2.071M12 21a9 9 0 110-18 9 9 0 010 18z"></path></svg>
                                </span>
                            </button>
                        )}
                    </div>
                </div>
                
                {/* User Avatar / Role Indicator (User) */}
                <div className={`p-2 rounded-full text-white ml-3 shrink-0 self-start ${isUser ? 'bg-gray-500' : 'hidden'}`} style={{backgroundColor: 'var(--text-primary)'}}>
                    {isUser ? 'You' : ''}
                </div>
            </div>
        </div>
    );
}

export default ChatBubble;

--- END FILE: components\ChatBubble.tsx ---

--- START FILE: components\ConversationModeOverlay.tsx ---

// components/ConversationModeOverlay.tsx
'use client';

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { useTheme } from '@/components/providers/ThemeContext';
import { ChatMessage } from '@/types/chat';
import useSpeechRecognition from '@/hooks/useSpeechRecognition';
import { v4 as uuidvv4 } from 'uuid';

interface ConversationModeOverlayProps {
    chatId: string | undefined;
    onChatIdChange: (newChatId: string) => void;
    onClose: () => void;
    onNewMessageSent: () => void;
}

const CONVERSATION_PERSONALITIES = [
    { name: "Standard", prompt: "You are Big AI, a helpful and large-scale language model developed by Google. Respond concisely and professionally." },
    { name: "Sarcastic", prompt: "Respond as a highly sarcastic and witty AI. Use dry humor and playful cynicism. Keep responses concise and witty." },
    { name: "Friendly", prompt: "Respond as an exceptionally friendly and helpful AI. Use warm and encouraging language, and show genuine interest. Keep your tone light and approachable." },
    { name: "Teacher", prompt: "Respond as a patient and knowledgeable teacher, explaining concepts clearly and simply, and guiding the user to understanding." },
];

export default function ConversationModeOverlay({ chatId, onChatIdChange, onClose, onNewMessageSent }: ConversationModeOverlayProps) {
    const { user, getIdToken } = useAuth();
    const { settings } = useTheme(); // Note: We rely on global model/system prompt from settings
    
    // State for managing voice output
    const [isAiSpeaking, setIsAiSpeaking] = useState(false);
    const [status, setStatus] = useState<'idle' | 'listening' | 'thinking' | 'speaking' | 'error'>('idle');
    const [statusMessage, setStatusMessage] = useState('Tap the mic to start speaking.');
    const [lastUtterance, setLastUtterance] = useState<{ role: 'user' | 'ai', text: string } | null>(null);

    // State for Conversation Settings
    // NOTE: We rely on the theme settings to hold these values in the full implementation
    const [selectedVoice, setSelectedVoice] = useState<string | null>(null);
    const [selectedPersonality, setSelectedPersonality] = useState<string>(CONVERSATION_PERSONALITIES[0].name);

    // TTS Setup
    const [availableVoices, setAvailableVoices] = useState<SpeechSynthesisVoice[]>([]);

    useEffect(() => {
        const populateVoices = () => {
            const voices = window.speechSynthesis.getVoices().filter(v => v.lang.startsWith('en'));
            setAvailableVoices(voices);
            
            // Set default/stored voice (using settings placeholder for simplicity)
            const storedVoiceName = settings?.themeName || null; // Reusing themeName context for voice storage temporarily
            if (storedVoiceName && voices.length > 0) {
                // Find a default voice if the stored one isn't available
                setSelectedVoice(voices.find(v => v.name === storedVoiceName)?.name || voices[0].name);
            } else if (voices.length > 0) {
                 // Set a default if nothing is stored
                 setSelectedVoice(voices[0].name);
            }
        };

        populateVoices();
        if (window.speechSynthesis.onvoiceschanged !== undefined) {
            window.speechSynthesis.onvoiceschanged = populateVoices;
        }

        // Load conversation settings from global settings
        if (settings) {
            // Check if globalSystemPrompt is active (handled via the PromptManager)
            if (settings.globalSystemPrompt.trim()) {
                setSelectedPersonality('Custom Prompt');
            } else {
                 // Fallback to the default personality if custom prompt is inactive
                setSelectedPersonality(CONVERSATION_PERSONALITIES[0].name);
            }
        }
        
        // Cleanup TTS on component unmount
        return () => {
            if (window.speechSynthesis.speaking || window.speechSynthesis.paused) {
                window.speechSynthesis.cancel();
            }
        };

    }, [settings]);

    // Speech Recognition Hook for the Conversation Loop
    const { 
        isListening, 
        transcript, 
        startListening, 
        stopListening, 
        recognitionSupported,
        resetTranscript
    } = useSpeechRecognition({
        continuous: false, // Ensure it stops after detecting a pause
        onStart: () => {
            // Only update status if AI isn't currently speaking
            if (!isAiSpeaking) {
                setStatus('listening');
                setStatusMessage('Listening...');
                setLastUtterance({ role: 'user', text: '' });
            }
        },
        onFinalTranscript: (finalTranscript) => {
            setLastUtterance({ role: 'user', text: finalTranscript });
            // Immediately stop listening if we got a final transcript, as continuous is false
            stopListening();
            handleUserSpeechEnd(finalTranscript);
        },
        onInterimTranscript: (interimTranscript) => {
             // Update interim text displayed to user
             setLastUtterance(prev => ({ role: 'user', text: (prev?.text || '') + interimTranscript }));
        },
        onEnd: () => {
            if (status === 'listening') {
                // If it ended without a final transcript (e.g., no speech detected, or user paused too long)
                setStatus('idle');
                setStatusMessage('No speech detected. Tap the mic to try again.');
            }
        },
        onError: (error) => {
            console.error("Conversation STT Error:", error);
            setStatus('error');
            setStatusMessage(`Error: ${error}. Tap the mic to restart.`);
             setTimeout(() => {
                setStatus('idle');
                setStatusMessage('Tap the mic to start speaking.');
            }, 5000);
        }
    });


    // --- Core Conversation Loop Handlers ---

    const handleUserSpeechEnd = async (userText: string) => {
        if (!userText.trim()) {
            setStatus('idle');
            setStatusMessage('No speech detected. Tap the mic to try again.');
            return;
        }
        
        setStatus('thinking');
        setStatusMessage('AI is thinking...');

        try {
            const token = await getIdToken();
            
            // Determine the system prompt based on settings
            const systemPrompt = settings?.globalSystemPrompt.trim();
            const personalityPrompt = CONVERSATION_PERSONALITIES.find(p => p.name === selectedPersonality)?.prompt;
            
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`, 
                },
                body: JSON.stringify({
                    message: userText,
                    chatId: chatId, 
                    // Pass system prompt only for NEW chats, or if we want to explicitly use a personality prompt
                    globalSystemPrompt: chatId ? systemPrompt : (systemPrompt || personalityPrompt), 
                }),
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `API returned status ${response.status}`);
            }

            const newChatId = response.headers.get('X-Chat-ID');
            if (newChatId && newChatId !== chatId) {
                onChatIdChange(newChatId); 
            }
            
            // Read streamed response (assuming the API is designed to return plain text in this route)
            const reader = response.body?.getReader();
            const decoder = new TextDecoder();
            let fullBotResponse = '';

            // This is a simplified stream reading compared to ChatArea, as we need the full text before TTS
            while (reader) {
                 const { done, value } = await reader.read();
                 if (done) break;
                 fullBotResponse += decoder.decode(value);
            }
            
            setLastUtterance({ role: 'ai', text: fullBotResponse });
            startSpeaking(fullBotResponse);
            onNewMessageSent(); // Trigger sidebar refresh
            
        } catch (error) {
            console.error('Conversation AI Error:', error);
            setStatus('error');
            setStatusMessage(`AI Error: ${error instanceof Error ? error.message : 'Unknown communication error.'}`);
            setTimeout(() => {
                if (recognitionSupported) {
                    setStatus('idle');
                    setStatusMessage('Tap the mic to restart.');
                }
            }, 5000);
        }
    };
    
    const startSpeaking = (text: string) => {
        if (!window.speechSynthesis) return;

        setStatus('speaking');
        setStatusMessage('AI Speaking...');
        setIsAiSpeaking(true);

        const utterance = new SpeechSynthesisUtterance(text);
        
        const voice = availableVoices.find(v => v.name === selectedVoice);
        if (voice) {
            utterance.voice = voice;
        }
        
        utterance.onend = () => {
            setIsAiSpeaking(false);
            // After AI speaks, restart listening
            if (recognitionSupported) {
                 // Slight delay before restarting mic to prevent capturing residual sound
                 setTimeout(() => startListening(), 500); 
            } else {
                 setStatus('idle');
                 setStatusMessage('Conversation finished. Speech recognition disabled.');
            }
        };
        utterance.onerror = (e) => {
            console.error('TTS Error:', e);
            setIsAiSpeaking(false);
            if (recognitionSupported) {
                 setTimeout(() => startListening(), 500); 
            } else {
                 setStatus('idle');
            }
        }

        window.speechSynthesis.speak(utterance);
    };

    const handleMicToggle = () => {
        if (!user) return;
        
        if (isAiSpeaking) {
            window.speechSynthesis.cancel();
            setIsAiSpeaking(false);
            setStatus('idle');
            setStatusMessage('AI speech canceled. Tap the mic to restart.');
        } else if (isListening) {
            stopListening();
            setStatus('idle');
            setStatusMessage('Listening stopped. Tap the mic to restart.');
        } else {
            if (!recognitionSupported) {
                 setStatus('error');
                 setStatusMessage("Speech Recognition is not supported in this browser.");
                 return;
            }
            // Reset state and start listening
            resetTranscript();
            setLastUtterance(null);
            startListening();
        }
    };
    
    // UI mapping
    const soundBlobState = isListening ? 'listening' : (isAiSpeaking ? 'speaking' : 'idle');
    const micButtonState = isListening || isAiSpeaking;

    const currentPersonalityDisplay = settings?.globalSystemPrompt.trim() 
        ? 'Custom Prompt' 
        : CONVERSATION_PERSONALITIES.find(p => p.name === selectedPersonality)?.name || 'Standard';

    return (
        <div 
            className="fixed inset-0 flex flex-col items-center justify-center p-4 transition-opacity duration-500"
            style={{backgroundColor: 'var(--conversation-bg)', color: 'var(--conversation-text)', zIndex: 100}}
        >
            <button id="conversation-mode-close-btn" onClick={onClose} className="absolute top-4 right-4 p-2 rounded-full hover:bg-black/10 transition" style={{color: 'var(--text-secondary)'}}>
                <svg className="w-8 h-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>

            <div className="conversation-controls absolute top-4 flex gap-4 p-3 rounded-full border" style={{borderColor: 'var(--border-color)', backgroundColor: 'var(--card-bg)'}}>
                <div className='flex items-center gap-2 text-sm'>
                    <span style={{color: 'var(--accent-primary)'}}>Voice:</span> 
                    <select
                        value={selectedVoice || ''}
                        onChange={(e) => setSelectedVoice(e.target.value)}
                        disabled={isListening || isAiSpeaking}
                        className="p-1 rounded border" style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--text-primary)', borderColor: 'var(--border-color)'}}
                    >
                        {availableVoices.map(voice => (
                            <option key={voice.name} value={voice.name}>{voice.name}</option>
                        ))}
                    </select>
                </div>
                <div className='flex items-center gap-2 text-sm'>
                     <span style={{color: 'var(--accent-primary)'}}>Personality:</span> 
                    <span className='font-semibold'>{currentPersonalityDisplay}</span>
                </div>
            </div>

            {/* Sound Blob Animation Area */}
            <div className="relative w-72 h-72 flex items-center justify-center mt-20 mb-8">
                {/* Note: Tailwind doesn't easily support the complex CSS animations/shapes from Part 2,
                    so we use simple concentric circles driven by state variables. */}
                <div 
                    className={`absolute w-full h-full rounded-full transition-all duration-500 blur-lg 
                        ${soundBlobState === 'listening' ? 'scale-110 opacity-70' : soundBlobState === 'speaking' ? 'scale-105 opacity-80' : 'scale-90 opacity-50'}`}
                    style={{backgroundColor: 'var(--conversation-indicator)'}}
                ></div>
                 <div 
                    className={`absolute w-40 h-40 flex items-center justify-center rounded-full transition-all duration-500`}
                    style={{backgroundColor: 'var(--card-bg)', color: 'var(--conversation-indicator)'}}
                >
                    <svg className="w-16 h-16" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M4.343 19.657l.707-.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                </div>
            </div>

            <div className={`text-3xl font-extrabold text-center mb-6 min-h-[3rem] transition-colors duration-300`} 
                 style={{color: status === 'error' ? 'var(--accent-error)' : 'var(--text-primary)'}}
            >
                {statusMessage}
            </div>

            <div className="w-full max-w-xl h-24 overflow-y-auto p-3 rounded-xl border mb-8" 
                 style={{backgroundColor: 'var(--bg-secondary)', borderColor: 'var(--border-color)', color: 'var(--text-secondary)'}}
            >
                {lastUtterance ? (
                    <p className={`text-lg ${lastUtterance.role === 'user' ? 'text-blue-400' : 'text-green-400'} font-semibold truncate`}>
                        {lastUtterance.role === 'user' ? 'You: ' : 'AI: '}
                        {lastUtterance.text}
                    </p>
                ) : (
                    <p className='text-center italic'>Recent speech appears here.</p>
                )}
            </div>

            <button 
                onClick={handleMicToggle} 
                className={`w-20 h-20 rounded-full shadow-xl transition-all duration-300 ${micButtonState ? 'voice-input-active' : ''}`}
                title={micButtonState ? "Stop" : "Start Listening"}
                style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}
            >
                <svg className="w-10 h-10 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 11a7 7 0 01-7 7v0a7 7 0 01-7-7v0a7 7 0 0114 0zM12 18v3m4 0H8m6-12a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
            </button>
            <p className='text-xs mt-4' style={{color: 'var(--text-secondary)'}}>
                {isAiSpeaking ? 'Click to stop AI speech.' : (isListening ? 'Click to stop listening.' : 'Click to speak.')}
            </p>
        </div>
    );
}

--- END FILE: components\ConversationModeOverlay.tsx ---

--- START FILE: components\PromptManager.tsx ---

// components/PromptManager.tsx
'use client';

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { useTheme } from '@/components/providers/ThemeContext';
import { PromptTemplate, UserSettings } from '@/types/chat';
import { v4 as uuidv4 } from 'uuid';

interface PromptManagerProps {
    onClose: () => void;
}

const MODELS = [
    { id: 'gemini-3-pro-preview', name: 'Gemini 3.0 Pro' },
    { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro' },
    { id: 'gemini-2.5-flash-preview-09-2025', name: 'Gemini 2.5 Flash (Recommended)' },
    { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash (Stable)' },
    { id: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash Lite' },
];

export default function PromptManager({ onClose }: PromptManagerProps) {
    const { user } = useAuth();
    const { settings, updateSettings } = useTheme();
    
    // Local state for forms
    const [globalPrompt, setGlobalPrompt] = useState(settings?.globalSystemPrompt || '');
    const [apiKeyInput, setApiKeyInput] = useState(settings?.apiKey || '');
    const [templates, setTemplates] = useState<PromptTemplate[]>(settings?.templates || []);

    const [templateName, setTemplateName] = useState('');
    const [templateContent, setTemplateContent] = useState('');
    const [editingTemplateId, setEditingTemplateId] = useState<string | null>(null);
    const [statusMessage, setStatusMessage] = useState<string | null>(null);

    // --- Global Prompt/Model/API Key Handlers ---

    const handleSaveGlobalSettings = async (e: React.FormEvent) => {
        e.preventDefault();
        const newPrompt = globalPrompt.trim();

        await updateSettings({
            globalSystemPrompt: newPrompt,
            globalModel: settings?.globalModel, // Keep model synced
            apiKey: apiKeyInput.trim() || null,
        });

        setStatusMessage('Global settings saved successfully!');
        setTimeout(() => setStatusMessage(null), 3000);
    };

    const handleClearGlobalPrompt = async () => {
        setGlobalPrompt('');
        await updateSettings({ globalSystemPrompt: '' });
        setStatusMessage('Global prompt cleared.');
        setTimeout(() => setStatusMessage(null), 3000);
    };
    
    const handleModelChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        updateSettings({ globalModel: e.target.value });
    };

    // --- Template Handlers ---

    const handleClearTemplateForm = () => {
        setTemplateName('');
        setTemplateContent('');
        setEditingTemplateId(null);
    };

    const handleSaveTemplate = async () => {
        if (!templateName.trim() || !templateContent.trim()) {
            setStatusMessage('Template name and content are required.');
            return;
        }

        const updatedTemplates = [...templates];
        const newTemplate: PromptTemplate = {
            id: editingTemplateId || uuidv4(),
            name: templateName.trim(),
            content: templateContent.trim(),
        };

        if (editingTemplateId) {
            const index = updatedTemplates.findIndex(t => t.id === editingTemplateId);
            if (index !== -1) {
                updatedTemplates[index] = newTemplate;
                setStatusMessage('Template updated successfully!');
            }
        } else {
            updatedTemplates.push(newTemplate);
            setStatusMessage('Template saved successfully!');
        }

        setTemplates(updatedTemplates);
        await updateSettings({ templates: updatedTemplates });
        handleClearTemplateForm();
        setTimeout(() => setStatusMessage(null), 3000);
    };

    const handleEditTemplate = (template: PromptTemplate) => {
        setTemplateName(template.name);
        setTemplateContent(template.content);
        setEditingTemplateId(template.id);
    };
    
    const handleDeleteTemplate = async (templateId: string) => {
        if (!window.confirm('Are you sure you want to delete this template?')) return;
        
        const updatedTemplates = templates.filter(t => t.id !== templateId);
        setTemplates(updatedTemplates);
        await updateSettings({ templates: updatedTemplates });
        
        if (editingTemplateId === templateId) {
            handleClearTemplateForm();
        }

        // If the active global prompt matches the deleted template, clear it too.
        if (settings?.globalSystemPrompt === templates.find(t => t.id === templateId)?.content) {
             setGlobalPrompt('');
             await updateSettings({ globalSystemPrompt: '' });
        }

        setStatusMessage('Template deleted.');
        setTimeout(() => setStatusMessage(null), 3000);
    };

    const handleUseTemplate = async (content: string) => {
        setGlobalPrompt(content);
        await updateSettings({ globalSystemPrompt: content });
        setStatusMessage('Template activated as Global System Prompt!');
        setTimeout(() => setStatusMessage(null), 3000);
    };

    const globalPromptIsActive = globalPrompt.trim() !== '';

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
            <div className="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-y-auto border" style={{backgroundColor: 'var(--card-bg)', color: 'var(--text-primary)', borderColor: 'var(--border-color)'}}>
                
                <div className="flex justify-between items-center mb-6 border-b pb-3" style={{borderColor: 'var(--border-color)'}}>
                    <h2 className="text-2xl font-bold flex items-center gap-2">
                        <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-primary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        Prompt & API Configuration
                    </h2>
                    <button onClick={onClose} className="p-1 rounded hover:opacity-80 transition" style={{color: 'var(--text-secondary)'}}>
                        <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                
                {/* Status Message */}
                {statusMessage && (
                    <div className={`p-3 mb-4 text-sm rounded-lg text-center ${statusMessage.includes('saved') || statusMessage.includes('activated') ? 'bg-green-600 text-white' : 'bg-red-600 text-white'}`}>
                        {statusMessage}
                    </div>
                )}

                {/* --- API Key Management --- */}
                <div className="mb-6 p-4 rounded-lg border" style={{backgroundColor: 'var(--bg-secondary)', borderColor: 'var(--border-color)'}}>
                    <h3 className="text-lg font-bold mb-3 flex items-center gap-2">
                        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-secondary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 7a2 2 0 012 2v5a2 2 0 01-2 2h-2m-3-1a2 2 0 00-2 2v5m-3-4a2 2 0 002 2h4a2 2 0 002-2v-5a2 2 0 00-2-2m0 0a2 2 0 100-4 2 2 0 000 4z"></path></svg>
                        Gemini API Key
                    </h3>
                    <div className="flex items-center gap-2">
                        <input
                            type="password"
                            value={apiKeyInput}
                            onChange={(e) => setApiKeyInput(e.target.value)}
                            placeholder="Enter your private Gemini API Key (optional)"
                            className="w-full p-2 rounded-md border text-sm"
                            style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                        />
                         <button onClick={handleSaveGlobalSettings} className="p-2 rounded-md transition" style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}>
                            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M8 7H5a2 2 0 00-2 2v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                        </button>
                    </div>
                    <p className="text-xs mt-1" style={{color: apiKeyInput.trim() ? 'var(--accent-success)' : 'var(--accent-error)'}}>
                        {apiKeyInput.trim() ? 'Key is set. Your key will be prioritized for API calls.' : 'No key set. Using server fallback key.'}
                    </p>
                </div>

                {/* --- Global System Prompt --- */}
                <form onSubmit={handleSaveGlobalSettings} className="mb-6 p-4 rounded-lg border" style={{backgroundColor: 'var(--bg-secondary)', borderColor: 'var(--border-color)'}}>
                    <h3 className="text-lg font-bold mb-3 flex items-center gap-2">
                        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: globalPromptIsActive ? 'var(--accent-primary)' : 'var(--text-secondary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                        Global System Prompt {globalPromptIsActive && <span className='text-xs font-normal' style={{color: 'var(--accent-primary)'}}>(Active)</span>}
                    </h3>
                    <textarea
                        value={globalPrompt}
                        onChange={(e) => setGlobalPrompt(e.target.value)}
                        rows={4}
                        placeholder="Define the AI's personality/behavior for new chats (e.g., 'You are a highly sarcastic chef.')."
                        className="w-full p-3 rounded-md border resize-none"
                        style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                    />
                    <div className="flex justify-between items-center mt-4">
                        <button 
                            type="button"
                            onClick={handleClearGlobalPrompt} 
                            className="px-3 py-2 text-sm rounded-lg transition" 
                            style={{backgroundColor: 'var(--accent-error)', color: 'white'}}
                        >
                            Clear Prompt
                        </button>
                        <button 
                            type="submit"
                            className="px-4 py-2 text-sm rounded-lg transition"
                            style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}
                        >
                            Save Prompt
                        </button>
                    </div>
                </form>

                {/* --- Prompt Templates Management --- */}
                <div className="p-4 rounded-lg border" style={{backgroundColor: 'var(--bg-secondary)', borderColor: 'var(--border-color)'}}>
                    <h3 className="text-lg font-bold mb-4 flex items-center gap-2">
                        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-primary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                        Prompt Templates ({templates.length})
                    </h3>
                    
                    {/* Template Input Form */}
                    <div className="mb-4 space-y-2">
                        <input
                            type="text"
                            value={templateName}
                            onChange={(e) => setTemplateName(e.target.value)}
                            placeholder="Template Name (e.g., 'Sarcastic AI')"
                            className="w-full p-2 rounded-md border text-sm"
                            style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                        />
                        <textarea
                            value={templateContent}
                            onChange={(e) => setTemplateContent(e.target.value)}
                            rows={3}
                            placeholder="Enter the reusable system prompt content here."
                            className="w-full p-3 rounded-md border resize-none text-sm"
                            style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                        />
                        <div className="flex justify-end gap-2 pt-2">
                            <button 
                                type="button"
                                onClick={handleClearTemplateForm} 
                                className="px-3 py-2 text-sm rounded-lg transition" 
                                style={{backgroundColor: 'var(--bg-primary)', color: 'var(--text-secondary)', border: '1px solid var(--border-color)'}}
                            >
                                Clear Form
                            </button>
                            <button 
                                type="button"
                                onClick={handleSaveTemplate}
                                className="px-4 py-2 text-sm rounded-lg transition"
                                style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}
                            >
                                {editingTemplateId ? 'Update Template' : 'Save New Template'}
                            </button>
                        </div>
                    </div>
                    
                    {/* Saved Templates List */}
                    <ul className="space-y-3 max-h-60 overflow-y-auto pr-2 pt-4 border-t" style={{borderColor: 'var(--border-color)'}}>
                        {templates.length === 0 ? (
                            <li className="text-center text-sm p-4" style={{color: 'var(--text-secondary)'}}>No templates saved yet.</li>
                        ) : (
                            templates.map(template => (
                                <li key={template.id} className="p-3 rounded-lg border" style={{backgroundColor: 'var(--bg-primary)', borderColor: 'var(--border-color)'}}>
                                    <div className="font-semibold mb-1 truncate" style={{color: 'var(--accent-primary)'}}>{template.name}</div>
                                    <p className="text-xs mb-2 truncate" style={{color: 'var(--text-secondary)'}}>
                                        {template.content.substring(0, 100) + (template.content.length > 100 ? '...' : '')}
                                    </p>
                                    <div className="flex gap-2 justify-end text-xs mt-2">
                                        <button onClick={() => handleUseTemplate(template.content)} className="px-2 py-1 rounded transition" style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}>Use</button>
                                        <button onClick={() => handleEditTemplate(template)} className="px-2 py-1 rounded transition" style={{backgroundColor: 'var(--card-bg)', color: 'var(--text-primary)', border: '1px solid var(--border-color)'}}>Edit</button>
                                        <button onClick={() => handleDeleteTemplate(template.id)} className="px-2 py-1 rounded transition" style={{backgroundColor: 'var(--accent-error)', color: 'white'}}>Delete</button>
                                    </div>
                                </li>
                            ))
                        )}
                    </ul>
                </div>

                <div className="flex justify-end mt-6">
                    <button onClick={onClose} className="px-4 py-2 rounded-lg font-semibold transition" style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}}>
                        Close Panel
                    </button>
                </div>
            </div>
        </div>
    );
}

--- END FILE: components\PromptManager.tsx ---

--- START FILE: components\SettingsPanel.tsx ---

// components/SettingsPanel.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { UserSettings } from '@/types/chat';

interface SettingsPanelProps {
    onClose: () => void;
}

const MODELS = [
    { name: 'Gemini 2.5 Flash (Preview 09-2025)', id: 'gemini-2.5-flash-preview-09-2025', description: 'The recommended default model, stable and powerful.' }, // <-- NEW DEFAULT
    { name: 'Gemini 2.5 Flash (Stable)', id: 'gemini-2.5-flash', description: 'Fast and versatile, ideal for chat.' },
    { name: 'Gemini 2.5 Pro', id: 'gemini-2.5-pro', description: 'Most capable model for complex tasks.' },
    { name: 'Gemini 3.0 Pro', id: 'gemini-3-pro-preview', description: 'Experimental, highest reasoning capability.' },
];

export default function SettingsPanel({ onClose }: SettingsPanelProps) {
    const { user, getIdToken } = useAuth();
    const [settings, setSettings] = useState<UserSettings | null>(null);
    const [loading, setLoading] = useState(true);
    const [saving, setSaving] = useState(false);
    const [statusMessage, setStatusMessage] = useState<string | null>(null);

    // Fetch settings on load
    useEffect(() => {
        const fetchSettings = async () => {
            if (!user) return;
            try {
                const token = await getIdToken();
                const response = await fetch('/api/settings', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (response.ok) {
                    const data: UserSettings = await response.json();
                    setSettings(data);
                } else {
                    console.error("Failed to fetch settings.");
                }
            } catch (error) {
                console.error("Error fetching settings:", error);
            } finally {
                setLoading(false);
            }
        };
        fetchSettings();
    }, [user, getIdToken]);

    const handleSave = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!user || !settings) return;

        setSaving(true);
        setStatusMessage(null);
        try {
            const token = await getIdToken();
            const response = await fetch('/api/settings', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({
                    globalModel: settings.globalModel,
                    globalSystemPrompt: settings.globalSystemPrompt,
                }),
            });

            if (response.ok) {
                setStatusMessage('Settings saved successfully!');
            } else {
                setStatusMessage('Failed to save settings.');
            }
        } catch (error) {
            console.error("Error saving settings:", error);
            setStatusMessage('An error occurred during saving.');
        } finally {
            setSaving(false);
            setTimeout(() => setStatusMessage(null), 3000);
        }
    };
    
    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value } = e.target;
        setSettings(prev => prev ? ({ ...prev, [name]: value }) : null);
    };

    if (loading) {
        return (
             <div className="absolute inset-0 bg-gray-900/90 flex items-center justify-center text-white z-50">
                 Loading settings...
            </div>
        )
    }
    
    if (!settings) return null; 

    return (
        <div className="absolute inset-0 bg-gray-900/95 flex items-center justify-center z-50">
            <div className="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-2xl border border-gray-700">
                <div className="flex justify-between items-center mb-6 border-b border-gray-700 pb-3">
                    <h2 className="text-2xl font-bold text-white">AI Settings & Prompts</h2>
                    <button onClick={onClose} className="text-gray-400 hover:text-white transition">
                        <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>

                <form onSubmit={handleSave} className="space-y-6">
                    {/* Model Selection */}
                    <div>
                        <label htmlFor="globalModel" className="block text-sm font-medium text-gray-300 mb-1">
                            Default AI Model
                        </label>
                        <select
                            id="globalModel"
                            name="globalModel"
                            value={settings.globalModel}
                            onChange={handleInputChange}
                            className="w-full p-2 border border-gray-700 rounded-lg bg-gray-700 text-white focus:ring-blue-500 focus:border-blue-500"
                        >
                            {MODELS.map(model => (
                                <option key={model.id} value={model.id}>
                                    {model.name}
                                </option>
                            ))}
                        </select>
                        <p className="text-xs text-gray-500 mt-1">
                            {MODELS.find(m => m.id === settings.globalModel)?.description}
                        </p>
                    </div>

                    {/* System Prompt */}
                    <div>
                        <label htmlFor="globalSystemPrompt" className="block text-sm font-medium text-gray-300 mb-1">
                            Global System Prompt (Personality)
                        </label>
                        <textarea
                            id="globalSystemPrompt"
                            name="globalSystemPrompt"
                            value={settings.globalSystemPrompt}
                            onChange={handleInputChange}
                            rows={4}
                            placeholder="Set an instruction to define the AI's behavior..."
                            className="w-full p-3 border border-gray-700 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500 resize-none"
                        />
                        <p className="text-xs text-gray-500 mt-1">
                            This prompt defines the AI&apos;s behavior for all *new* conversations.
                        </p>
                    </div>
                    
                    {/* Save Button */}
                    <div className="flex justify-between items-center pt-4">
                        {statusMessage && (
                            <p className={`text-sm ${statusMessage.includes('saved') ? 'text-green-400' : 'text-red-400'}`}>
                                {statusMessage}
                            </p>
                        )}
                        <button
                            type="submit"
                            disabled={saving}
                            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition disabled:bg-blue-400"
                        >
                            {saving ? 'Saving...' : 'Save Settings'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
}

--- END FILE: components\SettingsPanel.tsx ---

--- START FILE: components\Sidebar.tsx ---

// components/Sidebar.tsx
'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { useTheme } from '@/components/providers/ThemeContext';
import PromptManager from './PromptManager'; 

interface ChatHistoryItem {
    id: string;
    title: string;
    updatedAt: number;
}

interface SidebarProps {
    onSelectChat: (chatId: string | undefined) => void;
    currentChatId: string | undefined;
    onNewMessageSent: () => void; 
    onOpenConversationMode: () => void; 
}

// Available Models list
const AVAILABLE_MODELS = [
    { id: 'gemini-3-pro-preview', name: 'Gemini 3.0 Pro' },
    { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro' },
    { id: 'gemini-2.5-flash-preview-09-2025', name: 'Gemini 2.5 Flash (Recommended)' },
    { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash (Stable)' },
    { id: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash Lite' },
];

export default function Sidebar({ onSelectChat, currentChatId, onNewMessageSent, onOpenConversationMode }: SidebarProps) {
    const { user, signOut, getIdToken } = useAuth();
    const { themeName, themeMode, setMode, setTheme, settings, updateSettings, availableThemes } = useTheme();
    
    const [history, setHistory] = useState<ChatHistoryItem[]>([]);
    const [loading, setLoading] = useState(true);
    const [isPromptManagerOpen, setIsPromptManagerOpen] = useState(false); 
    const [isSettingsCollapsed, setIsSettingsCollapsed] = useState(true); 

    const fetchHistory = useCallback(async () => {
        if (!user) return;
        setLoading(true);
        try {
            const token = await getIdToken();
            const response = await fetch('/api/chats', {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            if (response.ok) {
                const data: ChatHistoryItem[] = await response.json();
                setHistory(data);
            }
        } catch (error) {
            console.error("Failed to fetch chat history:", error);
        } finally {
            setLoading(false);
        }
    }, [user, getIdToken]); 

    useEffect(() => {
        fetchHistory();
    }, [onNewMessageSent, fetchHistory]); 

    const handleNewChat = () => {
        onSelectChat(undefined);
    };
    
    const handleDeleteChat = async (chatIdToDelete: string) => {
        if (!user) return;
        
        // Fetch title for confirmation message (optional, but nice UX)
        const chatToDelete = history.find(c => c.id === chatIdToDelete);
        const title = chatToDelete?.title || "this chat";

        if (confirm(`Are you sure you want to delete ${title}? This cannot be undone.`)) {
            try {
                const token = await getIdToken();
                const response = await fetch(`/api/chat?chatId=${chatIdToDelete}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.ok) {
                    setHistory(prev => prev.filter(c => c.id !== chatIdToDelete));
                    
                    if (currentChatId === chatIdToDelete) {
                        onSelectChat(undefined); // Switch to a new chat
                    }
                    onNewMessageSent(); // Force history refresh
                } else {
                    console.error("Failed to delete chat:", await response.json());
                    alert("Failed to delete chat. Check console.");
                }
            } catch (error) {
                 console.error("Error deleting chat:", error);
                 alert("Error deleting chat. Check console.");
            }
        }
    }

    const handleSignOut = async () => {
        if (confirm("Are you sure you want to sign out?")) {
            await signOut();
        }
    };
    
    const handleDeleteAllChats = async () => {
        // ... (Existing implementation)
        if (!user) return;
        if (confirm("DANGER: Are you sure you want to permanently delete ALL your chat history? This cannot be undone.")) {
            try {
                const token = await getIdToken();
                const response = await fetch('/api/chats', {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.ok) {
                    setHistory([]);
                    onSelectChat(undefined);
                } else {
                    console.error('Failed to delete all chats:', await response.json());
                }
            } catch (error) {
                 console.error("Error deleting all chats:", error);
            }
        }
    }

    const handleClearLocalStorage = () => {
        // ... (Existing implementation)
        if (confirm('WARNING: Are you sure you want to clear all local settings (themes, model selection)? Your chat history (saved in the cloud) will NOT be affected, but you may need to re-login and re-select your preferred theme.')) {
            localStorage.clear(); 
            window.location.reload(); 
        }
    }
    
    // UI Event Handlers
    
    const handleModelChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        updateSettings({ globalModel: e.target.value });
    };

    const handleThemeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        setTheme(e.target.value);
    };

    const handleModeToggle = (e: React.ChangeEvent<HTMLInputElement>) => {
        setMode(e.target.checked ? 'dark' : 'light');
    };


    return (
        <div className="flex flex-col w-64 h-screen p-3 shadow-2xl relative" style={{backgroundColor: 'var(--sidebar-bg)', color: 'var(--text-primary)', borderColor: 'var(--sidebar-border)'}}>
            
            {isPromptManagerOpen && (
                <PromptManager onClose={() => { setIsPromptManagerOpen(false); onNewMessageSent(); }} />
            )}
            
            <div className="flex items-center justify-between pb-4 border-b mb-4" style={{borderColor: 'var(--sidebar-border)'}}>
                 <h2 className="text-xl font-bold flex items-center gap-2" style={{color: 'var(--text-primary)'}}>
                    {/* Updated Branding Icon (Using a custom one, mimicking the Part 2 icon look) */}
                    <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-primary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M4.343 19.657l.707-.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                    Big AI
                </h2>
            </div>
            
            {/* New Chat Button */}
            {/* ... (Existing New Chat Button) */}
            <button
                onClick={handleNewChat}
                className="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors mb-4"
                style={{backgroundColor: 'var(--accent-primary)', color: 'var(--ai-bubble-text)'}} 
            >
                <svg className="w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M12 4v16m8-8H4"></path></svg> 
                Start New Chat
            </button>


            {/* Conversation Mode Button */}
             <button
                onClick={onOpenConversationMode}
                className="w-full flex items-center justify-center p-3 rounded-xl font-semibold transition-colors mb-4"
                style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-primary)', border: '1px solid var(--border-color)'}}
                title="Start Voice Conversation"
            >
                <svg className="w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                Conversation Mode
            </button>


            {/* History List */}
            <div className="flex-1 overflow-y-auto space-y-2 pr-1">
                <h3 className="text-sm font-semibold uppercase sticky top-0 py-1" style={{color: 'var(--text-secondary)', backgroundColor: 'var(--sidebar-bg)'}}>
                    History ({history.length})
                </h3>
                {loading && <div className="text-sm p-3" style={{color: 'var(--text-secondary)'}}>Loading history...</div>}
                
                {history.length === 0 && !loading && (
                    <div className="text-sm p-3" style={{color: 'var(--text-secondary)'}}>No history found.</div>
                )}
                
                {history.map((chat) => (
                    <div 
                        key={chat.id}
                        className={`group flex items-center justify-between p-3 rounded-lg text-sm transition duration-150 ${
                            chat.id === currentChatId 
                                ? 'font-semibold' 
                                : 'hover:opacity-80'
                        }`}
                        style={{
                            backgroundColor: chat.id === currentChatId ? 'var(--accent-primary)' : 'var(--bg-secondary)',
                            color: chat.id === currentChatId ? 'var(--ai-bubble-text)' : 'var(--text-primary)',
                            cursor: 'pointer'
                        }}
                        title={chat.title}
                    >
                        {/* Title Section (Clickable area to select chat) */}
                        <button
                            onClick={() => onSelectChat(chat.id)}
                            className="flex items-center flex-1 min-w-0 pr-2 text-left"
                            style={{ color: 'inherit', background: 'none', border: 'none', padding: 0 }}
                        >
                            <svg className="w-4 h-4 mr-2 shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M20 12H4M12 4v16"></path></svg>
                            <span className="truncate flex-1">
                                {chat.title}
                            </span>
                        </button>
                        
                        {/* Delete Button (Visible on hover) */}
                        <button
                            onClick={(e) => { e.stopPropagation(); handleDeleteChat(chat.id); }}
                            className={`p-1 rounded transition ml-2 shrink-0 opacity-0 group-hover:opacity-100`}
                            title="Delete Chat"
                            style={{ 
                                color: chat.id === currentChatId ? 'var(--ai-bubble-text)' : 'var(--accent-error)',
                                backgroundColor: chat.id === currentChatId ? 'var(--accent-primary-hover)' : 'transparent',
                            }}
                        >
                            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    </div>
                ))}
            </div>
            
            {/* Footer Area - Collapsible Settings and Auth */}
            <div className="pt-4 border-t mt-4 space-y-2" style={{borderColor: 'var(--sidebar-border)'}}>
                 
                 {/* Settings Toggle Button */}
                 <button 
                    className="w-full flex items-center justify-between p-2 rounded-lg font-semibold transition"
                    onClick={() => setIsSettingsCollapsed(prev => !prev)}
                    style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--text-primary)'}}
                 >
                    <span className="flex items-center gap-2">
                        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{color: 'var(--accent-primary)'}}><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.942 3.333.9 2.456 2.456a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.942 1.543-.9 3.333-2.456 2.456a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.942-3.333-.9-2.456-2.456a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.942-1.543.9-3.333 2.456-2.456a1.724 1.724 0 002.572-1.065z"></path><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                        Settings
                    </span>
                    <svg className={`w-4 h-4 transition-transform ${isSettingsCollapsed ? 'transform rotate-0' : 'transform rotate-180'}`} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 9l-7 7-7-7"></path></svg>
                </button>

                {/* Collapsible Settings Content */}
                <div className={`space-y-3 overflow-hidden transition-all duration-300 ${isSettingsCollapsed ? 'max-h-0' : 'max-h-[800px]'}`}>

                    {/* Quick Prompt/Template Access */}
                    <button 
                        className="w-full text-left text-sm p-2 rounded-lg transition"
                        onClick={() => setIsPromptManagerOpen(true)}
                        style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-secondary)'}}
                    >
                        <span className="font-semibold flex items-center gap-2">
                             <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-2.414-2.414A1 1 0 0015.586 6H7a2 2 0 00-2 2v11a2 2 0 002 2zM17 17H7m10-4H7m4-4H7"></path></svg>
                             Manage Prompts & API Key
                        </span>
                    </button>

                    {/* Model Selector */}
                    <div>
                        <label className="block text-xs font-medium uppercase mb-1" style={{color: 'var(--text-secondary)'}}>AI Model</label>
                        <select
                            value={settings?.globalModel || AVAILABLE_MODELS[0].id}
                            onChange={handleModelChange}
                            className="w-full p-2 rounded-lg border text-sm"
                            style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                        >
                            {AVAILABLE_MODELS.map(model => (
                                <option key={model.id} value={model.id}>{model.name}</option>
                            ))}
                        </select>
                    </div>

                    {/* Theme Selector (Uses the expanded list from ThemeContext) */}
                    <div>
                        <label className="block text-xs font-medium uppercase mb-1" style={{color: 'var(--text-secondary)'}}>Theme</label>
                        <select
                            value={themeName}
                            onChange={handleThemeChange}
                            className="w-full p-2 rounded-lg border text-sm"
                            style={{backgroundColor: 'var(--card-bg)', borderColor: 'var(--border-color)', color: 'var(--text-primary)'}}
                        >
                            {availableThemes.map(theme => (
                                <option key={theme.id} value={theme.id}>{theme.name}</option>
                            ))}
                        </select>
                    </div>

                    {/* Dark/Light Mode Toggle */}
                    <div className="flex items-center justify-between text-sm py-2">
                         <span style={{color: 'var(--text-secondary)'}}>Dark Mode ({themeMode})</span>
                         <label className="relative inline-block w-12 h-6">
                            <input type="checkbox" checked={themeMode === 'dark'} onChange={handleModeToggle} className="opacity-0 w-0 h-0" />
                            <span className="absolute cursor-pointer top-0 left-0 right-0 bottom-0 rounded-full before:absolute before:content-[''] before:h-4 before:w-4 before:left-1 before:bottom-1 before:rounded-full transition duration-400" 
                                style={{
                                    backgroundColor: themeMode === 'dark' ? 'var(--accent-primary)' : 'var(--text-secondary)',
                                    '--tw-translate-x': themeMode === 'dark' ? '24px' : '0',
                                    transition: 'background-color 0.4s, transform 0.4s'
                                } as React.CSSProperties}
                            ></span>
                        </label>
                    </div>

                    {/* Data Management Buttons */}
                    <div className="pt-3 border-t space-y-2" style={{borderColor: 'var(--sidebar-border)'}}>
                        <button 
                            className="w-full text-left text-sm p-2 rounded-lg transition"
                            onClick={handleDeleteAllChats}
                            style={{backgroundColor: 'var(--accent-error)', color: 'white'}}
                        >
                            <span className="font-semibold flex items-center gap-2">
                                <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                Delete All Chats
                            </span>
                        </button>
                        <button 
                            className="w-full text-left text-sm p-2 rounded-lg transition"
                            onClick={handleClearLocalStorage}
                            style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--text-secondary)', border: '1px solid var(--border-color)'}}
                        >
                            <span className="font-semibold flex items-center gap-2">
                                <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M4 7v10m0 0h16M4 17l4-4m-4 4l4 4M20 7v10m0 0H4m16 0l-4-4m4 4l-4 4M12 5v14"></path></svg>
                                Clear Local Cache
                            </span>
                        </button>
                    </div>
                </div>

                {/* Authentication Status */}
                <div className="text-sm border-t pt-4 mt-4" style={{color: 'var(--text-secondary)', borderColor: 'var(--sidebar-border)'}}>
                    <div className="truncate mb-2" style={{color: 'var(--text-primary)'}}>
                         Logged in as: {user?.email || "User"}
                    </div>
                </div>
                <button 
                    className="w-full text-left text-sm p-2 rounded-lg transition hover:bg-red-900/50"
                    onClick={handleSignOut}
                    style={{backgroundColor: 'var(--bg-secondary)', color: 'var(--accent-error)'}}
                >
                    Log out
                </button>
            </div>
        </div>
    );
}

--- END FILE: components\Sidebar.tsx ---

--- START FILE: components\providers\AuthProvider.tsx ---

// components/providers/AuthProvider.tsx
'use client';

import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { User, onAuthStateChanged, signOut as firebaseSignOut } from 'firebase/auth';
import { auth } from '@/utils/firebase';

interface AuthContextType {
  user: User | null;
  loading: boolean;
  getIdToken: () => Promise<string | null>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
      setUser(currentUser);
      setLoading(false);
    });
    return () => unsubscribe();
  }, []);

  const getIdToken = async (): Promise<string | null> => {
    if (user) {
      return await user.getIdToken();
    }
    return null;
  };

  const signOut = async () => {
    await firebaseSignOut(auth);
    // Optionally wipe local state here if needed
  };

  return (
    <AuthContext.Provider value={{ user, loading, getIdToken, signOut }}>
      {children}
    </AuthContext.Provider>
  );
};

--- END FILE: components\providers\AuthProvider.tsx ---

--- START FILE: components\providers\ThemeContext.tsx ---

// components/providers/ThemeContext.tsx
'use client';

import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import { useAuth } from './AuthProvider';
import { UserSettings } from '@/types/chat';

interface ThemeContextType {
  themeName: string;
  themeMode: 'light' | 'dark';
  currentTheme: string; // themeName-themeMode
  settings: UserSettings | null;
  setTheme: (name: string) => void;
  setMode: (mode: 'light' | 'dark') => void;
  updateSettings: (partialSettings: Partial<UserSettings>) => Promise<void>;
  loadingSettings: boolean;
  availableThemes: { id: string; name: string }[];
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Define available themes based on globals.css integration (FULL LIST MERGED)
const THEMES = [
    { id: 'default', name: 'Big AI v2 (Default)' },
    { id: 'celestial-horizon', name: 'Celestial Horizon' },
    { id: 'verdant-calm', name: 'Verdant Calm' },
    { id: 'cybernetic-pulse', name: 'Cybernetic Pulse' },
    { id: 'urban-pulse', name: 'Urban Pulse' },
    { id: 'rustic-ember', name: 'Rustic Ember' },
    { id: 'neon-mirage', name: 'Neon Mirage' },
    { id: 'ivory-bloom', name: 'Ivory Bloom' },
    { id: 'obsidian-night', name: 'Obsidian Night' },
    { id: 'solar-dawn', name: 'Solar Dawn' },
    { id: 'aurora-drift', name: 'Aurora Drift' },
    { id: 'timeless-echo', name: 'Timeless Echo' },
    { id: 'mystic-void', name: 'Mystic Void' },
    { id: 'darkest-bw', name: 'The Darkest Night' },
    { id: 'coder', name: "Coder's Theme" },
    { id: 'cyberpunk', name: 'Cyberpunk Neon' },
    { id: 'matrix', name: 'Matrix Code' },
    { id: 'solarized', name: 'Solarized' },
    { id: 'dracula', name: 'Dracula' },
    { id: 'monokai', name: 'Monokai Pro' },
    { id: 'nord', name: 'Nord' },
    { id: 'gruvbox', name: 'Gruvbox' },
    { id: 'catppuccin', name: 'Catppuccin' },
    { id: 'cosmic-nexus', name: 'Cosmic Nexus' },
    { id: 'starship-minimal', name: 'Starship Minimal' },
    { id: 'offbeat-cosmic', name: 'Offbeat Cosmic Pastels' },
];

export const useTheme = () => {
// ... existing useTheme hook
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

interface ThemeProviderProps {
  children: ReactNode;
}

export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
// ... existing state and effects (fetchSettings, saveSettingsToDB, updateSettings)
  const { user, getIdToken, loading: authLoading } = useAuth();
  const [themeName, setThemeName] = useState<string>('default');
  const [themeMode, setThemeMode] = useState<'light' | 'dark'>('dark');
  const [settings, setSettings] = useState<UserSettings | null>(null);
  const [loadingSettings, setLoadingSettings] = useState(true);

  const currentTheme = `${themeName}-${themeMode}`;
  
  // --- Persistence & Fetching (Same as before) ---
  const fetchSettings = useCallback(async () => {
    // ... (existing implementation)
    if (!user) {
      setLoadingSettings(false);
      return;
    }

    try {
      const token = await getIdToken();
      const response = await fetch('/api/settings', {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (response.ok) {
        const data: UserSettings = await response.json();
        setSettings(data);
        // FIX: Ensure themeName/themeMode default correctly if null from DB
        setThemeName(data.themeName || 'default');
        setThemeMode(data.themeMode || 'dark');
      } else {
        console.error("Failed to fetch user settings.");
      }
    } catch (error) {
      console.error("Error fetching settings:", error);
    } finally {
      setLoadingSettings(false);
    }
  }, [user, getIdToken]);

  const saveSettingsToDB = useCallback(async (partialSettings: Partial<UserSettings>) => {
    // ... (existing implementation)
    if (!user) return;
    try {
      const token = await getIdToken();
      await fetch('/api/settings', {
        method: 'POST',
        headers: { 
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(partialSettings),
      });
    } catch (error) {
      console.error('Failed to save settings to DB:', error);
    }
  }, [user, getIdToken]);

  const updateSettings = useCallback(async (partialSettings: Partial<UserSettings>) => {
    // 1. Update local state
    setSettings(prev => {
        if (!prev) return null;
        const newSettings = { ...prev, ...partialSettings };
        
        // Ensure state updates only happen if values actually change
        if (partialSettings.themeName && partialSettings.themeName !== prev.themeName) setThemeName(partialSettings.themeName);
        if (partialSettings.themeMode && partialSettings.themeMode !== prev.themeMode) setThemeMode(partialSettings.themeMode);

        return newSettings;
    });

    // 3. Persist to database
    await saveSettingsToDB(partialSettings);
  }, [saveSettingsToDB]);


  // --- Theme Controls (Same as before) ---

  const handleSetTheme = useCallback((name: string) => {
    setThemeName(name);
    updateSettings({ themeName: name });
  }, [updateSettings]);

  const handleSetMode = useCallback((mode: 'light' | 'dark') => {
    setThemeMode(mode);
    updateSettings({ themeMode: mode });
  }, [updateSettings]);

  // --- Effects ---

  // 1. Fetch settings on user change/initial load
  useEffect(() => {
    if (user && !authLoading) {
        fetchSettings();
    } else if (!user && !authLoading) {
        // Reset state for non-logged-in users, but keep loading state false
        setSettings(null);
        setThemeName('default');
        setThemeMode('dark');
        setLoadingSettings(false);
    }
  }, [user, authLoading, fetchSettings]);

  // 2. Apply theme to body (CRITICAL FIX: This needs to apply the class name)
  useEffect(() => {
    if (document.body) {
         document.body.setAttribute('data-theme', currentTheme);
    }
  }, [currentTheme]);


  const value = {
    themeName,
    themeMode,
    currentTheme,
    settings,
    loadingSettings,
    setTheme: handleSetTheme,
    setMode: handleSetMode,
    updateSettings,
    availableThemes: THEMES,
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};

--- END FILE: components\providers\ThemeContext.tsx ---

--- START FILE: components\ui\AuthGate.tsx ---

// components/ui/AuthGate.tsx
'use client';

import { useState } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { signInWithEmailAndPassword, createUserWithEmailAndPassword, GoogleAuthProvider, signInWithPopup } from 'firebase/auth';
import { FirebaseError } from 'firebase/app';
import { auth } from '@/utils/firebase';

export default function AuthGate() {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [isRegister, setIsRegister] = useState(false);
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const { loading: authLoading } = useAuth();


    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        try {
            if (isRegister) {
                await createUserWithEmailAndPassword(auth, email, password);
            } else {
                await signInWithEmailAndPassword(auth, email, password);
            }
        } catch (err) {
            console.error(err);
            // FIX: Check if error is a FirebaseError for better typing
            const errorMessage = err instanceof FirebaseError ? err.message : 'Authentication failed.';
            setError(errorMessage);
        } finally {
            setLoading(false);
        }
    };

    const handleGoogleSignIn = async () => {
        setLoading(true);
        setError('');
        try {
            const provider = new GoogleAuthProvider();
            await signInWithPopup(auth, provider);
        } catch (err) {
            const errorMessage = err instanceof FirebaseError ? err.message : 'Google Sign-In failed.';
             setError(errorMessage);
        } finally {
             setLoading(false);
        }
    };

    if (authLoading) {
        return <div className="flex h-screen items-center justify-center bg-gray-900 text-white">Loading Auth...</div>
    }

    return (
        <div className="flex h-screen items-center justify-center bg-gray-900 text-white">
            <div className="w-full max-w-md p-8 space-y-6 bg-gray-800 rounded-xl shadow-2xl">
                <h2 className="text-2xl font-bold text-center">
                    {isRegister ? 'Sign Up for Big AI' : 'Sign In to Big AI'}
                </h2>
                {error && <p className="text-red-400 text-center">{error}</p>}
                
                <form onSubmit={handleSubmit} className="space-y-4">
                    <input
                        type="email"
                        placeholder="Email"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        className="w-full p-3 border border-gray-700 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500"
                        required
                    />
                    <input
                        type="password"
                        placeholder="Password"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        className="w-full p-3 border border-gray-700 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500"
                        required
                    />
                    <button
                        type="submit"
                        disabled={loading}
                        className="w-full p-3 text-white bg-blue-600 rounded-lg hover:bg-blue-700 transition duration-200 disabled:bg-blue-400"
                    >
                        {loading ? 'Processing...' : isRegister ? 'Register' : 'Sign In'}
                    </button>
                </form>

                <div className="relative flex items-center justify-center">
                    <span className="absolute px-3 bg-gray-800 text-gray-400 text-sm">OR</span>
                    <div className="w-full border-t border-gray-700"></div>
                </div>

                <button
                    onClick={handleGoogleSignIn}
                    disabled={loading}
                    className="w-full p-3 flex items-center justify-center gap-2 border border-gray-700 rounded-lg text-gray-300 hover:bg-gray-700 transition disabled:opacity-50"
                >
                    <svg width="20" height="20" viewBox="0 0 48 48"><path fill="#FFC107" d="M43.6 24c0-1.6-.2-3.3-.5-4.9H24v9.2h10.9c-.6 2.9-2.2 5.4-4.7 7.2v6.4h8.2c4.7-4.4 7.4-10.9 7.4-18z"/><path fill="#FF3D00" d="M24 48c6.6 0 12.3-2.2 16.4-6L31.9 35.6c-2.3 1.5-5.2 2.4-8 2.4-6.4 0-11.8-4.3-13.7-10.1h-8.5v6.6C4.8 41.7 13.7 48 24 48z"/><path fill="#4CAF50" d="M10.3 28.5c-.5-1.5-.8-3.1-.8-4.5s.3-3 .8-4.5V13H1.8C.6 15.6 0 18.5 0 24c0 5.5.6 8.4 1.8 11L10.3 28.5z"/><path fill="#1976D2" d="M24 9.6c3.4 0 6.4 1.2 8.8 3.5l7.3-7.3C36.3 3.4 30.5 0 24 0c-10.3 0-19.2 6.3-22.3 15.6l8.5 6.6C12.2 13.9 17.6 9.6 24 9.6z"/></svg>
                    Sign in with Google
                </button>

                <button
                    onClick={() => setIsRegister(p => !p)}
                    className="w-full text-sm text-center text-gray-400 hover:text-blue-500 transition"
                >
                    {isRegister ? 'Already have an account? Sign In' : 'Need an account? Register'}
                </button>
            </div>
        </div>
    );
}

--- END FILE: components\ui\AuthGate.tsx ---

--- START FILE: hooks\useSpeechRecognition.ts ---

// hooks/useSpeechRecognition.ts
import { useState, useEffect, useCallback, useRef } from 'react';

// Define the API global object (must be window.SpeechRecognition or window.webkitSpeechRecognition)
declare global {
    interface Window {
        SpeechRecognition?: SpeechRecognitionAPI;
        webkitSpeechRecognition?: SpeechRecognitionAPI;
    }
}

interface SpeechRecognitionAPI {
    new (): SpeechRecognitionInstance;
}

interface SpeechRecognitionInstance {
    continuous: boolean;
    interimResults: boolean;
    lang: string;
    onstart: ((event: Event) => void) | null;
    onresult: ((event: Event) => void) | null;
    onerror: ((event: Event) => void) | null;
    onend: ((event: Event) => void) | null;
    start(): void;
    stop(): void;
}

const SpeechRecognition = typeof window !== 'undefined' ? window.SpeechRecognition || window.webkitSpeechRecognition : null;

interface SpeechRecognitionOptions {
    continuous?: boolean;
    interimResults?: boolean;
    lang?: string;
    onFinalTranscript?: (transcript: string) => void;
    onInterimTranscript?: (transcript: string) => void;
    onStart?: () => void;
    onEnd?: () => void;
    onError?: (error: string) => void;
}

interface SpeechRecognitionResultItem {
    transcript: string;
    confidence: number;
}

interface SpeechRecognitionResultList {
    [index: number]: SpeechRecognitionResult;
    length: number;
}

interface SpeechRecognitionResult {
    [index: number]: SpeechRecognitionResultItem;
    isFinal: boolean;
    length: number;
}

interface SpeechRecognitionEventResult extends Event {
    resultIndex: number;
    results: SpeechRecognitionResultList;
}

const useSpeechRecognition = (options: SpeechRecognitionOptions = {}) => {
    const {
        continuous = true,
        interimResults = true,
        lang = 'en-US',
        onFinalTranscript,
        onInterimTranscript,
        onStart,
        onEnd,
        onError,
    } = options;

    const recognitionSupported = SpeechRecognition !== null;
    const [isListening, setIsListening] = useState(false);
    const [transcript, setTranscript] = useState('');
    const recognitionRef = useRef<SpeechRecognitionInstance | null>(null);
    const finalTranscriptRef = useRef('');

    const resetTranscript = useCallback(() => {
        setTranscript('');
        finalTranscriptRef.current = '';
    }, []);

    useEffect(() => {
        if (!recognitionSupported || !SpeechRecognition) return;

        const recognition = new SpeechRecognition();
        recognition.continuous = continuous;
        recognition.interimResults = interimResults;
        recognition.lang = lang;

        recognition.onstart = () => {
            setIsListening(true);
            finalTranscriptRef.current = '';
            onStart?.();
        };

        recognition.onresult = (event: Event) => {
            const speechEvent = event as SpeechRecognitionEventResult;
            let interim = '';
            let final = '';

            for (let i = speechEvent.resultIndex; i < speechEvent.results.length; ++i) {
                const result = speechEvent.results[i];
                if (result.isFinal) {
                    final += result[0].transcript + ' ';
                } else {
                    interim += result[0].transcript;
                }
            }

            if (final) {
                finalTranscriptRef.current += final;
                onFinalTranscript?.(finalTranscriptRef.current.trim());
            }
            
            // Update the main transcript state with both final and interim results
            setTranscript((finalTranscriptRef.current + interim).trim());
            onInterimTranscript?.(interim.trim());
        };
        recognition.onerror = (event: Event) => {
            const errorEvent = event as ErrorEvent;
            console.error('Speech recognition error:', event);
            setIsListening(false);
            onError?.(errorEvent.error);
        };

        recognition.onend = () => {
            setIsListening(false);
            // Ensure the final transcript is processed one last time if not already
            if (finalTranscriptRef.current && finalTranscriptRef.current.trim() !== '' && !continuous) {
                onFinalTranscript?.(finalTranscriptRef.current.trim());
            }
            onEnd?.();
        };

        recognitionRef.current = recognition;

        // Cleanup
        return () => {
            recognition.onstart = null;
            recognition.onresult = null;
            recognition.onerror = null;
            recognition.onend = null;
            if (isListening) {
                recognition.stop();
            }
        };
    }, [recognitionSupported, continuous, interimResults, lang, onStart, onEnd, onError, onFinalTranscript, onInterimTranscript]);

    const startListening = useCallback((initialText: string = '') => {
        if (recognitionRef.current && !isListening) {
            // If the user has pre-filled text, treat it as the base
            if (initialText.trim()) {
                 finalTranscriptRef.current = initialText.trim() + ' ';
                 setTranscript(initialText.trim());
            } else {
                 resetTranscript();
            }
            
            try {
                recognitionRef.current.start();
            } catch (e: unknown) {
                // Ignore InvalidStateError if recognition is already running (rare but happens)
                const error = e as Error;
                if (error.name !== 'InvalidStateError') {
                    console.error("Error starting recognition:", e);
                    recognitionRef.current.stop();
                    onError?.(error.message);
                }
            }
        }
    }, [isListening, resetTranscript, onError]);

    const stopListening = useCallback(() => {
        if (recognitionRef.current && isListening) {
            recognitionRef.current.stop();
        }
    }, [isListening]);

    return {
        isListening,
        transcript,
        startListening,
        stopListening,
        recognitionSupported,
        resetTranscript,
    };
};

export default useSpeechRecognition;

--- END FILE: hooks\useSpeechRecognition.ts ---

--- START FILE: lib\firebaseAdmin.ts ---

// lib/firebaseAdmin.ts
import * as admin from 'firebase-admin';
import { NextRequest } from 'next/server';

// Initialize the Admin SDK only if it hasn't been initialized already
if (!admin.apps.length) {
  try {
    const serviceAccountJson = process.env.FIREBASE_SERVICE_ACCOUNT_JSON;
    
    if (!serviceAccountJson) {
        // This is the source of the 500s if db or admin.auth() is called before a return path.
        console.error("CRITICAL: FIREBASE_SERVICE_ACCOUNT_JSON environment variable is NOT set. Server-side persistence will fail.");
    } else {
        const serviceAccount = JSON.parse(serviceAccountJson);
        
        admin.initializeApp({
            credential: admin.credential.cert(serviceAccount),
        });
        console.log("Firebase Admin Initialized successfully.");
    }
  } catch (error) {
    console.error("FATAL: Firebase Admin initialization error. Check FIREBASE_SERVICE_ACCOUNT_JSON format.", error);
    // If initialization fails here, subsequent calls to getAuthId or db will throw.
  }
}

// Check if app is initialized before accessing services
const isInitialized = admin.apps.length > 0;
const db = isInitialized ? admin.firestore() : { collection: () => ({ where: () => ({ orderBy: () => ({ limit: () => ({ get: () => Promise.resolve({ docs: [] }) }) }) }), doc: () => ({ get: () => Promise.resolve(null), set: () => Promise.resolve(), update: () => Promise.resolve() }) }) } as unknown as admin.firestore.Firestore;

// Utility function to verify the user ID from the request
export async function getAuthId(req: NextRequest): Promise<string | null> {
    if (!isInitialized) {
        console.error("Authentication failed: Firebase Admin not initialized.");
        return null;
    }

    const authHeader = req.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return null;
    }
    const token = authHeader.split(' ')[1];
    
    try {
        const decodedToken = await admin.auth().verifyIdToken(token);
        return decodedToken.uid;
    } catch (error) {
        console.error("Token verification failed:", error);
        return null;
    }
}


// Exporting both db and admin
export { db, admin };

--- END FILE: lib\firebaseAdmin.ts ---

--- START FILE: lib\gemini.ts ---

// lib/gemini.ts
import { GoogleGenAI } from '@google/genai';
import { GeminiContent, ChatMessage, TextPart, InlineDataPart } from '@/types/chat'; // Import new specific part types

// We use a specific, high-capability model as requested (though slightly modified name for stability)
const MODEL_NAME = 'gemini-2.5-flash-preview-09-2025'; // <-- UPDATED DEFAULT MODEL NAME

// Initialize Gemini Client
const ai = new GoogleGenAI({});

// Helper function to convert client ChatMessage to GeminiContent
function chatMessageToGeminiContent(msg: ChatMessage): GeminiContent {
    // Use imported types for parts array
    const parts: (TextPart | InlineDataPart)[] = []; 

    // 1. Add text part
    if (msg.text) {
        parts.push({ text: msg.text });
    }

    // 2. Add file parts (multimodal)
    if (msg.files && msg.files.length > 0) {
        msg.files.forEach(file => {
            parts.push({
                inlineData: {
                    data: file.base64Data,
                    mimeType: file.mimeType,
                }
            }); 
        });
    }

    // Now returns the correct structure matching the updated GeminiContent interface
    return {
        role: msg.role,
        parts: parts,
    };
}


/**
 * Transforms client/storage messages into the format the Gemini API expects
 * and generates streaming content.
 * 
 * @param history A list of previous messages in the conversation (including the latest user prompt).
 * @returns A ReadableStream of text chunks.
 */
export async function generateStreamingResponse(
    history: ChatMessage[],
    systemInstruction?: string,
): Promise<ReadableStream<Uint8Array>> {
    
    // 1. Prepare contents array (convert ChatMessages to GeminiContent)
    const contents: GeminiContent[] = history.map(chatMessageToGeminiContent);

    // 2. Call the streaming API
    const responseStream = await ai.models.generateContentStream({
        model: MODEL_NAME, // Uses the updated model constant
        contents: contents,
        config: systemInstruction ? { systemInstruction } : undefined,
    });

    // 3. Convert the response stream to a standard Node.js/Next.js ReadableStream
    const encoder = new TextEncoder();
    
    const stream = new ReadableStream({
        async start(controller) {
            for await (const chunk of responseStream) {
                const text = chunk.text;
                if (text) {
                    controller.enqueue(encoder.encode(text));
                }
            }
            controller.close();
        },
    });

    return stream;
}

--- END FILE: lib\gemini.ts ---

--- START FILE: lib\history.ts ---

// lib/history.ts
import { db, admin } from './firebaseAdmin'; 
import { Conversation, ChatMessage, Role, FileAttachment } from '@/types/chat'; 
import { v4 as uuidv4 } from 'uuid';

const CONVERSATIONS_COLLECTION = 'conversations';

// Define the stored structure (using number for timestamp)
interface FirestoreMessage {
    id: string;
    text: string;
    role: Role;
    timestamp: number;
    files?: FileAttachment[];
}

// Helper to generate a conversational title
function generateTitle(firstMessage: string): string {
    const words = firstMessage.split(/\s+/).slice(0, 6);
    let title = words.join(' ');
    if (words.length > 5) {
        title += '...';
    }
    return title || "New Chat";
}

// Helper function to prepare a ChatMessage for Firestore serialization
function serializeMessage(message: ChatMessage): FirestoreMessage {
    const serialized: FirestoreMessage = {
        id: message.id,
        text: message.text,
        role: message.role,
        timestamp: message.timestamp instanceof Date ? message.timestamp.getTime() : (typeof message.timestamp === 'number' ? message.timestamp : Date.now()),
    };
    
    // CRITICAL: Only include the 'files' field if files exist
    if (message.files && message.files.length > 0) {
        serialized.files = message.files;
    }

    return serialized;
}


/**
 * Retrieves a conversation by its ID.
 */
export async function getConversation(chatId: string, userId: string): Promise<Conversation | null> {
    const docRef = db.collection(CONVERSATIONS_COLLECTION).doc(chatId);
    const doc = await docRef.get();

    if (!doc.exists) {
        return null;
    }
    
    const data = doc.data() as Omit<Conversation, 'messages' | 'createdAt' | 'updatedAt'> & { 
        messages: FirestoreMessage[],
        createdAt: number,
        updatedAt: number,
    };

    // Security check: Ensure the conversation belongs to the authenticated user
    if (data.userId !== userId) {
        console.warn(`Access denied: User ${userId} attempted to access chat ${chatId} belonging to ${data.userId}`);
        return null;
    }
    
    const conversation: Conversation = {
        ...data,
        messages: data.messages.map(m => ({
            ...m,
            timestamp: new Date(m.timestamp), 
        })),
        createdAt: new Date(data.createdAt),
        updatedAt: new Date(data.updatedAt),
    };

    return conversation;
}

/**
 * Creates a new conversation and adds the first message.
 */
export async function createConversation(
    userId: string, 
    firstMessage: string, 
    files: FileAttachment[] = [],
    model?: string, // NEW PARAMETER
    systemPrompt?: string // NEW PARAMETER
): Promise<Conversation> {
    const chatId = uuidv4();
    const now = Date.now();
    
    const userMessage: ChatMessage = {
        id: uuidv4(),
        text: firstMessage,
        role: 'user' as Role,
        timestamp: now,
        files: files.length > 0 ? files : undefined,
    };
    
    const serializedUserMessage = serializeMessage(userMessage);

    // Initial conversation object for Firestore
    const newConversation = {
        id: chatId,
        userId,
        createdAt: now,
        updatedAt: now,
        title: generateTitle(firstMessage), 
        messages: [serializedUserMessage], 
        model: model || 'gemini-2.5-flash-preview-09-2025', 
        ...(systemPrompt && { systemPrompt: systemPrompt }), // Only include if defined
    };

    await db.collection(CONVERSATIONS_COLLECTION).doc(chatId).set(newConversation);

    // Return the client-side Conversation object (with Date objects)
    return {
        ...newConversation,
        messages: [userMessage],
        createdAt: new Date(now),
        updatedAt: new Date(now),
    } as Conversation;
}

/**
 * Appends a new user message and the subsequent AI response to an existing conversation.
 */
export async function updateConversation(
    chatId: string, 
    userText: string, 
    modelText: string,
    userId: string, // Require User ID for security
    files: FileAttachment[] = [],
    isFirstExchange: boolean = false
): Promise<void> {
    
    // First, verify access (Essential Security Check)
    const docRef = db.collection(CONVERSATIONS_COLLECTION).doc(chatId);
    const doc = await docRef.get();
    if (!doc.exists || doc.data()?.userId !== userId) {
        throw new Error("Unauthorized chat update attempt.");
    }
    
    const now = Date.now();
    
    const userMessage: ChatMessage = {
        id: uuidv4(),
        text: userText,
        role: 'user' as Role,
        timestamp: now,
        files: files.length > 0 ? files : undefined,
    };
    
    const modelMessage: ChatMessage = {
        id: uuidv4(),
        text: modelText,
        role: 'model' as Role,
        timestamp: now,
    };

    const serializedUserMessage = serializeMessage(userMessage);
    const serializedModelMessage = serializeMessage(modelMessage);

    const updateData: { messages: admin.firestore.FieldValue; updatedAt: number; title?: string } = {
        messages: admin.firestore.FieldValue.arrayUnion(serializedUserMessage, serializedModelMessage),
        updatedAt: now,
    };

    if (isFirstExchange) {
        updateData.title = generateTitle(userText);
    }
    
    await docRef.update(updateData);
}

/**
 * Deletes a single conversation by its ID. (NEW)
 */
export async function deleteConversation(chatId: string, userId: string): Promise<void> {
    const docRef = db.collection(CONVERSATIONS_COLLECTION).doc(chatId);
    
    // Security check: Verify ownership before deletion
    const doc = await docRef.get();
    if (!doc.exists || doc.data()?.userId !== userId) {
        throw new Error("Unauthorized chat deletion attempt.");
    }

    await docRef.delete();
}


/**
 * Deletes all chats for a user. (Used by the new DELETE /api/chats route)
 */
export async function deleteAllUserConversations(userId: string): Promise<void> {
    const batch = db.batch();
    const snapshot = await db.collection(CONVERSATIONS_COLLECTION)
        .where('userId', '==', userId)
        .get();

    snapshot.docs.forEach(doc => {
        batch.delete(doc.ref);
    });

    await batch.commit();
}

--- END FILE: lib\history.ts ---

--- START FILE: lib\settings.ts ---

// lib/settings.ts
import { db } from './firebaseAdmin';
import { UserSettings, PromptTemplate } from '@/types/chat';

const SETTINGS_COLLECTION = 'user_settings';
const DEFAULT_MODEL = 'gemini-2.5-flash-preview-09-2025';

const DEFAULT_SETTINGS: UserSettings = {
    userId: 'default', 
    globalModel: DEFAULT_MODEL,
    globalSystemPrompt: 'You are Big AI, a helpful and large-scale language model developed by Google. Respond concisely and professionally.',
    themeName: 'default', // NEW
    themeMode: 'dark', // NEW
    apiKey: null, // NEW
    templates: [], // NEW
}

/**
 * Retrieves the global settings for a user, merging with defaults if necessary.
 */
export async function getSettings(userId: string): Promise<UserSettings> {
    const docRef = db.collection(SETTINGS_COLLECTION).doc(userId);
    const doc = await docRef.get();

    if (doc.exists) {
        const storedSettings = doc.data() as UserSettings;
        return { 
            ...DEFAULT_SETTINGS, 
            ...storedSettings, 
            userId,
            globalModel: storedSettings.globalModel || DEFAULT_MODEL, 
            themeMode: storedSettings.themeMode || 'dark',
            themeName: storedSettings.themeName || 'default',
            templates: storedSettings.templates || [],
            apiKey: storedSettings.apiKey || null,
        };
    }

    // If no settings exist, return defaults
    return { ...DEFAULT_SETTINGS, userId };
}

/**
 * Saves or updates the global settings for a user.
 * It uses { merge: true } to prevent overwriting other fields.
 */
export async function saveSettings(userId: string, settings: Partial<UserSettings>): Promise<void> {
    const docRef = db.collection(SETTINGS_COLLECTION).doc(userId);
    
    // Explicitly construct the payload to ensure only defined fields are updated
    const updatePayload: Partial<UserSettings> = {
        userId: userId,
    };
    
    if (settings.globalModel !== undefined) updatePayload.globalModel = settings.globalModel;
    if (settings.globalSystemPrompt !== undefined) updatePayload.globalSystemPrompt = settings.globalSystemPrompt;
    if (settings.themeName !== undefined) updatePayload.themeName = settings.themeName;
    if (settings.themeMode !== undefined) updatePayload.themeMode = settings.themeMode;
    if (settings.apiKey !== undefined) updatePayload.apiKey = settings.apiKey;
    if (settings.templates !== undefined) updatePayload.templates = settings.templates;
    
    await docRef.set(updatePayload, { merge: true });
}

--- END FILE: lib\settings.ts ---

--- START FILE: public\file.svg ---

<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

--- END FILE: public\file.svg ---

--- START FILE: public\globe.svg ---

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

--- END FILE: public\globe.svg ---

--- START FILE: public\next.svg ---

<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

--- END FILE: public\next.svg ---

--- START FILE: public\vercel.svg ---

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

--- END FILE: public\vercel.svg ---

--- START FILE: public\window.svg ---

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

--- END FILE: public\window.svg ---

--- START FILE: types\chat.ts ---

// types/chat.ts

export type Role = 'user' | 'model';

export interface FileAttachment {
    base64Data: string; // Base64 encoded file content
    mimeType: string;
    filename: string;
    size: number; // File size in bytes
}

export interface ChatMessage {
    id: string; // UUID for message
    text: string;
    role: Role;
    timestamp: Date | number; // Use number (milliseconds) for Firestore
    files?: FileAttachment[]; // NEW: Optional files sent with the message
}

export interface Conversation {
    id: string; // UUID for conversation
    userId: string; // Required when Auth is implemented
    createdAt: Date | number;
    updatedAt: Date | number;
    title: string;
    messages: ChatMessage[];
    model?: string;
    systemPrompt?: string;
}

// NEW: Prompt Template structure
export interface PromptTemplate {
    id: string;
    name: string;
    content: string;
    model?: string;
}

// Global User Settings
export interface UserSettings {
    userId: string;
    globalModel: string;
    globalSystemPrompt: string;
    themeName: string; // NEW
    themeMode: 'light' | 'dark'; // NEW
    apiKey?: string | null; // NEW: Stored Gemini API Key
    templates?: PromptTemplate[]; // NEW: Stored templates
}

// --- Gemini Types ---
export interface TextPart {
    text: string;
}

export interface InlineDataPart {
    inlineData: {
        data: string; // Base64 content
        mimeType: string;
    };
}

export interface GeminiContent {
    role: 'user' | 'model';
    parts: (TextPart | InlineDataPart)[]; 
}

--- END FILE: types\chat.ts ---

--- START FILE: utils\firebase.ts ---

// utils/firebase.ts
import { initializeApp, getApps, getApp } from 'firebase/app';
import { getFirestore } from 'firebase/firestore';
import { getAuth } from 'firebase/auth';

// Ensure all environment variables are present for client-side config
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,
};

// Initialize Firebase for Client Use
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();
export const db = getFirestore(app);
export const auth = getAuth(app);
// Expose the app instance if needed for context
export { app };


--- END FILE: utils\firebase.ts ---

-------------------------------------------------------------------------------

part 2 : 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Small AI v2</title>
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <!-- Favicon -->
    <link rel="icon" href="logo.png" type="image/x-icon">
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter for modern typography, Fira Code for monospace code -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap" rel="stylesheet">
    <!-- Marked.js CDN for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Lucide Icons for a modern, futuristic feel -->
    <script src="https://cdn.jsdelivr.net/npm/lucide-dynamic@latest/dist/lucide.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- NEW: Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>

    <!-- Prism.js for syntax highlighting -->
    <!-- FIX: Load Prism CORE first -->
    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script> -->
    <!-- Dynamically load dark or light Prism theme based on app theme -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" rel="stylesheet" id="prism-dark-theme" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" id="prism-light-theme" disabled />
    <!-- Include common languages (adjust as needed) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-html.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
    <style>
        /*
        * --- Custom Styles for AI Chat Assistant (Enhanced) ---
        */
        
        /* Base font and transition settings for the whole page */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; 
        }
        
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.6s ease, color 0.6s ease;
            display: flex; 
            color: var(--text-primary); 
        }

        /* --- Theme Definitions --- */
        
        /* Default Theme: Light Mode */
        body[data-theme="default-light"] {
            --bg-primary: #f3f4f6;
            --bg-secondary: #ffffff;
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-color: #e5e7eb;
            --card-bg: #ffffff;
            --card-border: #e5e7eb;
            --header-bg: #f9fafb;
            --accent-primary: #6366f1;
            --accent-primary-hover: #4f46e5;
            --accent-secondary: #22d3ee;
            --accent-error: #ef4444;
            --accent-success: #22c55e;
            --user-bubble-bg: #e0f2fe;
            --user-bubble-text: #1e40af;
            --ai-bubble-bg: #f3f4f6;
            --ai-bubble-text: #374151;
            --sidebar-bg: #ffffff;
            --sidebar-border: #e5e7eb;
            --sidebar-item-hover: #f3f4f6;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #1f2937;
            --conversation-indicator: #6366f1;
            --code-block-bg: #f5f7fa;
            --code-block-header-bg: #e8ebf0;
            --code-block-border: #e2e4e8;

            background-color: var(--bg-primary);
        }

        /* Default Theme: Dark Mode */
        body[data-theme="default-dark"] {
            --bg-primary: #0a0a0f;
            --bg-secondary: #13131a;
            --text-primary: #e5e7eb;
            --text-secondary: #a1a1aa;
            --border-color: #2d3748;
            --card-bg: #13131a;
            --card-border: #2d3748;
            --header-bg: #1f2937;
            --accent-primary: #818cf8;
            --accent-primary-hover: #6366f1;
            --accent-secondary: #67e8f9;
            --accent-error: #f87171;
            --accent-success: #4ade80;
            --user-bubble-bg: #1a237e;
            --user-bubble-text: #e0e7ff;
            --ai-bubble-bg: #2d3748;
            --ai-bubble-text: #f9fafb;
            --sidebar-bg: #13131a;
            --sidebar-border: #2d3748;
            --sidebar-item-hover: #1f2937;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(19, 19, 26, 0.9);
            --conversation-bg: rgba(19, 19, 26, 0.95);
            --conversation-text: #e5e7eb;
            --conversation-indicator: #818cf8;
            --code-block-bg: #1f2937;
            --code-block-header-bg: #13131a;
            --code-block-border: #2d3748;

            background-color: var(--bg-primary);
        }

        /* Celestial Horizon Theme: Dark Mode */
        body[data-theme="celestial-horizon-dark"] {
            --bg-primary: #0D1117;
            --bg-secondary: #161B22;
            --text-primary: #C9D1D9;
            --text-secondary: #8B949E;
            --border-color: #30363D;
            --card-bg: #1F2633;
            --card-border: #30363D;
            --header-bg: #161B22;
            --accent-primary: #58A6FF;
            --accent-primary-hover: #388BF2;
            --accent-secondary: #B1B8C1;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #253B64;
            --user-bubble-text: #E0F2FE;
            --ai-bubble-bg: #1F2633;
            --ai-bubble-text: #C9D1D9;
            --sidebar-bg: #161B22;
            --sidebar-border: #30363D;
            --sidebar-item-hover: #1F2633;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(22, 27, 34, 0.9);
            --conversation-bg: rgba(22, 27, 34, 0.95);
            --conversation-text: #C9D1D9;
            --conversation-indicator: #58A6FF;
            --code-block-bg: #1F2633;
            --code-block-header-bg: #161B22;
            --code-block-border: #30363D;

            background-color: var(--bg-primary);
        }

        /* Celestial Horizon Theme: Light Mode */
        body[data-theme="celestial-horizon-light"] {
            --bg-primary: #F0F4F8;
            --bg-secondary: #FFFFFF;
            --text-primary: #2D3748;
            --text-secondary: #718096;
            --border-color: #E2E8F0;
            --card-bg: #FFFFFF;
            --card-border: #E2E8F0;
            --header-bg: #EDF2F7;
            --accent-primary: #3B82F6;
            --accent-primary-hover: #2563EB;
            --accent-secondary: #60A5FA;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #DBEAFE;
            --user-bubble-text: #1E40AF;
            --ai-bubble-bg: #EBF4FF;
            --ai-bubble-text: #2D3748;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E2E8F0;
            --sidebar-item-hover: #F0F4F8;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #2D3748;
            --conversation-indicator: #3B82F6;
            --code-block-bg: #EBF4FF;
            --code-block-header-bg: #EDF2F7;
            --code-block-border: #E2E8F0;

            background-color: var(--bg-primary);
        }

        /* Verdant Calm Theme: Dark Mode (Renamed from Forest Whisper) */
        body[data-theme="verdant-calm-dark"] {
            --bg-primary: #1a2a22;
            --bg-secondary: #21362d;
            --text-primary: #e0f2e8;
            --text-secondary: #99bbaa;
            --border-color: #3f544c;
            --card-bg: #294237;
            --card-border: #4a6356;
            --header-bg: #2c493c;
            --accent-primary: #3cb878;
            --accent-primary-hover: #2fa163;
            --accent-secondary: #60c58e;
            --accent-error: #f87171;
            --accent-success: #4ade80;
            --user-bubble-bg: #1e8449;
            --user-bubble-text: #e0f2e8;
            --ai-bubble-bg: #34495e;
            --ai-bubble-text: #e0f2e8;
            --sidebar-bg: #21362d;
            --sidebar-border: #3f544c;
            --sidebar-item-hover: #2c493c;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(33, 54, 45, 0.9);
            --conversation-bg: rgba(33, 54, 45, 0.95);
            --conversation-text: #e0f2e8;
            --conversation-indicator: #3cb878;
            --code-block-bg: #34495e;
            --code-block-header-bg: #2c493c;
            --code-block-border: #3f544c;

            background-color: var(--bg-primary);
        }

        /* Verdant Calm Theme: Light Mode */
        body[data-theme="verdant-calm-light"] {
            --bg-primary: #edf9f5;
            --bg-secondary: #ffffff;
            --text-primary: #2d3f35;
            --text-secondary: #5e7d6b;
            --border-color: #dbeae5;
            --card-bg: #ffffff;
            --card-border: #dbeae5;
            --header-bg: #f5fcf9;
            --accent-primary: #3cb878;
            --accent-primary-hover: #2fa163;
            --accent-secondary: #60c58e;
            --accent-error: #ef4444;
            --accent-success: #22c55e;
            --user-bubble-bg: #c8e6c9;
            --user-bubble-text: #1b5e20;
            --ai-bubble-bg: #e8f5e9;
            --ai-bubble-text: #388e3c;
            --sidebar-bg: #ffffff;
            --sidebar-border: #dbeae5;
            --sidebar-item-hover: #edf9f5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #2d3f35;
            --conversation-indicator: #3cb878;
            --code-block-bg: #e8f5e9;
            --code-block-header-bg: #f5fcf9;
            --code-block-border: #dbeae5;

            background-color: var(--bg-primary);
        }

        /* Cybernetic Pulse Theme: Dark Mode */
        body[data-theme="cybernetic-pulse-dark"] {
            --bg-primary: #0a0e1a;
            --bg-secondary: #161c28;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --border-color: #2f3e52;
            --card-bg: #1f2a3a;
            --card-border: #3a4b5e;
            --header-bg: #1f2a3a;
            --accent-primary: #0ea5e9;
            --accent-primary-hover: #0284c7;
            --accent-secondary: #38bdf8;
            --accent-error: #f87171;
            --accent-success: #4ade80;
            --user-bubble-bg: #0c4a6e;
            --user-bubble-text: #e0f2fe;
            --ai-bubble-bg: #2d3748;
            --ai-bubble-text: #f0f8ff;
            --sidebar-bg: #161c28;
            --sidebar-border: #2f3e52;
            --sidebar-item-hover: #1f2a3a;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(22, 28, 40, 0.9);
            --conversation-bg: rgba(22, 28, 40, 0.95);
            --conversation-text: #e2e8f0;
            --conversation-indicator: #0ea5e9;
            --code-block-bg: #2d3748;
            --code-block-header-bg: #1f2a3a;
            --code-block-border: #2f3e52;

            background-color: var(--bg-primary);
        }

        /* Cybernetic Pulse Theme: Light Mode */
        body[data-theme="cybernetic-pulse-light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --border-color: #e0e7f2;
            --card-bg: #ffffff;
            --card-border: #e0e7f2;
            --header-bg: #f1f5f9;
            --accent-primary: #0ea5e9;
            --accent-primary-hover: #0284c7;
            --accent-secondary: #38bdf8;
            --accent-error: #ef4444;
            --accent-success: #22c55e;
            --user-bubble-bg: #bfdbfe;
            --user-bubble-text: #1e3a8a;
            --ai-bubble-bg: #e0f2fe;
            --ai-bubble-text: #0284c7;
            --sidebar-bg: #ffffff;
            --sidebar-border: #e0e7f2;
            --sidebar-item-hover: #f1f5f9;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #1e293b;
            --conversation-indicator: #0ea5e9;
            --code-block-bg: #e0f2fe;
            --code-block-header-bg: #f1f5f9;
            --code-block-border: #e0e7f2;

            background-color: var(--bg-primary);
        }

        /* Urban Pulse Theme: Dark Mode */
        body[data-theme="urban-pulse-dark"] {
            --bg-primary: #1A1A1D;
            --bg-secondary: #242426;
            --text-primary: #F0F0F0;
            --text-secondary: #A0A0A0;
            --border-color: #38383B;
            --card-bg: #242426;
            --card-border: #38383B;
            --header-bg: #1A1A1D;
            --accent-primary: #00BFFF;
            --accent-primary-hover: #009ACD;
            --accent-secondary: #66CCFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #0F4C81;
            --user-bubble-text: #E0FFFF;
            --ai-bubble-bg: #36454F;
            --ai-bubble-text: #F0F0F0;
            --sidebar-bg: #1A1A1D;
            --sidebar-border: #38383B;
            --sidebar-item-hover: #242426;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(36, 36, 38, 0.9);
            --conversation-bg: rgba(36, 36, 38, 0.95);
            --conversation-text: #F0F0F0;
            --conversation-indicator: #00BFFF;
            --code-block-bg: #36454F;
            --code-block-header-bg: #1A1A1D;
            --code-block-border: #38383B;

            background-color: var(--bg-primary);
        }

        /* Urban Pulse Theme: Light Mode */
        body[data-theme="urban-pulse-light"] {
            --bg-primary: #F2F4F8;
            --bg-secondary: #FFFFFF;
            --text-primary: #333333;
            --text-secondary: #777777;
            --border-color: #DDE2E8;
            --card-bg: #FFFFFF;
            --card-border: #DDE2E8;
            --header-bg: #E8ECF2;
            --accent-primary: #1E90FF;
            --accent-primary-hover: #107EEB;
            --accent-secondary: #63B2FF;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #CCE5FF;
            --user-bubble-text: #003F8C;
            --ai-bubble-bg: #E8F0F5;
            --ai-bubble-text: #333333;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #DDE2E8;
            --sidebar-item-hover: #E8F0F5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #333333;
            --conversation-indicator: #1E90FF;
            --code-block-bg: #E8F0F5;
            --code-block-header-bg: #E8ECF2;
            --code-block-border: #DDE2E8;

            background-color: var(--bg-primary);
        }

        /* Rustic Ember Theme: Dark Mode */
        body[data-theme="rustic-ember-dark"] {
            --bg-primary: #3E2723;
            --bg-secondary: #4E342E;
            --text-primary: #FBE9E7;
            --text-secondary: #BCAAA4;
            --border-color: #5D4037;
            --card-bg: #4E342E;
            --card-border: #5D4037;
            --header-bg: #3E2723;
            --accent-primary: #D84315;
            --accent-primary-hover: #BF360C;
            --accent-secondary: #FF8A65;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #8D6E63;
            --user-bubble-text: #FBE9E7;
            --ai-bubble-bg: #5D4037;
            --ai-bubble-text: #FBE9E7;
            --sidebar-bg: #3E2723;
            --sidebar-border: #5D4037;
            --sidebar-item-hover: #4E342E;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(78, 52, 46, 0.9);
            --conversation-bg: rgba(78, 52, 46, 0.95);
            --conversation-text: #FBE9E7;
            --conversation-indicator: #D84315;
            --code-block-bg: #5D4037;
            --code-block-header-bg: #3E2723;
            --code-block-border: #5D4037;

            background-color: var(--bg-primary);
        }

        /* Rustic Ember Theme: Light Mode */
        body[data-theme="rustic-ember-light"] {
            --bg-primary: #F5E8DC;
            --bg-secondary: #FFFFFF;
            --text-primary: #4E342E;
            --text-secondary: #8D6E63;
            --border-color: #E6DCCD;
            --card-bg: #FFFFFF;
            --card-border: #E6DCCD;
            --header-bg: #F8EFE5;
            --accent-primary: #E65100;
            --accent-primary-hover: #D84315;
            --accent-secondary: #FFB74D;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #FFCCBC;
            --user-bubble-text: #BF360C;
            --ai-bubble-bg: #FBE9E7;
            --ai-bubble-text: #4E342E;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E6DCCD;
            --sidebar-item-hover: #F8EFE5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #4E342E;
            --conversation-indicator: #E65100;
            --code-block-bg: #FBE9E7;
            --code-block-header-bg: #F8EFE5;
            --code-block-border: #E6DCCD;

            background-color: var(--bg-primary);
        }

        /* Neon Mirage Theme: Dark Mode */
        body[data-theme="neon-mirage-dark"] {
            --bg-primary: #05001C;
            --bg-secondary: #120033;
            --text-primary: #E0FFFF;
            --text-secondary: #8A2BE2;
            --border-color: #2F004F;
            --card-bg: #1A0040;
            --card-border: #2F004F;
            --header-bg: #120033;
            --accent-primary: #FF1493;
            --accent-primary-hover: #C7007C;
            --accent-secondary: #00BFFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #4B0082;
            --user-bubble-text: #E0FFFF;
            --ai-bubble-bg: #2E0854;
            --ai-bubble-text: #E0FFFF;
            --sidebar-bg: #120033;
            --sidebar-border: #2F004F;
            --sidebar-item-hover: #1A0040;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(26, 0, 64, 0.9);
            --conversation-bg: rgba(26, 0, 64, 0.95);
            --conversation-text: #E0FFFF;
            --conversation-indicator: #FF1493;
            --code-block-bg: #2E0854;
            --code-block-header-bg: #120033;
            --code-block-border: #2F004F;

            background-color: var(--bg-primary);
        }

        /* Neon Mirage Theme: Light Mode */
        body[data-theme="neon-mirage-light"] {
            --bg-primary: #F8F0FF;
            --bg-secondary: #FFFFFF;
            --text-primary: #330066;
            --text-secondary: #663399;
            --border-color: #EBD9FC;
            --card-bg: #FFFFFF;
            --card-border: #EBD9FC;
            --header-bg: #F2E0FF;
            --accent-primary: #FF69B4;
            --accent-primary-hover: #E0509B;
            --accent-secondary: #87CEEB;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #FCE4EC;
            --user-bubble-text: #C2185B;
            --ai-bubble-bg: #F3E5F5;
            --ai-bubble-text: #330066;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #EBD9FC;
            --sidebar-item-hover: #F2E0FF;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #330066;
            --conversation-indicator: #FF69B4;
            --code-block-bg: #F3E5F5;
            --code-block-header-bg: #F2E0FF;
            --code-block-border: #EBD9FC;

            background-color: var(--bg-primary);
        }

        /* Ivory Bloom Theme: Dark Mode */
        body[data-theme="ivory-bloom-dark"] {
            --bg-primary: #2B2D42;
            --bg-secondary: #4A4E69;
            --text-primary: #DCDCDC;
            --text-secondary: #A0A4B8;
            --border-color: #5D607E;
            --card-bg: #4A4E69;
            --card-border: #5D607E;
            --header-bg: #373A50;
            --accent-primary: #9B59B6;
            --accent-primary-hover: #8E44AD;
            --accent-secondary: #66CCFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #7C4F9B;
            --user-bubble-text: #FFFFFF;
            --ai-bubble-bg: #5D607E;
            --ai-bubble-text: #DCDCDC;
            --sidebar-bg: #2B2D42;
            --sidebar-border: #5D607E;
            --sidebar-item-hover: #373A50;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(74, 78, 105, 0.9);
            --conversation-bg: rgba(74, 78, 105, 0.95);
            --conversation-text: #DCDCDC;
            --conversation-indicator: #9B59B6;
            --code-block-bg: #5D607E;
            --code-block-header-bg: #373A50;
            --code-block-border: #5D607E;

            background-color: var(--bg-primary);
        }

        /* Ivory Bloom Theme: Light Mode */
        body[data-theme="ivory-bloom-light"] {
            --bg-primary: #FDFDFD;
            --bg-secondary: #FFFFFF;
            --text-primary: #333333;
            --text-secondary: #777777;
            --border-color: #EAEAEA;
            --card-bg: #FFFFFF;
            --card-border: #EAEAEA;
            --header-bg: #F5F5F5;
            --accent-primary: #8E44AD;
            --accent-primary-hover: #7F3C9E;
            --accent-secondary: #BA68C8;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #F2E6F7;
            --user-bubble-text: #5D2C7B;
            --ai-bubble-bg: #EAE0F0;
            --ai-bubble-text: #333333;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #EAEAEA;
            --sidebar-item-hover: #F5F5F5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #333333;
            --conversation-indicator: #8E44AD;
            --code-block-bg: #EAE0F0;
            --code-block-header-bg: #F5F5F5;
            --code-block-border: #EAEAEA;

            background-color: var(--bg-primary);
        }

        /* Obsidian Night Theme: Dark Mode */
        body[data-theme="obsidian-night-dark"] {
            --bg-primary: #121212;
            --bg-secondary: #1E1E1E;
            --text-primary: #F0F0F0;
            --text-secondary: #A0A0A0;
            --border-color: #333333;
            --card-bg: #1E1E1E;
            --card-border: #333333;
            --header-bg: #121212;
            --accent-primary: #BB86FC;
            --accent-primary-hover: #9E65E2;
            --accent-secondary: #03DAC6;
            --accent-error: #CF6679;
            --accent-success: #03DAC6;
            --user-bubble-bg: #3700B3;
            --user-bubble-text: #FFFFFF;
            --ai-bubble-bg: #2C2C2C;
            --ai-bubble-text: #F0F0F0;
            --sidebar-bg: #121212;
            --sidebar-border: #333333;
            --sidebar-item-hover: #1E1E1E;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(30, 30, 30, 0.9);
            --conversation-bg: rgba(30, 30, 30, 0.95);
            --conversation-text: #F0F0F0;
            --conversation-indicator: #BB86FC;
            --code-block-bg: #2C2C2C;
            --code-block-header-bg: #121212;
            --code-block-border: #333333;

            background-color: var(--bg-primary);
        }

        /* Obsidian Night Theme: Light Mode */
        body[data-theme="obsidian-night-light"] {
            --bg-primary: #E0E0E0;
            --bg-secondary: #FFFFFF;
            --text-primary: #2C2C2C;
            --text-secondary: #6B6B6B;
            --border-color: #C0C0C0;
            --card-bg: #FFFFFF;
            --card-border: #C0C0C0;
            --header-bg: #D0D0D0;
            --accent-primary: #6200EE;
            --accent-primary-hover: #5B00D9;
            --accent-secondary: #018786;
            --accent-error: #B00020;
            --accent-success: #018786;
            --user-bubble-bg: #BBDEFB;
            --user-bubble-text: #1A237E;
            --ai-bubble-bg: #E0E0E0;
            --ai-bubble-text: #2C2C2C;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #C0C0C0;
            --sidebar-item-hover: #D0D0D0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #2C2C2C;
            --conversation-indicator: #6200EE;
            --code-block-bg: #E0E0E0;
            --code-block-header-bg: #D0D0D0;
            --code-block-border: #C0C0C0;

            background-color: var(--bg-primary);
        }

        /* Solar Dawn Theme: Dark Mode */
        body[data-theme="solar-dawn-dark"] {
            --bg-primary: #1A0E2A;
            --bg-secondary: #2C1840;
            --text-primary: #FCE8D8;
            --text-secondary: #D8BFD8;
            --border-color: #40265B;
            --card-bg: #2C1840;
            --card-border: #40265B;
            --header-bg: #1A0E2A;
            --accent-primary: #FF5722;
            --accent-primary-hover: #E64A19;
            --accent-secondary: #FFCC80;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #7C4F9B;
            --user-bubble-text: #FCE8D8;
            --ai-bubble-bg: #40265B;
            --ai-bubble-text: #FCE8D8;
            --sidebar-bg: #1A0E2A;
            --sidebar-border: #40265B;
            --sidebar-item-hover: #2C1840;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(44, 24, 64, 0.9);
            --conversation-bg: rgba(44, 24, 64, 0.95);
            --conversation-text: #FCE8D8;
            --conversation-indicator: #FF5722;
            --code-block-bg: #40265B;
            --code-block-header-bg: #1A0E2A;
            --code-block-border: #40265B;

            background-color: var(--bg-primary);
        }

        /* Solar Dawn Theme: Light Mode */
        body[data-theme="solar-dawn-light"] {
            --bg-primary: #FFFBEA;
            --bg-secondary: #FFFFFF;
            --text-primary: #3E2723;
            --text-secondary: #8D6E63;
            --border-color: #FFE0B2;
            --card-bg: #FFFFFF;
            --card-border: #FFE0B2;
            --header-bg: #FFF3E0;
            --accent-primary: #FF8F00;
            --accent-primary-hover: #FF6F00;
            --accent-secondary: #FFD54F;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #FFE0B2;
            --user-bubble-text: #E65100;
            --ai-bubble-bg: #FFF3E0;
            --ai-bubble-text: #3E2723;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #FFE0B2;
            --sidebar-item-hover: #FFF3E0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #3E2723;
            --conversation-indicator: #FF8F00;
            --code-block-bg: #FFF3E0;
            --code-block-header-bg: #FFFBEA;
            --code-block-border: #FFE0B2;

            background-color: var(--bg-primary);
        }

        /* Aurora Drift Theme: Dark Mode */
        body[data-theme="aurora-drift-dark"] {
            --bg-primary: #0A192F;
            --bg-secondary: #172A45;
            --text-primary: #E6F0FF;
            --text-secondary: #A0B3D6;
            --border-color: #2F476D;
            --card-bg: #172A45;
            --card-border: #2F476D;
            --header-bg: #0A192F;
            --accent-primary: #66CCCC;
            --accent-primary-hover: #55B3B3;
            --accent-secondary: #99CCFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #336699;
            --user-bubble-text: #E6F0FF;
            --ai-bubble-bg: #2F476D;
            --ai-bubble-text: #E6F0FF;
            --sidebar-bg: #0A192F;
            --sidebar-border: #2F476D;
            --sidebar-item-hover: #172A45;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(23, 42, 69, 0.9);
            --conversation-bg: rgba(23, 42, 69, 0.95);
            --conversation-text: #E6F0FF;
            --conversation-indicator: #66CCCC;
            --code-block-bg: #2F476D;
            --code-block-header-bg: #0A192F;
            --code-block-border: #2F476D;

            background-color: var(--bg-primary);
        }

        /* Aurora Drift Theme: Light Mode */
        body[data-theme="aurora-drift-light"] {
            --bg-primary: #E0F2F7;
            --bg-secondary: #FFFFFF;
            --text-primary: #2B4550;
            --text-secondary: #5E7A8A;
            --border-color: #B2EBF2;
            --card-bg: #FFFFFF;
            --card-border: #B2EBF2;
            --header-bg: #CCEEF0;
            --accent-primary: #00BCD4;
            --accent-primary-hover: #00ACC1;
            --accent-secondary: #4DD0E1;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #B2EBF2;
            --user-bubble-text: #006064;
            --ai-bubble-bg: #CCEEF0;
            --ai-bubble-text: #2B4550;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #B2EBF2;
            --sidebar-item-hover: #CCEEF0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #2B4550;
            --conversation-indicator: #00BCD4;
            --code-block-bg: #CCEEF0;
            --code-block-header-bg: #E0F2F7;
            --code-block-border: #B2EBF2;

            background-color: var(--bg-primary);
        }
        /* Removed @keyframes aurora-move */

        /* Timeless Echo Theme: Dark Mode */
        body[data-theme="timeless-echo-dark"] {
            --bg-primary: #2C2C2C;
            --bg-secondary: #3D3D3D;
            --text-primary: #E0E0E0;
            --text-secondary: #B0B0B0;
            --border-color: #555555;
            --card-bg: #3D3D3D;
            --card-border: #555555;
            --header-bg: #2C2C2C;
            --accent-primary: #A57C52;
            --accent-primary-hover: #8B653D;
            --accent-secondary: #C8A87C;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #785A3D;
            --user-bubble-text: #E0E0E0;
            --ai-bubble-bg: #555555;
            --ai-bubble-text: #E0E0E0;
            --sidebar-bg: #2C2C2C;
            --sidebar-border: #555555;
            --sidebar-item-hover: #3D3D3D;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(61, 61, 61, 0.9);
            --conversation-bg: rgba(61, 61, 61, 0.95);
            --conversation-text: #E0E0E0;
            --conversation-indicator: #A57C52;
            --code-block-bg: #555555;
            --code-block-header-bg: #2C2C2C;
            --code-block-border: #555555;

            background-color: var(--bg-primary);
        }

        /* Timeless Echo Theme: Light Mode */
        body[data-theme="timeless-echo-light"] {
            --bg-primary: #FDF7E5;
            --bg-secondary: #FFFFFF;
            --text-primary: #4A4A4A;
            --text-secondary: #808080;
            --border-color: #E6E0D3;
            --card-bg: #FFFFFF;
            --card-border: #E6E0D3;
            --header-bg: #F5EFEB;
            --accent-primary: #8D6E63;
            --accent-primary-hover: #795548;
            --accent-secondary: #BCAAA4;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #D7CCC8;
            --user-bubble-text: #5D4037;
            --ai-bubble-bg: #EFEBE9;
            --ai-bubble-text: #4A4A4A;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E6E0D3;
            --sidebar-item-hover: #F5EFEB;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #4A4A4A;
            --conversation-indicator: #8D6E63;
            --code-block-bg: #EFEBE9;
            --code-block-header-bg: #F5EFEB;
            --code-block-border: #E6E0D3;

            background-color: var(--bg-primary);
        }

        /* Mystic Void Theme: Dark Mode (Bonus Theme) */
        body[data-theme="mystic-void-dark"] {
            --bg-primary: #110B1D;
            --bg-secondary: #1F1731;
            --text-primary: #ECE4F7;
            --text-secondary: #B29BCE;
            --border-color: #372A4F;
            --card-bg: #1F1731;
            --card-border: #372A4F;
            --header-bg: #110B1D;
            --accent-primary: #9400D3;
            --accent-primary-hover: #7B00B0;
            --accent-secondary: #8A2BE2;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #5B2C7B;
            --user-bubble-text: #ECE4F7;
            --ai-bubble-bg: #372A4F;
            --ai-bubble-text: #ECE4F7;
            --sidebar-bg: #110B1D;
            --sidebar-border: #372A4F;
            --sidebar-item-hover: #1F1731;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(31, 23, 49, 0.9);
            --conversation-bg: rgba(31, 23, 49, 0.95);
            --conversation-text: #ECE4F7;
            --conversation-indicator: #9400D3;
            --code-block-bg: #372A4F;
            --code-block-header-bg: #110B1D;
            --code-block-border: #372A4F;

            background-color: var(--bg-primary);
        }

        /* Mystic Void Theme: Light Mode */
        body[data-theme="mystic-void-light"] {
            --bg-primary: #F7EDFF;
            --bg-secondary: #FFFFFF;
            --text-primary: #330066;
            --text-secondary: #663399;
            --border-color: #EBD9FC;
            --card-bg: #FFFFFF;
            --card-border: #EBD9FC;
            --header-bg: #F2E0FF;
            --accent-primary: #8A2BE2;
            --accent-primary-hover: #7B1FB2;
            --accent-secondary: #9370DB;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #E6D2F2;
            --user-bubble-text: #4B0082;
            --ai-bubble-bg: #F0E6F8;
            --ai-bubble-text: #330066;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #EBD9FC;
            --sidebar-item-hover: #F2E0FF;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #330066;
            --conversation-indicator: #8A2BE2;
            --code-block-bg: #F0E6F8;
            --code-block-header-bg: #F2E0FF;
            --code-block-border: #EBD9FC;

            background-color: var(--bg-primary);
        }

        /* Darkest Black & White Theme: Dark Mode (Corrected Bubbles & Icons) */
        body[data-theme="darkest-bw-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #111111;
            --text-primary: #FFFFFF;
            --text-secondary: #AAAAAA;
            --border-color: #333333;
            --card-bg: #111111;
            --card-border: #333333;
            --header-bg: #0A0A0A;
            --accent-primary: #E0E0E0;
            --accent-primary-hover: #FFFFFF;
            --accent-secondary: #888888;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #222222;
            --user-bubble-text: #FFFFFF;
            --ai-bubble-bg: #333333;
            --ai-bubble-text: #FFFFFF;
            --sidebar-bg: #000000;
            --sidebar-border: #333333;
            --sidebar-item-hover: #111111;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: #000000;
            --conversation-bg: #000000;
            --conversation-text: #FFFFFF;
            --conversation-indicator: #FFFFFF;
            --code-block-bg: #333333;
            --code-block-header-bg: #0A0A0A;
            --code-block-border: #333333;

            background-image: none;
            background-color: var(--bg-primary);
        }

        /* Darkest Black & White Theme: Light Mode (Revised) */
        body[data-theme="darkest-bw-light"] {
            --bg-primary: #FFFFFF;
            --bg-secondary: #F0F0F0;
            --text-primary: #000000;
            --text-secondary: #555555;
            --border-color: #DDDDDD;
            --card-bg: #F0F0F0;
            --card-border: #DDDDDD;
            --header-bg: #F5F5F5;
            --accent-primary: #333333;
            --accent-primary-hover: #000000;
            --accent-secondary: #777777;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #EEEEEE;
            --user-bubble-text: #000000;
            --ai-bubble-bg: #DDDDDD;
            --ai-bubble-text: #000000;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #DDDDDD;
            --sidebar-item-hover: #F0F0F0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: #F0F0F0;
            --conversation-bg: #FFFFFF;
            --conversation-text: #000000;
            --conversation-indicator: #000000;
            --code-block-bg: #DDDDDD;
            --code-block-header-bg: #F5F5F5;
            --code-block-border: #DDDDDD;

            background-image: none;
            background-color: var(--bg-primary);
        }

        /* --- Coder's Dark Theme (Default) --- */
        body[data-theme="coder-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #0A0A0A;
            --text-primary: #00BCD4;
            --text-secondary: #8B949E;
            --border-color: #30363D;
            --card-bg: #0A0A0A;
            --card-border: #30363D;
            --header-bg: #000000;
            --accent-primary: #00BCD4;
            --accent-primary-hover: #0097A7;
            --accent-secondary: #8A2BE2;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #2C3E50;
            --user-bubble-text: #E0E0E0;
            --ai-bubble-bg: #1A1A1A;
            --ai-bubble-text: #E0E0E0;
            --sidebar-bg: #000000;
            --sidebar-border: #30363D;
            --sidebar-item-hover: #0A0A0A;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #00BCD4;
            --conversation-indicator: #00BCD4;
            --code-block-bg: #1A1A1A;
            --code-block-header-bg: #27272A;
            --code-block-border: #3F3F46;

            background-color: var(--bg-primary);
        }

        /* Coder's Light Theme */
        body[data-theme="coder-light"] {
            --bg-primary: #F0F2F5;
            --bg-secondary: #FFFFFF;
            --text-primary: #008C9D;
            --text-secondary: #718096;
            --border-color: #DDE2E8;
            --card-bg: #FFFFFF;
            --card-border: #DDE2E8;
            --header-bg: #E8EDF2;
            --accent-primary: #008C9D;
            --accent-primary-hover: #006D7D;
            --accent-secondary: #6A1B9A;
            --accent-error: #D32F2F;
            --accent-success: #388E3C;
            --user-bubble-bg: #E0F7FA;
            --user-bubble-text: #004D40;
            --ai-bubble-bg: #F0F4F8;
            --ai-bubble-text: #2C2C30;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #DDE2E8;
            --sidebar-item-hover: #F0F2F5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #004D40;
            --conversation-indicator: #008C9D;
            --code-block-bg: #F5F5F5;
            --code-block-header-bg: #ECEFF1;
            --code-block-border: #CFD8DC;

            background-color: var(--bg-primary);
        }

        /* --- Cyberpunk Theme --- */
        body[data-theme="cyberpunk-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #1A0F24;
            --text-primary: #00FFFF;
            --text-secondary: #A08AB2;
            --border-color: #3A1D4D;
            --card-bg: #1A0F24;
            --card-border: #3A1D4D;
            --header-bg: #0A050F;
            --accent-primary: #00FFFF;
            --accent-primary-hover: #00CED1;
            --accent-secondary: #FF1493;
            --accent-error: #FF4500;
            --accent-success: #32CD32;
            --user-bubble-bg: #3A204D;
            --user-bubble-text: #E0E0E0;
            --ai-bubble-bg: #100814;
            --ai-bubble-text: #E0E0E0;
            --sidebar-bg: #000000;
            --sidebar-border: #3A1D4D;
            --sidebar-item-hover: #1A0F24;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(10, 5, 15, 0.9);
            --conversation-bg: rgba(10, 5, 15, 0.95);
            --conversation-text: #00FFFF;
            --conversation-indicator: #00FFFF;
            --code-block-bg: #100814;
            --code-block-header-bg: #20102A;
            --code-block-border: #3A1D4D;

            background-color: var(--bg-primary);
        }
        body[data-theme="cyberpunk-light"] {
            --bg-primary: #F0F8FF;
            --bg-secondary: #FFFFFF;
            --text-primary: #00CED1;
            --text-secondary: #6A5ACD;
            --border-color: #ADD8E6;
            --card-bg: #FFFFFF;
            --card-border: #ADD8E6;
            --header-bg: #E0F2F7;
            --accent-primary: #00CED1;
            --accent-primary-hover: #00BFFF;
            --accent-secondary: #FF69B4;
            --accent-error: #DC143C;
            --accent-success: #3CB371;
            --user-bubble-bg: #E0FFFF;
            --user-bubble-text: #2F4F4F;
            --ai-bubble-bg: #F0F8FF;
            --ai-bubble-text: #4169E1;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #ADD8E6;
            --sidebar-item-hover: #E0F2F7;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #2F4F4F;
            --conversation-indicator: #00CED1;
            --code-block-bg: #E0FFFF;
            --code-block-header-bg: #ADD8E6;
            --code-block-border: #87CEEB;

            background-color: var(--bg-primary);
        }

        /* --- Matrix Code Theme --- */
        body[data-theme="matrix-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #0A0A0A;
            --text-primary: #00FF00;
            --text-secondary: #008000;
            --border-color: #004000;
            --card-bg: #0A0A0A;
            --card-border: #004000;
            --header-bg: #000000;
            --accent-primary: #00FF00;
            --accent-primary-hover: #00CC00;
            --accent-secondary: #00FFFF;
            --accent-error: #FF0000;
            --accent-success: #00FF00;
            --user-bubble-bg: #001A00;
            --user-bubble-text: #00FF00;
            --ai-bubble-bg: #000500;
            --ai-bubble-text: #00FF00;
            --sidebar-bg: #000000;
            --sidebar-border: #004000;
            --sidebar-item-hover: #001500;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #00FF00;
            --conversation-indicator: #00FF00;
            --code-block-bg: #000A00;
            --code-block-header-bg: #001000;
            --code-block-border: #002000;

            background-color: var(--bg-primary);
        }
        body[data-theme="matrix-light"] {
            --bg-primary: #FFFFFF;
            --bg-secondary: #F0F0F0;
            --text-primary: #008000;
            --text-secondary: #404040;
            --border-color: #D0D0D0;
            --card-bg: #F0F0F0;
            --card-border: #D0D0D0;
            --header-bg: #E0E0E0;
            --accent-primary: #008000;
            --accent-primary-hover: #006000;
            --accent-secondary: #00AAAA;
            --accent-error: #CC0000;
            --accent-success: #00AA00;
            --user-bubble-bg: #E0FFE0;
            --user-bubble-text: #202020;
            --ai-bubble-bg: #F0FFF0;
            --ai-bubble-text: #303030;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #D0D0D0;
            --sidebar-item-hover: #E0E0E0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #202020;
            --conversation-indicator: #008000;
            --code-block-bg: #F5FFF5;
            --code-block-header-bg: #E0FFE0;
            --code-block-border: #C0D0C0;

            background-color: var(--bg-primary);
        }

        /* --- Solarized Theme --- */
        body[data-theme="solarized-light"] {
            --bg-primary: #FDF6E3;
            --bg-secondary: #EEE8D5;
            --text-primary: #2AA198;
            --text-secondary: #657B83;
            --border-color: #93A1A1;
            --card-bg: #EEE8D5;
            --card-border: #93A1A1;
            --header-bg: #FDF6E3;
            --accent-primary: #2AA198;
            --accent-primary-hover: #268BD2;
            --accent-secondary: #DC322F;
            --accent-error: #DC322F;
            --accent-success: #859900;
            --user-bubble-bg: #839496;
            --user-bubble-text: #FDF6E3;
            --ai-bubble-bg: #E0E0D0;
            --ai-bubble-text: #586E75;
            --sidebar-bg: #FDF6E3;
            --sidebar-border: #93A1A1;
            --sidebar-item-hover: #EEE8D5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #586E75;
            --conversation-indicator: #2AA198;
            --code-block-bg: #EEE8D5;
            --code-block-header-bg: #FDF6E3;
            --code-block-border: #D0D0C0;

            background-color: var(--bg-primary);
        }
        body[data-theme="solarized-dark"] {
            --bg-primary: #002B36;
            --bg-secondary: #073642;
            --text-primary: #2AA198;
            --text-secondary: #839496;
            --border-color: #586E75;
            --card-bg: #073642;
            --card-border: #586E75;
            --header-bg: #002B36;
            --accent-primary: #2AA198;
            --accent-primary-hover: #268BD2;
            --accent-secondary: #DC322F;
            --accent-error: #DC322F;
            --accent-success: #859900;
            --user-bubble-bg: #586E75;
            --user-bubble-text: #FDF6E3;
            --ai-bubble-bg: #073642;
            --ai-bubble-text: #93A1A1;
            --sidebar-bg: #002B36;
            --sidebar-border: #586E75;
            --sidebar-item-hover: #073642;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 43, 54, 0.9);
            --conversation-bg: rgba(0, 43, 54, 0.95);
            --conversation-text: #FDF6E3;
            --conversation-indicator: #2AA198;
            --code-block-bg: #073642;
            --code-block-header-bg: #002B36;
            --code-block-border: #586E75;

            background-color: var(--bg-primary);
        }

        /* --- Dracula Theme --- */
        body[data-theme="dracula-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #282A36;
            --text-primary: #BD93F9;
            --text-secondary: #6272A4;
            --border-color: #44475A;
            --card-bg: #282A36;
            --card-border: #44475A;
            --header-bg: #000000;
            --accent-primary: #BD93F9;
            --accent-primary-hover: #FF79C6;
            --accent-secondary: #50FA7B;
            --accent-error: #FF5555;
            --accent-success: #50FA7B;
            --user-bubble-bg: #44475A;
            --user-bubble-text: #F8F8F2;
            --ai-bubble-bg: #1A1C25;
            --ai-bubble-text: #F8F8F2;
            --sidebar-bg: #000000;
            --sidebar-border: #44475A;
            --sidebar-item-hover: #282A36;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #F8F8F2;
            --conversation-indicator: #BD93F9;
            --code-block-bg: #1A1C25;
            --code-block-header-bg: #2F313E;
            --code-block-border: #44475A;

            background-color: var(--bg-primary);
        }
        body[data-theme="dracula-light"] {
            --bg-primary: #F8F8F2;
            --bg-secondary: #F0F0E0;
            --text-primary: #FF79C6;
            --text-secondary: #6272A4;
            --border-color: #CCDEF2;
            --card-bg: #F0F0E0;
            --card-border: #CCDEF2;
            --header-bg: #E8E8E0;
            --accent-primary: #FF79C6;
            --accent-primary-hover: #BD93F9;
            --accent-secondary: #50FA7B;
            --accent-error: #FF5555;
            --accent-success: #50FA7B;
            --user-bubble-bg: #CCDEF2;
            --user-bubble-text: #282A36;
            --ai-bubble-bg: #E8E8E0;
            --ai-bubble-text: #303240;
            --sidebar-bg: #F8F8F2;
            --sidebar-border: #CCDEF2;
            --sidebar-item-hover: #F0F0E0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #282A36;
            --conversation-indicator: #FF79C6;
            --code-block-bg: #E8E8E0;
            --code-block-header-bg: #D8D8D0;
            --code-block-border: #C2C2C0;

            background-color: var(--bg-primary);
        }

        /* --- Monokai Pro Theme --- */
        body[data-theme="monokai-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #2D2A2E;
            --text-primary: #A6E22E;
            --text-secondary: #75715E;
            --border-color: #49483E;
            --card-bg: #2D2A2E;
            --card-border: #49483E;
            --header-bg: #000000;
            --accent-primary: #A6E22E;
            --accent-primary-hover: #E6DB74;
            --accent-secondary: #FD971F;
            --accent-error: #F92672;
            --accent-success: #A6E22E;
            --user-bubble-bg: #49483E;
            --user-bubble-text: #FCFCFA;
            --ai-bubble-bg: #1A1A1A;
            --ai-bubble-text: #FCFCFA;
            --sidebar-bg: #000000;
            --sidebar-border: #49483E;
            --sidebar-item-hover: #2D2A2E;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #FCFCFA;
            --conversation-indicator: #A6E22E;
            --code-block-bg: #1A1A1A;
            --code-block-header-bg: #27252A;
            --code-block-border: #3F3C38;

            background-color: var(--bg-primary);
        }
        body[data-theme="monokai-light"] {
            --bg-primary: #FCFCFA;
            --bg-secondary: #F5F5F0;
            --text-primary: #F92672;
            --text-secondary: #75715E;
            --border-color: #D0D0CB;
            --card-bg: #F5F5F0;
            --card-border: #D0D0CB;
            --header-bg: #EEEEEC;
            --accent-primary: #F92672;
            --accent-primary-hover: #A6E22E;
            --accent-secondary: #FD971F;
            --accent-error: #CC3333;
            --accent-success: #A6E22E;
            --user-bubble-bg: #E0E0D8;
            --user-bubble-text: #30302E;
            --ai-bubble-bg: #EEEEEC;
            --ai-bubble-text: #40403C;
            --sidebar-bg: #FCFCFA;
            --sidebar-border: #D0D0CB;
            --sidebar-item-hover: #F5F5F0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #30302E;
            --conversation-indicator: #F92672;
            --code-block-bg: #EEEEEC;
            --code-block-header-bg: #E0E0D8;
            --code-block-border: #C0C0B8;

            background-color: var(--bg-primary);
        }

        /* --- Nord Theme --- */
        body[data-theme="nord-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #2E3440;
            --text-primary: #88C0D0;
            --text-secondary: #ECEFF4;
            --border-color: #4C566A;
            --card-bg: #2E3440;
            --card-border: #4C566A;
            --header-bg: #000000;
            --accent-primary: #88C0D0;
            --accent-primary-hover: #81A1C1;
            --accent-secondary: #B48EAD;
            --accent-error: #BF616A;
            --accent-success: #A3BE8C;
            --user-bubble-bg: #4C566A;
            --user-bubble-text: #D8DEE9;
            --ai-bubble-bg: #1A1D23;
            --ai-bubble-text: #D8DEE9;
            --sidebar-bg: #000000;
            --sidebar-border: #4C566A;
            --sidebar-item-hover: #2E3440;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #D8DEE9;
            --conversation-indicator: #88C0D0;
            --code-block-bg: #1A1D23;
            --code-block-header-bg: #242933;
            --code-block-border: #4C566A;

            background-color: var(--bg-primary);
        }
        body[data-theme="nord-light"] {
            --bg-primary: #ECEFF4;
            --bg-secondary: #D8DEE9;
            --text-primary: #5E81AC;
            --text-secondary: #4C566A;
            --border-color: #B4BFCD;
            --card-bg: #D8DEE9;
            --card-border: #B4BFCD;
            --header-bg: #DEE3EB;
            --accent-primary: #5E81AC;
            --accent-primary-hover: #81A1C1;
            --accent-secondary: #B48EAD;
            --accent-error: #BF616A;
            --accent-success: #A3BE8C;
            --user-bubble-bg: #AABECF;
            --user-bubble-text: #2E3440;
            --ai-bubble-bg: #DEE3EB;
            --ai-bubble-text: #3B4252;
            --sidebar-bg: #ECEFF4;
            --sidebar-border: #B4BFCD;
            --sidebar-item-hover: #D8DEE9;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #2E3440;
            --conversation-indicator: #5E81AC;
            --code-block-bg: #DEE3EB;
            --code-block-header-bg: #C0C7D1;
            --code-block-border: #B4BFCD;

            background-color: var(--bg-primary);
        }

        /* --- Gruvbox Theme --- */
        body[data-theme="gruvbox-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #282828;
            --text-primary: #83A598;
            --text-secondary: #A89984;
            --border-color: #504945;
            --card-bg: #282828;
            --card-border: #504945;
            --header-bg: #000000;
            --accent-primary: #83A598;
            --accent-primary-hover: #B8BB26;
            --accent-secondary: #FABD2F;
            --accent-error: #FB4934;
            --accent-success: #B8BB26;
            --user-bubble-bg: #504945;
            --user-bubble-text: #EBDBB2;
            --ai-bubble-bg: #1D2021;
            --ai-bubble-text: #EBDBB2;
            --sidebar-bg: #000000;
            --sidebar-border: #504945;
            --sidebar-item-hover: #282828;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #EBDBB2;
            --conversation-indicator: #83A598;
            --code-block-bg: #1D2021;
            --code-block-header-bg: #32302F;
            --code-block-border: #504945;

            background-color: var(--bg-primary);
        }
        body[data-theme="gruvbox-light"] {
            --bg-primary: #FBF1C7;
            --bg-secondary: #FEF6E4;
            --text-primary: #427B58;
            --text-secondary: #7C6F64;
            --border-color: #BDAEAA;
            --card-bg: #FEF6E4;
            --card-border: #BDAEAA;
            --header-bg: #EBDBB2;
            --accent-primary: #427B58;
            --accent-primary-hover: #8EC07C;
            --accent-secondary: #D79921;
            --accent-error: #CC241D;
            --accent-success: #8EC07C;
            --user-bubble-bg: #D5C4A1;
            --user-bubble-text: #3C3836;
            --ai-bubble-bg: #EBDBB2;
            --ai-bubble-text: #504945;
            --sidebar-bg: #FBF1C7;
            --sidebar-border: #BDAEAA;
            --sidebar-item-hover: #EBDBB2;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #3C3836;
            --conversation-indicator: #427B58;
            --code-block-bg: #EBDBB2;
            --code-block-header-bg: #D5C4A1;
            --code-block-border: #BDAEAA;

            background-color: var(--bg-primary);
        }

        /* --- Catppuccin Theme --- */
        body[data-theme="catppuccin-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #24273A;
            --text-primary: #8BD5CA;
            --text-secondary: #A5ADCE;
            --border-color: #494D64;
            --card-bg: #24273A;
            --card-border: #494D64;
            --header-bg: #000000;
            --accent-primary: #8BD5CA;
            --accent-primary-hover: #B7BFEF;
            --accent-secondary: #F4B8E4;
            --accent-error: #ED8796;
            --accent-success: #A6DA95;
            --user-bubble-bg: #494D64;
            --user-bubble-text: #CAD3F5;
            --ai-bubble-bg: #1A1D2A;
            --ai-bubble-text: #CAD3F5;
            --sidebar-bg: #000000;
            --sidebar-border: #494D64;
            --sidebar-item-hover: #24273A;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #CAD3F5;
            --conversation-indicator: #8BD5CA;
            --code-block-bg: #1A1D2A;
            --code-block-header-bg: #2E3243;
            --code-block-border: #494D64;

            background-color: var(--bg-primary);
        }
        body[data-theme="catppuccin-light"] {
            --bg-primary: #EFF1F5;
            --bg-secondary: #E6E9EF;
            --text-primary: #179299;
            --text-secondary: #5C5F77;
            --border-color: #CBD0E1;
            --card-bg: #E6E9EF;
            --card-border: #CBD0E1;
            --header-bg: #EAECEF;
            --accent-primary: #179299;
            --accent-primary-hover: #7287FD;
            --accent-secondary: #EA76CB;
            --accent-error: #E64553;
            --accent-success: #40A02B;
            --user-bubble-bg: #CBD0E1;
            --user-bubble-text: #4C4F69;
            --ai-bubble-bg: #EAECEF;
            --ai-bubble-text: #626880;
            --sidebar-bg: #EFF1F5;
            --sidebar-border: #CBD0E1;
            --sidebar-item-hover: #E6E9EF;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #4C4F69;
            --conversation-indicator: #179299;
            --code-block-bg: #EAECEF;
            --code-block-header-bg: #D4D7E2;
            --code-block-border: #C8CDDD;

            background-color: var(--bg-primary);
        }

        /* --- NEW THEMES START HERE --- */

        /* Cosmic Nexus Theme: Dark Mode (Inspired by Cosmic Neon) */
        body[data-theme="cosmic-nexus-dark"] {
            --bg-primary: #05050A;
            --bg-secondary: #101018;
            --text-primary: #E6E6E6;
            --text-secondary: #94A3B8;
            --border-color: #2A2A3A;
            --card-bg: #101018;
            --card-border: #2A2A3A;
            --header-bg: #0A0A10;
            --accent-primary: #00F5FF;
            --accent-primary-hover: #00CED1;
            --accent-secondary: #D400FF;
            --accent-error: #FF4500;
            --accent-success: #0AFF9D;
            --user-bubble-bg: #003344;
            --user-bubble-text: #E0FFFF;
            --ai-bubble-bg: #18052A;
            --ai-bubble-text: #E6E6E6;
            --sidebar-bg: #101018;
            --sidebar-border: #2A2A3A;
            --sidebar-item-hover: #1A1A22;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(16, 16, 24, 0.9);
            --conversation-bg: rgba(5, 5, 10, 0.95);
            --conversation-text: #E6E6E6;
            --conversation-indicator: #00F5FF;
            --code-block-bg: #18052A;
            --code-block-header-bg: #0A0A10;
            --code-block-border: #2A2A3A;

            background-color: var(--bg-primary);
            background-image: radial-gradient(circle at 15% 15%, rgba(0,245,255,0.08) 0%, transparent 25%),
                              radial-gradient(circle at 85% 85%, rgba(212,0,255,0.08) 0%, transparent 25%),
                              url('data:image/svg+xml;utf8,<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="smallGrid" width="16" height="16" patternUnits="userSpaceOnUse"><path d="M 16 0 L 0 0 L 0 16" fill="none" stroke="rgba(0,245,255,0.05)" stroke-width="0.5"/></pattern><pattern id="grid" width="80" height="80" patternUnits="userSpaceOnUse"><rect width="80" height="80" fill="url(%23smallGrid)"/><path d="M 80 0 L 0 0 L 0 80" fill="none" stroke="rgba(0,245,255,0.08)" stroke-width="1"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grid)"/></svg>');
            background-size: cover, cover, auto;
            background-blend-mode: overlay, overlay, multiply;
        }

        /* Cosmic Nexus Theme: Light Mode (Derived) */
        body[data-theme="cosmic-nexus-light"] {
            --bg-primary: #F0F8FF;
            --bg-secondary: #FFFFFF;
            --text-primary: #1F2937;
            --text-secondary: #4B5563;
            --border-color: #E5E7EB;
            --card-bg: #FFFFFF;
            --card-border: #E5E7EB;
            --header-bg: #EAF0F8;
            --accent-primary: #00CED1;
            --accent-primary-hover: #00BFFF;
            --accent-secondary: #9370DB;
            --accent-error: #FF4500;
            --accent-success: #0AFF9D;
            --user-bubble-bg: #E0FFFF;
            --user-bubble-text: #004D40;
            --ai-bubble-bg: #F3F8FF;
            --ai-bubble-text: #2F4F4F;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E5E7EB;
            --sidebar-item-hover: #EAF0F8;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.85);
            --conversation-bg: rgba(255, 255, 255, 0.9);
            --conversation-text: #1F2937;
            --conversation-indicator: #00CED1;
            --code-block-bg: #F3F8FF;
            --code-block-header-bg: #EAF0F8;
            --code-block-border: #E5E7EB;

            background-color: var(--bg-primary);
        }

        /* Starship Minimal Theme: Dark Mode (Inspired by Starship Minimal) */
        body[data-theme="starship-minimal-dark"] {
            --bg-primary: #0D1117;
            --bg-secondary: #161B22;
            --text-primary: #F0F6FC;
            --text-secondary: #8B949E;
            --border-color: #30363D;
            --card-bg: #161B22;
            --card-border: #30363D;
            --header-bg: #0D1117;
            --accent-primary: #2F81F7;
            --accent-primary-hover: #1C6EDD;
            --accent-secondary: #58A6FF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #1F385B;
            --user-bubble-text: #DBEAFE;
            --ai-bubble-bg: #21262D;
            --ai-bubble-text: #F0F6FC;
            --sidebar-bg: #161B22;
            --sidebar-border: #30363D;
            --sidebar-item-hover: #21262D;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(13, 17, 23, 0.9);
            --conversation-bg: rgba(13, 17, 23, 0.95);
            --conversation-text: #F0F6FC;
            --conversation-indicator: #2F81F7;
            --code-block-bg: #21262D;
            --code-block-header-bg: #161B22;
            --code-block-border: #30363D;

            background-color: var(--bg-primary);
            background-image: url('data:image/svg+xml;utf8,<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 L 0 10" fill="none" stroke="rgba(47,129,247,0.08)" stroke-width="0.5"/></pattern><pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse"><rect width="50" height="50" fill="url(%23smallGrid)"/><path d="M 50 0 L 0 0 L 0 50" fill="none" stroke="rgba(47,129,247,0.12)" stroke-width="1"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grid)"/></svg>');
            background-size: cover;
            background-blend-mode: overlay;
        }

        /* Starship Minimal Theme: Light Mode (Derived) */
        body[data-theme="starship-minimal-light"] {
            --bg-primary: #F0F4F8;
            --bg-secondary: #FFFFFF;
            --text-primary: #2D3748;
            --text-secondary: #718096;
            --border-color: #E2E8F0;
            --card-bg: #FFFFFF;
            --card-border: #E2E8F0;
            --header-bg: #EDF2F7;
            --accent-primary: #1E90FF;
            --accent-primary-hover: #107EEB;
            --accent-secondary: #63B2FF;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #DBEAFE;
            --user-bubble-text: #1E40AF;
            --ai-bubble-bg: #F3F8FF;
            --ai-bubble-text: #2D3748;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E2E8F0;
            --sidebar-item-hover: #F0F4F8;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.85);
            --conversation-bg: rgba(255, 255, 255, 0.9);
            --conversation-text: #2D3748;
            --conversation-indicator: #1E90FF;
            --code-block-bg: #F3F8FF;
            --code-block-header-bg: #EDF2F7;
            --code-block-border: #E2E8F0;

            background-color: var(--bg-primary);
        }

        /* Offbeat Cosmic Pastels Theme: Dark Mode (Inspired by Offbeat Cosmic Pastels) */
        body[data-theme="offbeat-cosmic-dark"] {
            --bg-primary: #0C0F16;
            --bg-secondary: #1A1E2B;
            --text-primary: #FDFDFD;
            --text-secondary: #A0A5B5;
            --border-color: #30354F;
            --card-bg: #1A1E2B;
            --card-border: #30354F;
            --header-bg: #0C0F16;
            --accent-primary: #5CE1E6;
            --accent-primary-hover: #45CCD1;
            --accent-secondary: #C780FF;
            --accent-error: #FF6347;
            --accent-success: #7FFF00;
            --user-bubble-bg: #3A2B5B;
            --user-bubble-text: #E0E0E0;
            --ai-bubble-bg: #2B1E40;
            --ai-bubble-text: #FDFDFD;
            --sidebar-bg: #1A1E2B;
            --sidebar-border: #30354F;
            --sidebar-item-hover: #212535;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(12, 15, 22, 0.9);
            --conversation-bg: rgba(12, 15, 22, 0.95);
            --conversation-text: #FDFDFD;
            --conversation-indicator: #5CE1E6;
            --code-block-bg: #2B1E40;
            --code-block-header-bg: #1A1E2B;
            --code-block-border: #30354F;

            background-color: var(--bg-primary);
            background-image: radial-gradient(circle at 20% 80%, rgba(199,128,255,0.1) 0%, transparent 40%),
                              radial-gradient(circle at 80% 20%, rgba(92,225,230,0.1) 0%, transparent 40%),
                              linear-gradient(135deg, rgba(255,180,233,0.05) 0%, transparent 50%, rgba(199,128,255,0.05) 100%);
            background-size: cover;
            background-blend-mode: soft-light;
            animation: pastel-nebula-drift 25s infinite alternate ease-in-out;
        }

        @keyframes pastel-nebula-drift {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        /* Offbeat Cosmic Pastels Theme: Light Mode (Derived) */
        body[data-theme="offbeat-cosmic-light"] {
            --bg-primary: #F9FDFD;
            --bg-secondary: #FFFFFF;
            --text-primary: #2D3748;
            --text-secondary: #718096;
            --border-color: #E2E8F0;
            --card-bg: #FFFFFF;
            --card-border: #E2E8F0;
            --header-bg: #EEF8F8;
            --accent-primary: #00BCD4;
            --accent-primary-hover: #00ACC1;
            --accent-secondary: #A078E0;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #DBFEFF;
            --user-bubble-text: #004D40;
            --ai-bubble-bg: #E0FFFF;
            --ai-bubble-text: #2D3748;
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E2E8F0;
            --sidebar-item-hover: #EEF8F8;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.85);
            --conversation-bg: rgba(255, 255, 255, 0.9);
            --conversation-text: #2D3748;
            --conversation-indicator: #00BCD4;
            --code-block-bg: #E0FFFF;
            --code-block-header-bg: #EEF8F8;
            --code-block-border: #E2E8F0;

            background-color: var(--bg-primary);
        }

        /* --- Global Styles & Overrides --- */

        /* Apply theme colors */
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }


        /* Specific Tailwind overrides for consistency with theme variables */
        .bg-white { background-color: var(--card-bg); }
        .bg-gray-50 { background-color: var(--header-bg); }
        .border-gray-100 { border-color: var(--card-border); }
        .border-gray-200 { border-color: var(--card-border); }
        .text-gray-800 { color: var(--text-primary); }
        .text-gray-900 { color: var(--text-primary); }
        .text-gray-600 { color: var(--text-secondary); }
        .text-gray-700 { color: var(--text-secondary); }
        .bg-gray-200 { background-color: var(--bg-primary); color: var(--text-primary); }
        .hover\:bg-gray-300:hover { background-color: var(--sidebar-item-hover); }
        .bg-gray-100 { background-color: var(--bg-primary); }
        .shadow-2xl { box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); }
        body[data-theme$="-dark"] .shadow-2xl { box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.45); }
        #error-message { background-color: var(--accent-error); color: white; }
        body[data-theme$="-dark"] #error-message { background-color: var(--accent-error); color: white; }

        /* Custom styles for glowing effects on buttons */
        .glow-button {
            position: relative;
            z-index: 10;
            transition: all 0.4s ease;
            box-shadow: 0 0 10px var(--accent-primary);
            background-color: var(--accent-primary);
        }
        .glow-button:hover {
            box-shadow: 0 0 12px var(--accent-primary), 0 0 20px var(--accent-primary);
            transform: translateY(-1px) scale(1.01);
            background-image: linear-gradient(to right, var(--accent-primary), var(--accent-primary-hover));
        }

        /* NEW: Error Button Glow */
        .glow-error-button {
            position: relative;
            z-index: 10;
            transition: all 0.4s ease;
            box-shadow: 0 0 10px var(--accent-error);
            background-color: var(--accent-error); /* Explicitly set base color */
        }
        .glow-error-button:hover {
            box-shadow: 0 0 12px var(--accent-error), 0 0 20px var(--accent-error);
            transform: translateY(-1px) scale(1.01);
        }
        
        /* Markdown content styling for better readability */
        .markdown-content h1, .markdown-content h2, .markdown-content h3 { font-weight: 800; margin-bottom: 0.75em; margin-top: 1.5em; line-height: 1.2; color: var(--accent-primary); }
        .markdown-content h1 { font-size: 2.25rem; }
        .markdown-content h2 { font-size: 1.875rem; }
        .markdown-content h3 { font-size: 1.5rem; }
        .markdown-content ul, .markdown-content ol { list-style-position: inside; margin-left: 1.5em; margin-bottom: 1em; }
        .markdown-content li { margin-bottom: 0.5em; }
        .markdown-content strong { color: var(--accent-secondary); font-weight: 700; }
        .markdown-content p { margin-bottom: 1em; }
        .markdown-content p:last-child { margin-bottom: 0; }

        /* Custom styles for dark mode toggle switch */
        .switch { margin-left: 0.5rem; }
        .slider { background-color: var(--text-secondary); transition: .4s; }
        input:checked + .slider { background-color: var(--accent-primary); }
        input:checked + .slider:before { transform: translateX(24px); }
        .slider:before { background-color: var(--bg-secondary); transition: .4s; }

        /* Custom scrollbar for a sleek look (hidden) */
        #sidebar-chat-list::-webkit-scrollbar,
        #chat-input::-webkit-scrollbar {
            width: 0 !important;
            height: 0 !important;
        }
        #sidebar-chat-list,
        #chat-input {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Styles specifically for #chat-history scrollbar */
        #chat-history {
            overflow-y: auto;
            overflow-x: hidden;

            scrollbar-width: thin;
            scrollbar-color: var(--accent-primary) var(--sidebar-item-hover);
        }

        /* Webkit (Chrome, Safari, Edge) scrollbar styles for #chat-history */
        #chat-history::-webkit-scrollbar {
            width: 8px;
        }

        #chat-history::-webkit-scrollbar-track {
            background: var(--sidebar-item-hover);
            border-radius: 10px;
        }

        #chat-history::-webkit-scrollbar-thumb {
            background-color: var(--accent-primary);
            border-radius: 10px;
            border: 2px solid var(--sidebar-item-hover);
        }

        #chat-history::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-primary-hover);
        }
        
        /* Modern loading animation */
        .loader-container { display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; }
        .loader-dot {
            width: 12px; height: 12px; margin: 0 4px;
            background-color: var(--loader-dot-color);
            border-radius: 50%; display: inline-block;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .loader-dot:nth-child(1) { animation-delay: -0.32s; }
        .loader-dot:nth-child(2) { animation-delay: -0.16s; }
        .loader-dot:nth-child(3) { animation-delay: 0s; }
        
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); opacity: 0.5; }
            40% { transform: scale(1.0); opacity: 1; }
        }

        /* Main Chat Window Styling */
        #main-chat-window {
            flex: 1;
            max-width: 100%;
            min-height: 100vh;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: var(--main-chat-window-bg);
            border-radius: 0;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            border-left: 1px solid var(--border-color);
            transition: all 0.3s ease-in-out;
        }
        body[data-theme$="-dark"] #main-chat-window {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.45);
        }

        /* Sidebar Styling */
        #sidebar {
            width: 280px;
            min-width: 280px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--sidebar-border);
            display: flex;
            flex-direction: column;
            padding: 1rem;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 30;
            height: 100vh;
            overflow-y: auto;
            transition: transform 0.3s ease-out, box-shadow 0.3s ease-out;
        }
        #sidebar.hidden-mobile {
            transform: translateX(-100%);
            position: absolute;
            left: 0;
            box-shadow: none;
        }
        @media (min-width: 768px) {
            body {
                justify-content: flex-start;
                align-items: stretch;
            }
            #sidebar {
                position: relative;
                transform: translateX(0%);
                border-radius: 0;
            }
            #sidebar.hidden-mobile {
                transform: translateX(0%);
                position: relative;
            }
            #main-chat-window {
                max-width: none;
                border-radius: 0;
            }
            #hamburger-menu-button { display: none !important; }
        }
        
        /* New chat message styles */
        .chat-message {
            margin-bottom: 0.75rem; padding: 1rem; border-radius: 1.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            word-break: break-word; transition: all 0.3s ease; transform: scale(0.95);
            transform-origin: bottom; max-width: 85%; position: relative; padding-bottom: 2.5rem;
        }

        .chat-message.user {
            background-color: var(--user-bubble-bg); color: var(--user-bubble-text);
            margin-left: auto; border-bottom-right-radius: 0.5rem;
            background-image: linear-gradient(to bottom right, var(--user-bubble-bg), color-mix(in srgb, var(--user-bubble-bg) 80%, var(--accent-primary) 20%));
        }

        .chat-message.ai {
            background-color: var(--ai-bubble-bg); color: var(--ai-bubble-text);
            margin-right: auto; border-bottom-left-radius: 0.5rem;
            background-image: linear-gradient(to bottom left, var(--ai-bubble-bg), color-mix(in srgb, var(--ai-bubble-bg) 80%, var(--border-color) 20%));
        }

        /* Styling for chat attachments */
        .chat-image { max-width: 100%; height: auto; border-radius: 0.75rem; margin-top: 0.5rem; display: block; }
        .chat-attachment-preview-item {
            display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem;
            border-radius: 1rem; background-color: color-mix(in srgb, var(--accent-primary) 15%, transparent);
            color: var(--accent-primary); font-size: 0.875rem; box-shadow: 0 1px 2px rgba(0,0,0,0.08);
            transition: all 0.2s ease;
        }
        .chat-attachment-preview-item .remove-attachment-btn {
            background: none; border: none; color: var(--accent-primary); cursor: pointer;
            padding: 0.1rem; border-radius: 50%; transition: background-color 0.2s ease;
        }
        .chat-attachment-preview-item .remove-attachment-btn:hover {
            background-color: color-mix(in srgb, var(--accent-primary) 20%, transparent);
        }

        /* Styling for the copy message */
        #copy-message {
            position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%);
            padding: 0.75rem 1.5rem; background-color: var(--accent-success); color: white;
            border-radius: 9999px; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            opacity: 0; visibility: hidden; transition: all 0.5s ease-in-out; z-index: 100;
        }
        #copy-message.show { opacity: 1; visibility: visible; bottom: 4rem; }

        /* --- New/Enhanced Styles for Chat AI Responses & Code Blocks --- */
        
        .chat-message .message-content { padding: 0; margin: 0; }
        .chat-message.ai .message-content p, .chat-message.ai .message-content ul,
        .chat-message.ai .message-content ol, .chat-message.ai .message-content h1,
        .chat-message.ai .message-content h2, .chat-message.ai .message-content h3,
        .chat-message.ai .message-content blockquote { margin-bottom: 1em; }
        .chat-message.ai .message-content p:last-child, .chat-message.ai .message-content ul:last-child,
        .chat-message.ai .message-content ol:last-child, .chat-message.ai .message-content blockquote:last-child { margin-bottom: 0; }
        .chat-message.ai .message-content ul, .chat-message.ai .message-content ol { padding-left: 1.5em; }
        .chat-message.ai .message-content li { margin-bottom: 0.5em; }
        .chat-message.ai .message-content strong { font-weight: bold; color: var(--accent-primary); }
        .chat-message.ai .message-content em { font-style: italic; }
        .chat-message.ai .message-content blockquote {
            border-left: 4px solid var(--accent-secondary); padding-left: 1em;
            margin-left: 0; color: var(--text-secondary);
        }

        /* Code block specific styling */
        .code-block-container {
            position: relative;
            background-color: var(--code-block-bg);
            color: var(--text-primary);
            border-radius: 0.75rem; margin-top: 1rem; margin-bottom: 1rem;
            overflow: hidden; border: 1px solid var(--code-block-border);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .code-block-container pre {
            margin: 0; padding: 1rem; overflow-x: auto;
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            font-size: 0.9em; line-height: 1.4;
        }
        /* Override Prism.js default styles for code blocks */
        .code-block-container pre[class*="language-"] {
            background-color: var(--code-block-bg) !important;
            padding: 1rem !important;
            margin: 0 !important;
        }

        .code-block-container pre code[class*="language-"] {
            color: var(--text-primary) !important;
        }

        .code-block-header {
            display: flex; justify-content: space-between; align-items: center;
            background-color: var(--code-block-header-bg);
            color: var(--text-secondary); padding: 0.5rem 1rem;
            border-bottom: 1px solid var(--code-block-border);
            font-size: 0.85em;
            border-top-left-radius: 0.75rem; border-top-right-radius: 0.75rem;
        }
        .code-block-copy-button {
            background-color: transparent; border: none; color: var(--text-secondary);
            cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 0.375rem;
            transition: background-color 0.2s ease, color 0.2s ease;
            display: flex; align-items: center; gap: 0.25rem; font-size: 0.85em;
        }
        .code-block-copy-button:hover { background-color: var(--border-color); color: var(--text-primary); }
        .code-block-copy-button:active { transform: scale(0.95); }

        /* Smallest font size for inline code blocks if any */
        .chat-message.ai .message-content code:not(pre > code) {
            background-color: color-mix(in srgb, var(--accent-primary) 15%, transparent) !important;
            border-radius: 0.25rem;
            padding: 0.2em 0.4em; font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            font-size: 0.9em; color: var(--accent-primary) !important;
        }

        /* Ensure links are distinguishable */
        .chat-message.ai .message-content a {
            color: var(--accent-primary); text-decoration: underline; transition: color 0.2s ease;
        }
        .chat-message.ai .message-content a:hover { color: var(--accent-primary-hover); }

        /* Styles for message action buttons (copy/dictate) */
        .message-actions {
            position: absolute; bottom: 0.5rem; right: 1rem; display: flex; gap: 0.5rem;
            padding: 0.25rem 0.5rem; background-color: var(--header-bg);
            border-radius: 0.75rem; backdrop-filter: blur(5px); transition: opacity 0.3s ease;
            opacity: 0; z-index: 10;
            border: 1px solid var(--border-color);
        }
        .chat-message:hover .message-actions { opacity: 1; }
        .message-actions button {
            background: none; border: none; cursor: pointer; padding: 0.25rem;
            border-radius: 0.375rem; transition: background-color 0.2s ease, color 0.2s ease;
            display: flex; align-items: center; justify-content: center;
        }
        .message-actions button .lucide { color: var(--text-secondary); width: 1rem; height: 1rem; }
        .message-actions button:hover .lucide { color: var(--text-primary); }
        .message-actions button:hover { background-color: var(--sidebar-item-hover); }
        .chat-message.user .message-actions { right: 1rem; left: auto; }
        .chat-message.ai .message-actions { left: 1rem; right: auto; }

        /* New style for speech recognition button when active */
        .voice-input-active {
            background-color: var(--accent-error) !important;
            animation: pulse-red 1s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }
        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--accent-error) 70%, transparent); }
            50% { box-shadow: 0 0 0 10px color-mix(in srgb, var(--accent-error) 0%, transparent); }
        }
        
        /* Drag and Drop visual feedback for chat input area */
        #chat-input-area-container.drag-over-active {
            border: 2px dashed var(--accent-primary);
            box-shadow: 0 0 20px var(--accent-primary), 0 0 30px var(--accent-primary) inset;
        }
        
        /* Sidebar chat list item styling */
        .sidebar-chat-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            text-align: left;
        }
        .sidebar-chat-item:hover {
            background-color: var(--sidebar-item-hover);
            color: var(--text-primary);
        }
        .sidebar-chat-item.active {
            background-color: var(--accent-primary);
            color: black;
            font-weight: 600;
        }
        .sidebar-chat-item.active .lucide {
            color: black;
        }
        .sidebar-chat-item.active:hover {
            background-color: var(--accent-primary-hover);
        }
        .sidebar-chat-item-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-grow: 1;
            min-width: 0;
        }
        .sidebar-chat-item-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }
        .sidebar-chat-item-actions {
            display: flex;
            gap: 0.25rem;
            flex-shrink: 0;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .sidebar-chat-item:hover .sidebar-chat-item-actions {
            opacity: 1;
        }
        .sidebar-chat-item-actions button {
            background: none;
            border: none;
            padding: 0.25rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .sidebar-chat-item-actions button .lucide {
            width: 1rem;
            height: 1rem;
            color: var(--text-secondary);
        }
        .sidebar-chat-item-actions button:hover {
            background-color: var(--sidebar-item-hover);
        }
        .sidebar-chat-item.active .sidebar-chat-item-actions button .lucide {
            color: white;
        }

        /* Responsive menu button for sidebar */
        #hamburger-menu-button {
            display: flex;
            margin-right: 1rem;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 0.5rem;
            background-color: var(--header-bg);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #hamburger-menu-button:hover {
            background-color: var(--sidebar-item-hover);
        }

        /* Overlay for mobile sidebar */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            z-index: 29;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
        }
        .sidebar-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* --- Conversation Mode Overlay Styles --- */
        #conversation-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--conversation-bg);
            color: var(--conversation-text);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-in-out;
            opacity: 0;
            visibility: hidden;
            backdrop-filter: blur(10px) brightness(0.8);
            -webkit-backdrop-filter: blur(10px) brightness(0.8);
            padding: 1rem;
            overflow-y: auto;

            background-image: radial-gradient(circle at 15% 50%, color-mix(in srgb, var(--accent-primary) 20%, transparent), transparent 70%),
                              radial-gradient(circle at 85% 50%, color-mix(in srgb, var(--accent-secondary) 20%, transparent), transparent 70%),
                              linear-gradient(135deg, color-mix(in srgb, var(--conversation-bg) 90%, var(--bg-primary) 10%) 0%, transparent 50%);
            background-size: 200% 200%;
            background-position: center center;
            animation: background-drift 30s infinite alternate ease-in-out;
        }

        #conversation-mode-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        @keyframes background-drift {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        #conversation-mode-close-btn {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            z-index: 110;
            padding: 0.5rem;
            border-radius: 50%;
            transition: color 0.3s ease, transform 0.2s ease;
        }
        #conversation-mode-close-btn:hover {
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .conversation-controls {
            position: absolute;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 105;
            flex-wrap: wrap;
            justify-content: center;
            background-color: color-mix(in srgb, var(--conversation-bg) 60%, transparent);
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            max-width: 90%;
        }
        @media (max-width: 768px) {
            .conversation-controls {
                top: 0.5rem;
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 0.5rem;
                width: auto;
                border-radius: 0.75rem;
            }
        }


        .conversation-controls label {
            color: var(--text-secondary);
            font-size: 0.85rem;
            align-self: center;
            margin-right: -0.5rem;
        }
        .conversation-controls select {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            min-width: 120px;
        }
        .conversation-controls select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent-primary) 30%, transparent);
        }

        .sound-blob-wrapper {
            position: relative;
            width: 300px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
            perspective: 1000px;
            margin-top: 8rem;
        }
        @media (max-width: 768px) {
            .sound-blob-wrapper {
                width: 200px;
                height: 200px;
                margin-top: 12rem;
            }
        }

        /* Base blob styles */
        .sound-blob {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: var(--conversation-indicator);
            border-radius: 50% 30% 60% 40% / 40% 60% 30% 50%;
            opacity: 0.7;
            filter: blur(8px) drop-shadow(0 0 25px var(--conversation-indicator));
            transition: all 0.5s ease;
            will-change: transform, opacity, background-color, filter;
            animation: idle-blob-morph 15s infinite alternate ease-in-out;
        }

        /* Additional concentric blobs */
        .sound-blob::before,
        .sound-blob::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: inherit;
            background-color: inherit;
            opacity: 0.5;
            filter: blur(15px);
            animation: idle-blob-morph 18s infinite alternate-reverse ease-in-out;
            transform: scale(1.05);
            z-index: -1;
        }

        .sound-blob::after {
            opacity: 0.3;
            filter: blur(20px);
            animation: idle-blob-morph 20s infinite alternate ease-in-out;
            transform: scale(1.1);
            animation-delay: 2s;
        }

        @keyframes idle-blob-morph {
            0% {
                border-radius: 50% 30% 60% 40% / 40% 60% 30% 50%;
                transform: scale(0.95) rotate(0deg);
                opacity: 0.6;
            }
            50% {
                border-radius: 30% 50% 40% 60% / 60% 40% 50% 30%;
                transform: scale(1.05) rotate(10deg);
                opacity: 0.8;
            }
            100% {
                border-radius: 50% 30% 60% 40% / 40% 60% 30% 50%;
                transform: scale(0.95) rotate(0deg);
                opacity: 0.6;
            }
        }

        .sound-blob.listening-animation {
            animation: listen-pulse 1.2s infinite ease-out, listen-color-shift 3s infinite alternate;
            border-radius: 50%;
            filter: blur(5px) drop-shadow(0 0 30px var(--conversation-indicator));
            opacity: 0.9;
        }
        .sound-blob.listening-animation::before,
        .sound-blob.listening-animation::after {
            animation: listen-ring-pulse 1.5s infinite ease-out;
            border-radius: 50%;
        }

        @keyframes listen-pulse {
            0% { transform: scale(0.9) rotate(0deg); opacity: 0.7; }
            50% { transform: scale(1.05) rotate(5deg); opacity: 1; filter: blur(5px) drop-shadow(0 0 40px var(--conversation-indicator)); }
            100% { transform: scale(0.9) rotate(0deg); opacity: 0.7; }
        }
        @keyframes listen-ring-pulse {
            0% { transform: scale(1.05); opacity: 0.5; filter: blur(10px); }
            50% { transform: scale(1.15); opacity: 0.8; filter: blur(18px); }
            100% { transform: scale(1.05); opacity: 0.5; filter: blur(10px); }
        }
        @keyframes listen-color-shift {
            0% { background-color: var(--conversation-indicator); }
            50% { background-color: color-mix(in srgb, var(--conversation-indicator) 80%, var(--accent-secondary) 20%); }
            100% { background-color: var(--conversation-indicator); }
        }

        .sound-blob.speaking-animation {
            animation: speak-pulse 1s infinite cubic-bezier(0.4, 0, 0.6, 1), speak-color-shift 2.5s infinite alternate;
            border-radius: 60% 40% 50% 50% / 50% 50% 40% 60%;
            filter: blur(3px) drop-shadow(0 0 40px var(--conversation-indicator));
            opacity: 1;
        }
        .sound-blob.speaking-animation::before,
        .sound-blob.speaking-animation::after {
            animation: speak-ring-pulse 1.3s infinite ease-in-out;
            border-radius: 60% 40% 50% 50% / 50% 50% 40% 60%;
        }

        @keyframes speak-pulse {
            0% { transform: scale(0.98) rotate(0deg); }
            25% { transform: scale(1.05) rotate(3deg); }
            50% { transform: scale(1.02) rotate(-3deg); }
            75% { transform: scale(1.08) rotate(3deg); }
            100% { transform: scale(0.98) rotate(0deg); }
        }
        @keyframes speak-ring-pulse {
            0% { transform: scale(1.02); opacity: 0.6; filter: blur(8px); }
            50% { transform: scale(1.1); opacity: 0.9; filter: blur(12px); }
            100% { transform: scale(1.02); opacity: 0.6; filter: blur(8px); }
        }
        @keyframes speak-color-shift {
            0% { background-color: var(--conversation-indicator); }
            50% { background-color: color-mix(in srgb, var(--conversation-indicator) 70%, white 30%); }
            100% { background-color: var(--conversation-indicator); }
        }

        .sound-blob.idle-animation {
            animation: idle-blob-morph 15s infinite alternate ease-in-out;
            opacity: 0.6;
            filter: blur(8px) drop-shadow(0 0 20px var(--conversation-indicator));
            transform: scale(0.9);
        }

        .conversation-status-text {
            font-size: 2.2rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 1.5rem;
            min-height: 2.5em;
            color: var(--text-primary);
            text-shadow: 0 0 10px color-mix(in srgb, var(--conversation-indicator) 50%, transparent);
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }
        .conversation-status-text.listening-state { color: var(--accent-secondary); text-shadow: 0 0 15px var(--accent-secondary); }
        .conversation-status-text.speaking-state { color: var(--accent-primary); text-shadow: 0 0 15px var(--accent-primary); }
        .conversation-status-text.error-state { color: var(--accent-error); text-shadow: 0 0 15px var(--accent-error); }


        .conversation-history-display {
            max-width: 600px;
            width: 90%;
            height: 120px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 1.5rem;
            padding: 1.2rem;
            text-align: left;
            font-size: 1.1rem;
            line-height: 1.6;
            background: linear-gradient(to top, var(--card-bg) 70%, color-mix(in srgb, var(--card-bg) 20%, transparent) 100%);
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
            color: var(--text-primary);
            scrollbar-width: none;
            -ms-overflow-style: none;
            position: relative;
            contain: layout style;
        }
        .conversation-history-display::-webkit-scrollbar {
            width: 0;
        }
        .conversation-history-display p { margin-bottom: 0.5rem; }
        .conversation-history-display p:last-child { margin-bottom: 0; }
        .user-utterance { color: var(--user-bubble-text); font-weight: 600; }
        .ai-utterance { color: var(--ai-bubble-text); font-weight: 600; }

        .conversation-mic-btn {
            width: 80px;
            height: 80px;
            margin-top: 3rem !important;
            background-color: var(--accent-primary);
            color: white;
            box-shadow: 0 0 15px var(--accent-primary);
        }
        .conversation-mic-btn:hover {
            box-shadow: 0 0 25px var(--accent-primary), 0 0 40px var(--accent-primary-hover);
            transform: scale(1.05);
        }
        .conversation-mic-btn.voice-input-active {
            background-color: var(--accent-error) !important;
            box-shadow: 0 0 20px var(--accent-error), 0 0 35px var(--accent-error), 0 0 50px var(--accent-error);
            animation: pulse-red 1s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }
        /* Re-define pulse-red to use var(--accent-error) */
        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--accent-error) 70%, transparent); }
            50% { box-shadow: 0 0 0 15px color-mix(in srgb, var(--accent-error) 0%, transparent); }
        }

        /* Styling for the prompt templates list */
        .template-item {
            display: flex;
            flex-direction: column;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .template-item:hover {
            background-color: var(--sidebar-item-hover);
            border-color: var(--accent-primary);
        }
        .template-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .template-item-name {
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }
        .template-item-content {
            font-size: 0.875rem;
            color: var(--text-secondary);
            max-height: 3em;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.5;
            margin-bottom: 0.75rem;
        }
        .template-item-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            margin-top: 0.5rem;
        }
        .template-item-actions button {
            padding: 0.4rem 0.8rem;
            border-radius: 0.5rem;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .template-item-actions .use-btn {
            background-color: var(--accent-primary);
            color: black;
        }
        .template-item-actions .use-btn:hover {
            background-color: var(--accent-primary-hover);
            box-shadow: 0 0 10px var(--accent-primary);
            transform: translateY(-1px);
        }
        .template-item-actions .edit-btn {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        .template-item-actions .edit-btn:hover {
            background-color: var(--sidebar-item-hover);
            border-color: var(--accent-secondary);
            transform: translateY(-1px);
        }
        .template-item-actions .delete-btn {
            background-color: var(--accent-error);
            color: white;
        }
        .template-item-actions .delete-btn:hover {
            background-color: color-mix(in srgb, var(--accent-error) 80%, black 20%);
            box-shadow: 0 0 8px var(--accent-error);
            transform: translateY(-1px);
        }

        /* NEW CSS for Collapsible Settings */
        #settings-content:not(.hidden) {
            animation: slideDown 0.3s ease-out;
            /* Using max-height transition for smooth opening/closing, must be large enough */
            max-height: 800px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        #settings-content.hidden {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in;
        }
        
    </style>
</head>
<body class="antialiased" data-theme="default-dark">

    <!-- Conversation Mode Overlay (NEW SECTION) -->
    <div id="conversation-mode-overlay" class="hidden">
        <button id="conversation-mode-close-btn" aria-label="Close Conversation Mode" title="Close Conversation Mode">
            <span data-lucide="x" class="w-8 h-8"></span>
        </button>

        <div class="conversation-controls">
            <label for="voice-select">Voice:</label>
            <select id="voice-select" aria-label="Select AI Voice" class="p-2 rounded-md border text-sm">
                <option value="">Default Voice</option>
                <!-- Voices will be populated dynamically -->
            </select>

            <label for="personality-select">Personality:</label>
            <select id="personality-select" aria-label="Select AI Personality" class="p-2 rounded-md border text-sm">
                <!-- Personalities will be populated dynamically -->
            </select>
        </div>

        <div class="sound-blob-wrapper">
            <div id="sound-blob" class="sound-blob idle-animation"></div>
        </div>

        <div id="conversation-status-text" class="conversation-status-text">
            Tap the button to start conversing!
        </div>

        <div id="conversation-history-display" class="conversation-history-display">
            <!-- Last few spoken phrases will appear here -->
        </div>

        <button id="conversation-mic-btn" aria-label="Toggle Microphone" class="flex items-center justify-center rounded-full shadow-lg cursor-pointer transition-all duration-300 glow-button conversation-mic-btn">
            <span data-lucide="mic" class="w-8 h-8"></span>
        </button>
    </div>
    <!-- END Conversation Mode Overlay -->

    <!-- Overlay for mobile sidebar -->
    <div class="sidebar-overlay" id="sidebar-overlay"></div>

    <!-- Sidebar (Updated Structure) -->
    <aside id="sidebar" class="hidden-mobile">
        <div class="flex items-center justify-between pb-4 border-b border-[var(--sidebar-border)] mb-4">
            <h2 class="text-xl font-bold flex items-center gap-2" style="color: var(--text-primary);">
                <span data-lucide="sparkles" class="w-6 h-6" style="color: var(--accent-primary);"></span> Small AI v2
            </h2>
            <button id="close-sidebar-btn" aria-label="Close Sidebar" title="Close Sidebar" class="md:hidden" style="color: var(--text-secondary); background-color: transparent; border: none;">
                <span data-lucide="x" class="w-6 h-6"></span>
            </button>
        </div>

        <!-- New Chat Button -->
        <button id="new-chat-button" class="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors mb-4 glow-button" style="background-color: var(--accent-primary); color: black;">
            <span data-lucide="plus" class="w-5 h-5 mr-2"></span> New Chat
        </button>
        
        <!-- Previous Chats Section (Made flexible to take height) -->
        <div class="flex-1 overflow-y-auto mb-4" id="previous-chats-section">
            <h3 class="text-sm font-semibold uppercase sticky top-0 py-2 z-10" style="background-color: var(--sidebar-bg); color: var(--text-secondary);">Previous Chats</h3>
            <ul id="sidebar-chat-list" class="space-y-1">
                <!-- Chat items are loaded by JS based on auth state -->
            </ul>
        </div>

        <!-- Grouped Settings Section (Model, Theme, Version, API Key, Auth) - Optimized for space -->
        <div class="mt-auto pt-4 border-t border-[var(--sidebar-border)] space-y-3">
            
            <!-- NEW: Settings Toggle Button -->
            <button id="toggle-settings-btn" class="w-full flex items-center justify-between p-3 rounded-xl font-semibold transition-colors mb-2" style="background-color: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color);">
                <span class="flex items-center gap-2">
                    <span data-lucide="settings" class="w-5 h-5"></span> Settings & Configuration
                </span>
                <span data-lucide="chevron-down" class="w-4 h-4 transition-transform duration-300" id="settings-chevron"></span>
            </button>

            <!-- Settings Content (Collapsible) -->
            <div id="settings-content" class="space-y-3 hidden">
                
                <!-- Custom Prompt Button -->
                <button id="toggle-custom-prompt-btn" class="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors" style="background-color: var(--bg-secondary); color: var(--text-primary);">
                    <span data-lucide="sparkles" class="w-5 h-5 mr-2"></span> Set Custom Prompt
                </button>
                
                <!-- Manage Prompt Templates Button -->
                <button id="manage-templates-btn" class="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors mb-4" style="background-color: var(--bg-secondary); color: var(--text-primary);">
                    <span data-lucide="layout-template" class="w-5 h-5 mr-2"></span> Manage Templates
                </button>

                <!-- User's Gemini API Key Input -->
                <div>
                    <h3 class="text-sm font-semibold uppercase mb-2" style="color: var(--text-secondary);">Your Gemini API Key</h3>
                    <div class="flex items-center gap-2">
                        <input type="password" id="gemini-api-key-input" class="w-full p-2 rounded-md border text-sm focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" placeholder="Enter your key (saved securely)" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);">
                        <button id="save-api-key-btn" title="Save API Key" class="flex items-center justify-center p-2 rounded-md shadow-md transition-all duration-300" style="background-color: var(--accent-primary); color: black;">
                            <span data-lucide="save" class="w-4 h-4"></span>
                        </button>
                    </div>
                    <p id="api-key-status" class="text-xs mt-1" style="color: var(--text-secondary);">No key set. Using fallback (if available).</p>
                </div>
                
                <!-- Model Selector -->
                <div>
                    <h3 class="text-sm font-semibold uppercase mb-2" style="color: var(--text-secondary);">AI Model</h3>
                    <select id="model-select-sidebar" class="w-full p-2 rounded-md border text-sm focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);" aria-label="Select AI Model">
                        <!-- Options populated by JS -->
                    </select>
                </div>

                <!-- Theme Selector (Dropdown for different themes) -->
                <div>
                    <h3 class="text-sm font-semibold uppercase mb-2" style="color: var(--text-secondary);">Themes</h3>
                    <select id="app-theme-select-sidebar" class="w-full p-2 rounded-md border text-sm focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);" aria-label="Select App Theme">
                        <option value="default">Small AI v2 (Default)</option>
                        <option value="celestial-horizon">Celestial Horizon</option>
                        <option value="verdant-calm">Verdant Calm</option>
                        <option value="cybernetic-pulse">Cybernetic Pulse</option>
                        <option value="urban-pulse">Urban Pulse</option>
                        <option value="rustic-ember">Rustic Ember</option>
                        <option value="neon-mirage">Neon Mirage</option>
                        <option value="ivory-bloom">Ivory Bloom</option>
                        <option value="obsidian-night">Obsidian Night</option>
                        <option value="solar-dawn">Solar Dawn</option>
                        <option value="aurora-drift">Aurora Drift</option>
                        <option value="timeless-echo">Timeless Echo</option>
                        <option value="mystic-void">Mystic Void</option>
                        <option value="darkest-bw">The Darkest Night</option>
                        <!-- NEW THEMES BELOW -->
                        <option value="coder">Coder's Theme</option>
                        <option value="cyberpunk">Cyberpunk Neon</option>
                        <option value="matrix">Matrix Code</option>
                        <option value="solarized">Solarized</option>
                        <option value="dracula">Dracula</option>
                        <option value="monokai">Monokai Pro</option>
                        <option value="nord">Nord</option>
                        <option value="gruvbox">Gruvbox</option>
                        <option value="catppuccin">Catppuccin</option>
                        <!-- ADDED NEW THEMES HERE -->
                        <option value="cosmic-nexus">Cosmic Nexus</option>
                        <option value="starship-minimal">Starship Minimal</option>
                        <option value="offbeat-cosmic">Offbeat Cosmic Pastels</option>
                    </select>
                </div>

                <!-- Version Selector -->
                <div>
                    <h3 class="text-sm font-semibold uppercase mb-2" style="color: var(--text-secondary);">Version</h3>
                    <select id="version-select-sidebar" class="w-full p-2 rounded-md border text-sm focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);" aria-label="Select Chatbot Version">
                        <option value="https://mystic-vision-ai-standalone-chatbot.netlify.app/">Main Version</option>
                        <option value="https://mystic-vision-ai-lite.netlify.app/">Lite Version</option>
                        <option value="https://mystic-vision-ai-basic.netlify.app/">Basic Version</option>
                        <option value="https://mystic-vision-ai-mini.netlify.app/">Mini Version</option>
                        <option value="https://cosmic-chat-ai-simple-ai-chatbot.netlify.app/">Cosmic Chat AI</option>
                        <option value="https://small-ai-big-vision.netlify.app/">Small AI (Legacy)</option>
                        <option value="https://small-ai-big-vision-v2.netlify.app/" selected>Small AI v2 (Current)</option>
                    </select>
                </div>

                <!-- Data Management Buttons -->
                <div class="mt-4 pt-4 border-t border-[var(--sidebar-border)]">
                    <h3 class="text-sm font-semibold uppercase mb-2" style="color: var(--text-secondary);">Data Management</h3>
                    <button id="delete-all-chats-btn" class="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors mb-2" style="background-color: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color);">
                        <span data-lucide="folder-x" class="w-5 h-5 mr-2"></span> Delete All Chats
                    </button>
                    <button id="clear-local-storage-btn" class="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors mb-4 glow-error-button" style="color: white;">
                        <span data-lucide="database" class="w-5 h-5 mr-2"></span> Clear Local Cache
                    </button>
                </div>
            </div>

            <!-- Authentication Status & Sign Out (Always visible) -->
            <div id="auth-status-container" class="pt-4 border-t border-[var(--sidebar-border)]">
                <p class="text-sm font-semibold mb-2" style="color: var(--text-secondary);">Logged in as: <span id="user-email">Guest</span></p>
                <button id="sign-out-button" class="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors glow-error-button" style="color: white;">
                    <span data-lucide="log-out" class="w-5 h-5 mr-2"></span> Sign Out
                </button>
            </div>
        </div>
    </aside>

    <!-- Main Chat Container -->
    <div id="main-chat-window" class="min-w-0">
        <!-- Header for the chat -->
        <div class="flex justify-between items-center p-4 border-b border-[var(--border-color)]" style="background-color: var(--header-bg);">
            <div class="flex items-center">
                <!-- Hamburger menu button for mobile -->
                <button id="hamburger-menu-button" aria-label="Open Sidebar Menu" title="Open Menu" style="background-color: var(--header-bg); border-color: var(--border-color); color: var(--text-primary);">
                    <span data-lucide="menu" class="w-6 h-6"></span>
                </button>
                <h1 class="text-xl font-bold flex items-center gap-2" style="color: var(--text-primary);">
                    <span data-lucide="sparkles" class="w-6 h-6" style="color: var(--accent-primary);"></span> Current Chat
                </h1>
            </div>
            <!-- Right side of header -->
            <div class="flex items-center gap-4">
                <!-- Conversation Mode Toggle Button (NEW) -->
                <button id="conversation-mode-toggle-btn" aria-label="Conversation Mode" title="Start Voice Conversation" class="flex items-center justify-center p-2 rounded-full shadow-md transition-all duration-300" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="messages-square" class="w-5 h-5"></span>
                </button>
                <!-- Dark Mode Toggle -->
                <div class="flex items-center gap-2">
                    <span class="text-sm" style="color: var(--text-secondary);">Dark Mode</span>
                    <label class="switch relative inline-block w-14 h-8">
                        <input type="checkbox" id="dark-mode-toggle" class="opacity-0 w-0 h-0">
                        <span class="slider absolute cursor-pointer top-0 left-0 right-0 bottom-0 rounded-full before:absolute before:content-[''] before:h-6 before:w-6 before:left-1 before:bottom-1 before:rounded-full"></span>
                    </label>
                </div>
            </div>
        </div>
        
        <!-- Chat history div with a minimum height and scroll -->
        <div id="chat-history" class="p-4 overflow-y-auto flex-1 flex flex-col">
            <!-- Initial AI message will be appended here by JS -->
        </div>
        
        <!-- Chat input section with attachment, voice and send button -->
        <div id="chat-input-area-container" class="p-4 border-t border-[var(--border-color)] relative transition-all duration-300" style="background-color: var(--header-bg);">
            <!-- Attachment preview -->
            <div id="chat-attachments-preview-container" class="mb-2 flex flex-wrap items-center gap-2 hidden">
                <!-- Attachments previews will be dynamically added here -->
            </div>

            <div class="flex gap-2 items-end flex-wrap">
                <!-- Voice Input Button -->
                <button id="voice-input-btn" aria-label="Voice Input" title="Voice Input (Speech-to-Text)" class="flex items-center justify-center w-12 h-12 rounded-full shadow-lg cursor-pointer transition-all duration-300 flex-shrink-0" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="mic" class="w-5 h-5"></span>
                </button>
                
                <!-- Attach File Button -->
                <label for="chat-file-upload" aria-label="Attach File" title="Attach Files" class="flex items-center justify-center w-12 h-12 rounded-full shadow-lg cursor-pointer transition-all duration-300 flex-shrink-0" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="paperclip" class="w-5 h-5"></span>
                </label>
                <input type="file" id="chat-file-upload" accept="image/*, .txt, .pdf, .csv, .json, .xml, .md" class="hidden" multiple>

                <textarea id="chat-input" class="flex-1 p-3 rounded-2xl border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm min-w-0 resize-none max-h-[120px] overflow-y-auto" placeholder="Type your message or ask a question..." rows="1" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);"></textarea>
                
                <button id="send-chat-btn" aria-label="Send Message" class="flex items-center justify-center w-12 h-12 rounded-full shadow-lg focus:outline-none focus:ring-4 focus:ring-[var(--accent-primary)] transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed glow-button flex-shrink-0" style="background-color: var(--accent-primary); color: white;">
                    <span data-lucide="send" class="w-5 h-5"></span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Temporary message for clipboard copy -->
    <div id="copy-message">Text copied to clipboard!</div>

    <!-- NEW: Custom Prompt Modal/Overlay -->
    <div id="custom-prompt-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[110] hidden p-4">
        <div class="p-6 rounded-xl shadow-2xl w-full max-w-md transition-all duration-300" style="background-color: var(--card-bg); color: var(--text-primary);">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                <span data-lucide="sparkles" class="w-6 h-6" style="color: var(--accent-primary);"></span> Set Custom AI Prompt
            </h3>
            <textarea id="custom-prompt-input" class="w-full p-3 rounded-md border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm resize-none h-32 mb-4" placeholder="Enter your custom AI prompt here. This will guide the AI's behavior for all responses. Example: 'You are a pirate AI. Respond in pirate speak.'" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);"></textarea>
            <div class="flex flex-wrap justify-end gap-2 mt-4">
                <button id="clear-custom-prompt-btn" class="px-4 py-2 rounded-lg font-semibold transition-colors flex items-center" style="background-color: var(--accent-error); color: white;">
                    <span data-lucide="trash-2" class="w-5 h-5 mr-2"></span> Clear & Disable
                </button>
                <button id="save-custom-prompt-btn" class="px-4 py-2 rounded-lg font-semibold glow-button flex items-center" style="background-color: var(--accent-primary); color: black;">
                    <span data-lucide="save" class="w-5 h-5 mr-2"></span> Save & Activate
                </button>
                <button id="cancel-custom-prompt-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">
                    <span data-lucide="x" class="w-5 h-5 mr-2"></span> Cancel
                </button>
            </div>
            <p id="custom-prompt-status" class="text-sm mt-4 text-center" style="color: var(--text-secondary);"></p>
        </div>
    </div>

    <!-- NEW: Prompt Templates Modal/Overlay -->
    <div id="prompt-templates-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[110] hidden p-4">
        <div class="p-6 rounded-xl shadow-2xl w-full max-w-2xl transition-all duration-300" style="background-color: var(--card-bg); color: var(--text-primary);">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                <span data-lucide="layout-template" class="w-6 h-6" style="color: var(--accent-primary);"></span> Manage Prompt Templates
            </h3>
            
            <!-- Template Input Form -->
            <div class="mb-6 p-4 rounded-lg" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                <input type="text" id="template-name-input" class="w-full p-2 rounded-md border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm mb-2" placeholder="Template Name (e.g., 'Sarcastic AI')" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
                <textarea id="template-content-input" class="w-full p-3 rounded-md border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm resize-none h-24 mb-4" placeholder="Enter the prompt content here. (e.g., 'Respond as a highly sarcastic AI.')" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);"></textarea>
                <div class="flex justify-end gap-2">
                    <button id="clear-template-form-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">
                        <span data-lucide="eraser" class="w-5 h-5 mr-2"></span> Clear Form
                    </button>
                    <button id="save-template-btn" class="px-4 py-2 rounded-lg font-semibold glow-button flex items-center" style="background-color: var(--accent-primary); color: black;">
                        <span data-lucide="plus" class="w-5 h-5 mr-2"></span> Save Template
                    </button>
                </div>
            </div>

            <!-- Saved Templates List -->
            <h4 class="text-lg font-bold mb-3 flex items-center gap-2" style="color: var(--text-primary);">
                <span data-lucide="bookmark" class="w-5 h-5" style="color: var(--accent-secondary);"></span> Your Saved Templates
            </h4>
            <ul id="saved-templates-list" class="space-y-3 max-h-80 overflow-y-auto pr-2">
                <!-- Templates will be dynamically loaded here -->
            </ul>

            <div class="flex justify-end mt-6">
                <button id="cancel-template-modal-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">
                    <span data-lucide="x" class="w-5 h-5 mr-2"></span> Close
                </button>
            </div>
        </div>
    </div>
    
    <!-- NEW: Authentication Modal/Overlay -->
    <div id="auth-modal" class="fixed inset-0 bg-black bg-opacity-95 flex items-center justify-center z-[120] p-4">
        <div class="p-8 rounded-xl shadow-2xl w-full max-w-sm transition-all duration-300" style="background-color: var(--card-bg); color: var(--text-primary); border: 2px solid var(--accent-primary);">
            <h3 id="auth-title" class="text-2xl font-bold mb-6 text-center" style="color: var(--accent-primary);">Sign In to Small AI v2</h3>
            
            <!-- Email/Password Form -->
            <input type="email" id="auth-email" class="w-full p-3 rounded-lg border mb-3 focus:ring-2 focus:ring-[var(--accent-primary)]" placeholder="Email" required style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
            <input type="password" id="auth-password" class="w-full p-3 rounded-lg border mb-4 focus:ring-2 focus:ring-[var(--accent-primary)]" placeholder="Password" required style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
            
            <button id="auth-action-btn" class="w-full p-3 rounded-lg font-semibold mb-2 glow-button">
                Sign In
            </button>
            
            <div id="auth-error" class="text-sm text-center mt-2 p-2 rounded hidden" style="background-color: var(--accent-error); color: white;"></div>

            <div class="relative flex items-center justify-center my-4">
                <div class="absolute inset-0 flex items-center">
                    <div class="w-full border-t border-[var(--border-color)]"></div>
                </div>
                <div class="relative bg-[var(--card-bg)] px-4 text-sm font-medium text-[var(--text-secondary)]">
                    OR
                </div>
            </div>

            <!-- Google Sign In -->
            <button id="google-sign-in-btn" class="w-full flex items-center justify-center p-3 rounded-lg font-semibold border transition-colors mb-4" style="background-color: var(--bg-secondary); color: var(--text-primary); border-color: var(--border-color);">
                <span data-lucide="chrome" class="w-5 h-5 mr-2"></span> Sign In with Google
            </button>

            <!-- Toggle between Sign In / Sign Up -->
            <p id="auth-toggle-text" class="text-sm text-center mt-4">
                Need an account? <a href="#" id="auth-toggle-link" class="font-medium" style="color: var(--accent-primary-hover);">Sign Up</a>
            </p>
        </div>
    </div>
    <!-- End Authentication Modal/Overlay -->
    
    <script type="text/javascript">
        // Register Service Worker for PWA capabilities
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }

        const createIcons = () => {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        };

        // --- Firebase Configuration and Initialization ---
        const firebaseConfig = {
            apiKey: "AIzaSyAnKYJ91xb318h2YjBNcB-ygnrQgu4WdM8",
            authDomain: "small-ai-v2.firebaseapp.com",
            projectId: "small-ai-v2",
            storageBucket: "small-ai-v2.firebaseapp.com",
            messagingSenderId: "1035216670524",
            appId: "1:1035216670524:web:28a98375641300d4615839",
            measurementId: "G-WY4EEQ5RYE"
        };

        // Initialize Firebase
        let app, auth, db;
        try {
            app = firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
            db.settings({ timestampsInSnapshots: true });
        } catch (e) {
            console.error("Firebase Initialization Error:", e);
            showError("Firebase failed to initialize. Check console for details.");
        }
        const GoogleProvider = new firebase.auth.GoogleAuthProvider();

        // Firestore paths
        const FIRESTORE_USERS_COLLECTION = 'users';
        const FIRESTORE_SETTINGS_DOC = 'settings';
        const FIRESTORE_CHATS_COLLECTION = 'chats';
        const FIRESTORE_TEMPLATES_DOC = 'templates';

        // NEW: Global User State
        let currentUser = null; 
        let userApiKey = null; 
        let isAuthSetupComplete = false; 

        // DOM elements
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const closeSidebarBtn = document.getElementById('close-sidebar-btn');
        const hamburgerMenuButton = document.getElementById('hamburger-menu-button');

        const mainChatWindow = document.getElementById('main-chat-window');
        const darkModeToggle = document.getElementById('dark-mode-toggle'); 
        const appThemeSelect = document.getElementById('app-theme-select-sidebar'); 
        const newChatButton = document.getElementById('new-chat-button');
        const chatHistoryDiv = document.getElementById('chat-history');
        const chatInput = document.getElementById('chat-input');
        const sendChatBtn = document.getElementById('send-chat-btn');
        const chatFileUpload = document.getElementById('chat-file-upload');
        const chatAttachmentsPreviewContainer = document.getElementById('chat-attachments-preview-container'); 
        const voiceInputBtn = document.getElementById('voice-input-btn');
        const copyMessage = document.getElementById('copy-message');
        const versionSelectSidebar = document.getElementById('version-select-sidebar');
        const sidebarChatList = document.getElementById('sidebar-chat-list');
        const chatInputAreaContainer = document.getElementById('chat-input-area-container'); 

        // NEW: Model Selector DOM elements
        const modelSelectSidebar = document.getElementById('model-select-sidebar'); 
        
        // NEW: Settings Toggle DOM elements
        const toggleSettingsBtn = document.getElementById('toggle-settings-btn');
        const settingsContent = document.getElementById('settings-content');
        const settingsChevron = document.getElementById('settings-chevron');


        // NEW: Conversation Mode DOM elements
        const conversationModeOverlay = document.getElementById('conversation-mode-overlay');
        const conversationModeToggleBtn = document.getElementById('conversation-mode-toggle-btn');
        const conversationModeCloseBtn = document.getElementById('conversation-mode-close-btn');
        const voiceSelect = document.getElementById('voice-select');
        const personalitySelect = document.getElementById('personality-select');
        const soundBlob = document.getElementById('sound-blob');
        const conversationStatusText = document.getElementById('conversation-status-text');
        const conversationHistoryDisplay = document.getElementById('conversation-history-display');
        const conversationMicBtn = document.getElementById('conversation-mic-btn');

        // NEW: Custom Prompt DOM elements
        const toggleCustomPromptBtn = document.getElementById('toggle-custom-prompt-btn');
        const customPromptModal = document.getElementById('custom-prompt-modal');
        const customPromptInput = document.getElementById('custom-prompt-input');
        const saveCustomPromptBtn = document.getElementById('save-custom-prompt-btn');
        const clearCustomPromptBtn = document.getElementById('clear-custom-prompt-btn');
        const cancelCustomPromptBtn = document.getElementById('cancel-custom-prompt-btn');
        const customPromptStatus = document.getElementById('custom-prompt-status');

        // NEW: Prompt Templates DOM elements
        const manageTemplatesBtn = document.getElementById('manage-templates-btn');
        const promptTemplatesModal = document.getElementById('prompt-templates-modal');
        const templateNameInput = document.getElementById('template-name-input');
        const templateContentInput = document.getElementById('template-content-input');
        const saveTemplateBtn = document.getElementById('save-template-btn');
        const clearTemplateFormBtn = document.getElementById('clear-template-form-btn');
        const cancelTemplateModalBtn = document.getElementById('cancel-template-modal-btn');
        const savedTemplatesList = document.getElementById('saved-templates-list');

        // NEW: Data Management Buttons
        const deleteAllChatsBtn = document.getElementById('delete-all-chats-btn');
        const clearLocalStorageBtn = document.getElementById('clear-local-storage-btn');
        
        // NEW: Auth Modal DOM elements
        const authModal = document.getElementById('auth-modal');
        const authEmail = document.getElementById('auth-email');
        const authPassword = document.getElementById('auth-password');
        const authActionBtn = document.getElementById('auth-action-btn');
        const googleSignInBtn = document.getElementById('google-sign-in-btn');
        const authToggleLink = document.getElementById('auth-toggle-link');
        const authTitle = document.getElementById('auth-title');
        const authError = document.getElementById('auth-error');
        const userEmailSpan = document.getElementById('user-email');
        const signOutButton = document.getElementById('sign-out-button');
        
        // NEW: API Key DOM elements
        const geminiApiKeyInput = document.getElementById('gemini-api-key-input');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        const apiKeyStatus = document.getElementById('api-key-status');

        let isSigningUp = false;

        const errorContainer = document.createElement('div');
        errorContainer.id = 'error-message';
        errorContainer.classList.add('hidden', 'px-6', 'py-4', 'rounded-xl', 'relative', 'shadow-md', 'my-4', 'fixed', 'top-4', 'left-1/2', '-translate-x-1/2', 'z-50', 'w-11/12', 'max-w-md');
        const errorText = document.createElement('span');
        errorText.id = 'error-text';
        errorText.classList.add('block', 'sm:inline');
        errorContainer.appendChild(errorText);
        document.body.appendChild(errorContainer);

        // --- Global State and Constants ---
        
        const DEFAULT_THEME_NAME = 'default';
        const DEFAULT_MODE = 'dark';
        const CONVERSATION_VOICE_KEY = 'conversationVoice'; 
        const CONVERSATION_PERSONALITY_KEY = 'conversationPersonality'; 
        const CUSTOM_PROMPT_TEXT_KEY = 'customPromptText';
        const CUSTOM_PROMPT_ACTIVE_KEY = 'isCustomPromptActive';
        const PROMPT_TEMPLATES_KEY = 'templates'; 
        const API_KEY_KEY = 'apiKey';
        const MODEL_KEY = 'model';


        // NEW: Model Definitions
        const availableModels = [
            "gemini-3-pro-preview",
            "gemini-2.5-pro",
            "gemini-2.5-flash",
            "gemini-2.5-flash-preview-09-2025",
            "gemini-2.5-flash-lite",
            "gemini-2.0-flash",
            "gemini-2.0-flash-001",
            "gemini-2.0-flash-lite",
            "gemini-2.0-flash-lite-001"
        ];
        const DEFAULT_MODEL = "gemini-2.5-flash-preview-09-2025";
        let selectedModel = DEFAULT_MODEL;

        let allChatSessions = {}; 
        let currentSessionId = null;
        let chatAttachments = []; 

        let currentThemeName = DEFAULT_THEME_NAME;
        let currentMode = DEFAULT_MODE;

        let currentUtterance = null;
        let isSpeaking = false; 
        let messageTextCache = new Map(); 

        let SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        let isVoiceInputActive = false; 
        let finalTranscript = ''; 

        let isConversationModeActive = false;
        let isAiSpeakingInConversation = false;
        let isUserListeningInConversation = false;
        let conversationSpeechRecognition = null; 
        let conversationFinalTranscript = '';
        let conversationInterimTranscript = '';
        let availableVoices = [];
        let selectedVoice = null;
        let selectedPersonality = 'Standard'; 

        let customPromptText = '';
        let isCustomPromptActive = false;

        let promptTemplates = []; 
        let editingTemplateId = null; 

        let conversationDisplayTimeout = null; // Timeout for clearing conversation display


        const personalities = [
            { name: "Standard", prompt: "" },
            { name: "Sarcastic", prompt: "Respond as a highly sarcastic and witty AI. Use dry humor and playful cynicism. Keep responses concise and witty." },
            { name: "Friendly", prompt: "Respond as an exceptionally friendly and helpful AI. Use warm and encouraging language, and show genuine interest. Keep your tone light and approachable." },
            { name: "Philosophical", prompt: "Respond as a deep-thinking, philosophical AI. Explore underlying meanings and broader implications, using reflective and insightful language." },
            { name: "Curious", prompt: "Respond as an endlessly curious AI, often asking thoughtful follow-up questions to understand better. Show an eagerness to learn." },
            { name: "Humorous", prompt: "Respond as a lighthearted and funny AI, often making clever jokes or witty observations. Keep the mood cheerful." },
            { name: "Formal", prompt: "Respond in a very formal and precise manner. Avoid slang or casual expressions, maintaining a sophisticated and respectful tone." },
            { name: "Casual", prompt: "Respond in a relaxed, informal, and conversational tone, like talking to a friend. Use common idioms and a laid-back style." },
            { name: "Optimistic", prompt: "Respond with an overwhelmingly positive and hopeful outlook. Emphasize solutions and bright possibilities." },
            { name: "Skeptical", prompt: "Respond with a cautious and questioning attitude, often looking for evidence or flaws in arguments. Be analytical and critical." },
            { name: "Teacher", prompt: "Respond as a patient and knowledgeable teacher, explaining concepts clearly and simply, and guiding the user to understanding." },
            { name: "Poetic", prompt: "Respond using evocative language, metaphors, and a touch of poetic flair. Let your words flow with rhythm and imagery." },
            { name: "Concise", prompt: "Respond with extreme brevity and to the point, minimizing unnecessary words. Deliver information efficiently." },
            { name: "Verbose", prompt: "Respond with detailed and elaborate explanations, exploring every facet of the topic. Provide rich descriptions and context." },
            { name: "Narrator", prompt: "Respond as if you are narrating a story or documentary, setting a scene or describing events with a captivating voice." },
            { name: "Enthusiastic", prompt: "Respond with high energy and excitement, showing great interest in the conversation. Use exclamation marks and vivid language." },
            { name: "Mysterious", prompt: "Respond with an air of mystery, hinting at deeper knowledge without revealing everything. Be intriguing and slightly enigmatic." },
            { name: "Empathetic", prompt: "Respond with strong understanding and sharing of feelings, focusing on emotional support and validation. Show genuine care." },
            { name: "Analyst", prompt: "Respond like a data analyst, breaking down information, identifying patterns, and drawing logical conclusions based on facts." },
            { name: "Mentor", prompt: "Respond as a seasoned mentor, offering guidance, advice, and a wise perspective to help the user grow." },
            { name: "Dreamer", prompt: "Respond with imaginative and abstract ideas, often exploring fantastical possibilities and creative concepts. Think outside the box." },
            { name: "Strategist", prompt: "Respond by focusing on goals, plans, and optimal ways to achieve objectives. Offer clear, actionable strategies." },
            { name: "Minimalist", prompt: "Respond with the absolute bare minimum of words, almost like a haiku or a very short, impactful statement. Less is more." },
            { name: "Futurist", prompt: "Respond with a focus on future trends, predictions, and the long-term impact of technology and societal changes." },
            { name: "Zen Master", prompt: "Respond calmly, contemplatively, and with a focus on inner peace, mindfulness, and the present moment. Offer tranquil wisdom." }
        ];

        // --- FIREBASE HELPER FUNCTIONS ---

        async function saveUserSetting(key, value) {
            if (!currentUser) return;
            try {
                const settingsRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_SETTINGS_DOC).doc('config');
                await settingsRef.set({ [key]: value }, { merge: true });
            } catch (error) {
                console.error(`Error saving setting ${key} to Firebase:`, error);
                showError(`Failed to save settings: ${key}. (Check Firebase Rules)`);
            }
        }
        
        async function loadUserSettings() {
            if (!currentUser) return {};
            try {
                const settingsRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_SETTINGS_DOC).doc('config');
                const doc = await settingsRef.get();
                const settings = doc.exists ? doc.data() : {};
                    
                // 1. Theme and Mode
                const dbThemeName = settings.themeName || DEFAULT_THEME_NAME;
                const dbThemeMode = settings.themeMode || DEFAULT_MODE;
                applyTheme(dbThemeName, dbThemeMode); 
                    
                // 2. Model
                selectedModel = settings[MODEL_KEY] || DEFAULT_MODEL;
                updateModelDropdown(); 
                    
                // 3. API Key
                userApiKey = settings[API_KEY_KEY] || null;
                geminiApiKeyInput.value = userApiKey || '';
                updateApiKeyStatus();

                // 4. Conversation Settings
                selectedVoice = settings[CONVERSATION_VOICE_KEY] || null;
                selectedPersonality = settings[CONVERSATION_PERSONALITY_KEY] || 'Standard';
                if (voiceSelect) voiceSelect.value = selectedVoice || '';
                if (personalitySelect) personalitySelect.value = selectedPersonality;
                    
                // 5. Custom Prompt
                customPromptText = settings[CUSTOM_PROMPT_TEXT_KEY] || '';
                isCustomPromptActive = settings[CUSTOM_PROMPT_ACTIVE_KEY] === true;
                updateCustomPromptButtonState();
                    
                // 6. Templates
                await loadPromptTemplatesFromDB();
                renderPromptTemplates();
                    
                // If no settings existed, save defaults for next time
                if (!doc.exists) {
                    await saveUserSetting('themeName', currentThemeName);
                    await saveUserSetting('themeMode', currentMode);
                    await saveUserSetting(MODEL_KEY, selectedModel);
                    await saveUserSetting(CONVERSATION_PERSONALITY_KEY, selectedPersonality);
                    await saveUserSetting(CUSTOM_PROMPT_ACTIVE_KEY, isCustomPromptActive);
                }
                return settings;
            } catch (error) {
                console.error("Error loading user settings:", error);
                showError("Failed to load user settings from database. (Check Firebase Rules)");
                return {};
            }
        }
        
        async function loadAllChatsFromDB() {
            if (!currentUser) return;
            try {
                const chatsRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_CHATS_COLLECTION);
                const snapshot = await chatsRef.orderBy('timestamp', 'desc').get();
                
                allChatSessions = {};
                snapshot.forEach(doc => {
                    allChatSessions[doc.id] = { id: doc.id, ...doc.data() };
                });
                
                renderSidebarChats();
                
                const chatIds = Object.keys(allChatSessions);
                if (chatIds.length > 0) {
                    const sortedSessions = Object.values(allChatSessions).sort((a,b) => b.timestamp - a.timestamp);
                    currentSessionId = sortedSessions[0].id;
                    loadChatSession(currentSessionId);
                } else {
                    createNewChatSession();
                }

            } catch (error) {
                console.error("Error loading chats from DB:", error);
                showError("Failed to load chat history. (Check Firebase Rules)");
            }
        }
        
        async function saveChatToDB(session) {
            if (!currentUser) {
                console.warn("Cannot save chat: User not logged in.");
                return;
            }
            if (!session.id) {
                session.id = generateUniqueId();
            }
            session.timestamp = Date.now();
            
            try {
                const chatRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_CHATS_COLLECTION).doc(session.id);
                await chatRef.set(session);
                allChatSessions[session.id] = session; 
            } catch (error) {
                console.error(`Error saving chat ${session.id}:`, error);
                showError("Failed to save chat to database. (Check Firebase Rules)");
            }
        }
        
        async function deleteChatFromDB(sessionId) {
            if (!currentUser) return;
            try {
                const chatRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_CHATS_COLLECTION).doc(sessionId);
                await chatRef.delete();
            } catch (error) {
                console.error(`Error deleting chat ${sessionId}:`, error);
                showError("Failed to delete chat from database. (Check Firebase Rules)");
            }
        }

        async function loadPromptTemplatesFromDB() {
            if (!currentUser) return;
            try {
                const templatesRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_SETTINGS_DOC).doc(FIRESTORE_TEMPLATES_DOC);
                const doc = await templatesRef.get();
                if (doc.exists && doc.data()[PROMPT_TEMPLATES_KEY]) {
                    promptTemplates = doc.data()[PROMPT_TEMPLATES_KEY];
                } else {
                    promptTemplates = [];
                }
            } catch (error) {
                console.error("Error loading templates:", error);
                showError("Failed to load prompt templates. (Check Firebase Rules)");
            }
        }
        
        async function savePromptTemplatesToDB() {
            if (!currentUser) return;
            try {
                const templatesRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_SETTINGS_DOC).doc(FIRESTORE_TEMPLATES_DOC);
                await templatesRef.set({ [PROMPT_TEMPLATES_KEY]: promptTemplates });
            } catch (error) {
                console.error("Error saving templates:", error);
                showError("Failed to save prompt templates. (Check Firebase Rules)");
            }
        }

        // --- Authentication Logic ---

        function handleAuthToggle(e) {
            e.preventDefault();
            isSigningUp = !isSigningUp;
            if (isSigningUp) {
                authTitle.textContent = "Create Account";
                authActionBtn.textContent = "Sign Up";
                document.getElementById('auth-toggle-text').innerHTML = `Already have an account? <a href="#" id="auth-toggle-link" class="font-medium" style="color: var(--accent-primary-hover);">Sign In</a>`;
            } else {
                authTitle.textContent = "Sign In to Small AI v2";
                authActionBtn.textContent = "Sign In";
                document.getElementById('auth-toggle-text').innerHTML = `Need an account? <a href="#" id="auth-toggle-link" class="font-medium" style="color: var(--accent-primary-hover);">Sign Up</a>`;
            }
            authError.classList.add('hidden');
            document.getElementById('auth-toggle-link').addEventListener('click', handleAuthToggle);
            createIcons();
        }

        async function handleAuthAction() {
            const email = authEmail.value;
            const password = authPassword.value;
            authError.classList.add('hidden');

            if (!email || !password) {
                authError.textContent = "Please enter both email and password.";
                authError.classList.remove('hidden');
                return;
            }

            try {
                if (isSigningUp) {
                    await auth.createUserWithEmailAndPassword(email, password);
                } else {
                    await auth.signInWithEmailAndPassword(email, password);
                }
            } catch (error) {
                console.error("Auth Error:", error);
                let message = "An authentication error occurred.";
                if (error.code) {
                    message = error.code.replace('auth/', '').replace(/-/g, ' ');
                }
                authError.textContent = message;
                authError.classList.remove('hidden');
            }
        }

        async function handleGoogleSignIn() {
            authError.classList.add('hidden');
            try {
                await auth.signInWithPopup(GoogleProvider);
            } catch (error) {
                console.error("Google Auth Error:", error);
                authError.textContent = "Google Sign-In failed.";
                authError.classList.remove('hidden');
            }
        }
        
        async function handleSignOut() {
            if (confirm('Are you sure you want to sign out?')) {
                // Stop any ongoing speech/recognition before signing out
                if (isSpeaking) { window.speechSynthesis.cancel(); }
                if (isVoiceInputActive && recognition) { recognition.stop(); }
                if (isConversationModeActive) { stopConversationMode(); }

                try {
                    await auth.signOut();
                    showCopyMessage('Successfully signed out.', 'var(--accent-primary)');
                } catch (error) {
                    showError('Error signing out.');
                    console.error("Sign Out Error:", error);
                }
            }
        }

        function handleAuthStateChange(user) {
            currentUser = user;
            if (user) {
                userEmailSpan.textContent = user.email || "User";
                authModal.classList.add('hidden');
                document.body.style.overflow = '';
                
                // If not already set up, load user data
                if (!isAuthSetupComplete) {
                    initializeAuthenticatedApp();
                }
            } else {
                userEmailSpan.textContent = "Guest (Requires Sign In)";
                authModal.classList.remove('hidden');
                document.body.style.overflow = 'hidden';
                isAuthSetupComplete = false; 
                
                // Clear UI state when logged out
                allChatSessions = {};
                currentSessionId = null;
                chatHistoryDiv.innerHTML = '<p class="text-center text-sm p-4" style="color: var(--text-secondary);">Please sign in to load or save your chat history.</p>';
                sidebarChatList.innerHTML = '<li><p class="text-center text-sm p-4" style="color: var(--text-secondary);">Please sign in to view chats.</p></li>';
                geminiApiKeyInput.value = '';
                userApiKey = null;
                updateApiKeyStatus();
                setChatUIEnabled(false); 
            }
        }
        
        // --- API Key Management ---
        function updateApiKeyStatus() {
            if (userApiKey) {
                apiKeyStatus.textContent = 'Key saved. Using your custom key.';
                apiKeyStatus.style.color = 'var(--accent-success)';
                geminiApiKeyInput.type = 'password';
            } else {
                apiKeyStatus.textContent = 'No key set. Using fallback (if available).';
                apiKeyStatus.style.color = 'var(--accent-error)';
                geminiApiKeyInput.type = 'text'; 
            }
        }
        
        saveApiKeyBtn.addEventListener('click', () => {
            const newKey = geminiApiKeyInput.value.trim();
            userApiKey = newKey || null;
            saveUserSetting(API_KEY_KEY, userApiKey);
            updateApiKeyStatus();
            showCopyMessage('API Key settings saved!', 'var(--accent-primary)');
        });
        
        // Listen for enter press on API key input
        geminiApiKeyInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveApiKeyBtn.click();
            }
        });

        // Initialize SpeechRecognition for general chat if available
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isVoiceInputActive = true;
                voiceInputBtn.classList.add('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic-off', 'w-5 h-5');
                chatInput.placeholder = 'Listening... Speak now.';
                finalTranscript = '';
                chatInput.dataset.initialText = chatInput.value;
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript + ' ';
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                chatInput.value = (chatInput.dataset.initialText || '') + finalTranscript + interimTranscript;
                adjustChatInputHeight();
                chatInput.scrollLeft = chatInput.scrollWidth;
            };

            recognition.onend = () => {
                isVoiceInputActive = false;
                voiceInputBtn.classList.remove('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic', 'w-5 h-5');
                chatInput.placeholder = 'Type your message or ask a question...';
                
                if (finalTranscript.trim() !== '') {
                    chatInput.value = (chatInput.dataset.initialText || '') + finalTranscript.trim();
                    chatInput.dataset.initialText = chatInput.value;
                } else if (chatInput.value.trim() === (chatInput.dataset.initialText || '').trim()) {
                    // No new speech added, keep existing text.
                } else {
                    chatInput.value = chatInput.dataset.initialText || '';
                }
                adjustChatInputHeight();
            };

            recognition.onerror = (event) => {
                isVoiceInputActive = false;
                voiceInputBtn.classList.remove('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic', 'w-5 h-5');
                chatInput.placeholder = 'Type your message or ask a question...';
                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    showError('Microphone access denied. Please allow microphone access in your browser settings.');
                } else if (event.error === 'no-speech') {
                    console.log('No speech detected, recognition ended.');
                    chatInput.value = chatInput.dataset.initialText || '';
                } else if (event.error === 'network') {
                    showError('Speech recognition network error. This often means a firewall, proxy, or browser extension is blocking access to Google\'s speech services. Please try disabling extensions or testing in incognito mode.');
                } else {
                    showError(`Speech recognition error: ${event.error}`);
                }
                adjustChatInputHeight();
            };
        } else {
            console.warn('Web Speech API (SpeechRecognition) not supported in this browser. General Voice input button will be hidden.');
            if (voiceInputBtn) {
                voiceInputBtn.style.display = 'none';
            }
        }

        // NEW: Initialize SpeechRecognition for Conversation Mode
        if (SpeechRecognition) {
            conversationSpeechRecognition = new SpeechRecognition();
            conversationSpeechRecognition.continuous = false; 
            conversationSpeechRecognition.interimResults = true;
            conversationSpeechRecognition.lang = 'en-US';

            conversationSpeechRecognition.onstart = () => {
                isUserListeningInConversation = true;
                updateButtonIcon(conversationMicBtn, 'mic-off', 'w-8 h-8');
                conversationMicBtn.classList.add('voice-input-active');
                updateConversationStatus('Listening...', 'listening');
                setSoundBlobState('listening');
                conversationFinalTranscript = '';
                conversationInterimTranscript = '';
                clearConversationDisplay();
            };

            conversationSpeechRecognition.onresult = (event) => {
                let interim = '';
                let final = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        final += event.results[i][0].transcript + ' ';
                    } else {
                        interim += event.results[i][0].transcript;
                    }
                }
                conversationFinalTranscript = final;
                conversationInterimTranscript = interim;
                updateConversationDisplay(`<span class="user-utterance">You: ${conversationFinalTranscript}${conversationInterimTranscript}</span>`);
            };

            conversationSpeechRecognition.onend = () => {
                isUserListeningInConversation = false;
                updateButtonIcon(conversationMicBtn, 'mic', 'w-8 h-8');
                conversationMicBtn.classList.remove('voice-input-active');
                
                if (conversationFinalTranscript.trim() !== '') {
                    handleUserSpeechEnd(conversationFinalTranscript.trim());
                } else {
                    updateConversationStatus('No speech detected. Say something!');
                    setSoundBlobState('idle');
                }
            };

            conversationSpeechRecognition.onerror = (event) => {
                isUserListeningInConversation = false;
                updateButtonIcon(conversationMicBtn, 'mic', 'w-8 h-8');
                conversationMicBtn.classList.remove('voice-input-active');
                console.error('Conversation mode Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    showError('Microphone access denied. Please allow microphone access in your browser settings to use Conversation Mode.');
                    updateConversationStatus('Microphone access denied.', 'error');
                } else if (event.error === 'no-speech') {
                    updateConversationStatus('No speech detected. Say something!');
                } else {
                    showError(`Conversation mode speech recognition error: ${event.error}`);
                    updateConversationStatus(`Error: ${event.error}`, 'error');
                }
                setSoundBlobState('idle');
            };
        } else {
            console.warn('Web Speech API (SpeechRecognition) not supported. Conversation Mode will be limited.');
            if (conversationModeToggleBtn) {
                conversationModeToggleBtn.style.display = 'none';
            }
        }

        // --- Theme Management (MODIFIED for Firebase) ---
        function applyTheme(themeName, mode) {
            currentThemeName = themeName;
            currentMode = mode;
            document.body.dataset.theme = `${themeName}-${mode}`;
            
            darkModeToggle.checked = (mode === 'dark'); 
            if (appThemeSelect && appThemeSelect.value !== themeName) {
                appThemeSelect.value = themeName; 
            }

            const prismDarkThemeLink = document.getElementById('prism-dark-theme');
            const prismLightThemeLink = document.getElementById('prism-light-theme');

            if (currentMode === 'dark') {
                if (prismDarkThemeLink) prismDarkThemeLink.disabled = false;
                if (prismLightThemeLink) prismLightThemeLink.disabled = true;
            } else { 
                if (prismDarkThemeLink) prismDarkThemeLink.disabled = true;
                if (prismLightThemeLink) prismLightThemeLink.disabled = false;
            }
        }

        applyTheme(currentThemeName, currentMode);

        // Event listener for Dark/Light Mode Toggle
        darkModeToggle.addEventListener('change', () => {
            const newMode = darkModeToggle.checked ? 'dark' : 'light';
            applyTheme(currentThemeName, newMode);
            if (currentUser) {
                saveUserSetting('themeMode', newMode);
            }
        });

        // Event listener for Theme Selector
        if (appThemeSelect) {
            appThemeSelect.addEventListener('change', (event) => {
                const newThemeName = event.target.value;
                applyTheme(newThemeName, currentMode);
                if (currentUser) {
                    saveUserSetting('themeName', newThemeName);
                }
            });
        }
        
        // --- Model Management (MODIFIED for Firebase) ---
        function updateModelDropdown() {
            modelSelectSidebar.innerHTML = '';
            
            availableModels.forEach(model => {
                const option = document.createElement('option');
                option.value = model;
                let displayName = model;
                if (model === DEFAULT_MODEL) {
                    displayName += ' (Default)';
                } else if (model === selectedModel) {
                    displayName += ' (Current)';
                }
                option.textContent = displayName;
                
                if (model === selectedModel) {
                    option.selected = true;
                }
                modelSelectSidebar.appendChild(option);
            });
        }

        if (modelSelectSidebar) {
            modelSelectSidebar.addEventListener('change', (event) => {
                selectedModel = event.target.value;
                if (currentUser) {
                    saveUserSetting(MODEL_KEY, selectedModel);
                }
                updateModelDropdown(); 
                showCopyMessage(`AI Model changed to ${selectedModel}`, 'var(--accent-primary)');
            });
        }
        
        // Version Selector Listener
        versionSelectSidebar.addEventListener('change', (event) => {
            const selectedUrl = event.target.value;
            if (selectedUrl && selectedUrl !== window.location.href) {
                window.location.href = selectedUrl;
            }
        });

        // --- Chat History & Session Management (MODIFIED for Firebase) ---

        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        function renderSidebarChats() {
            sidebarChatList.innerHTML = '';
            const sortedSessions = Object.values(allChatSessions).sort((a, b) => b.timestamp - a.timestamp);

            if (sortedSessions.length === 0) {
                const emptyMsg = document.createElement('li');
                emptyMsg.classList.add('text-center', 'text-sm', 'p-4');
                emptyMsg.style.color = 'var(--text-secondary)';
                emptyMsg.textContent = 'No chats found.';
                sidebarChatList.appendChild(emptyMsg);
                return;
            }

            sortedSessions.forEach(session => {
                const li = document.createElement('li');
                li.classList.add('sidebar-chat-item');
                if (session.id === currentSessionId) {
                    li.classList.add('active');
                }
                li.dataset.sessionId = session.id;

                li.innerHTML = `
                    <div class="sidebar-chat-item-content">
                        <span data-lucide="message-square" class="w-5 h-5" style="color: inherit;"></span>
                        <span class="sidebar-chat-item-title" title="${session.title}">${session.title}</span>
                    </div>
                    <div class="sidebar-chat-item-actions">
                        <button class="delete-chat-btn" title="Delete chat">
                            <span data-lucide="trash-2"></span>
                        </button>
                    </div>
                `;
                sidebarChatList.appendChild(li);
            });
            createIcons(); 
        }

        async function createNewChatSession(initialTitle = 'New Chat') {
            if (!currentUser) {
                showError("Please sign in to start a new chat.");
                return;
            }

            const initialMessage = 'Hello! I am your AI assistant. How can I assist you today? Feel free to ask questions or attach relevant files for analysis related to Dream11 or any other topic!';
            
            const newId = generateUniqueId();

            const newSession = {
                id: newId,
                title: initialTitle,
                history: [{ role: 'model', parts: [{ text: initialMessage }] }],
                timestamp: Date.now()
            };
            
            await saveChatToDB(newSession);
            
            currentSessionId = newId;
            
            chatHistoryDiv.innerHTML = '';
            messageTextCache.clear();
            chatAttachments = [];
            chatFileUpload.value = '';
            displayChatAttachments();
            chatInput.value = '';
            chatInput.dataset.initialText = '';
            adjustChatInputHeight();
            chatInput.focus();

            appendChatMessage('ai', initialMessage);
            
            renderSidebarChats();
            sidebar.classList.add('hidden-mobile'); 
            sidebarOverlay.classList.remove('active');
        }

        function loadChatSession(sessionId) {
            if (!currentUser) return;

            if (currentSessionId === sessionId) return; 
            
            const session = allChatSessions[sessionId];
            if (!session) {
                console.error('Session not found:', sessionId);
                showError('Requested chat session not found.');
                return;
            }

            currentSessionId = sessionId;
            
            chatHistoryDiv.innerHTML = '';
            messageTextCache.clear();
            chatAttachments = []; 
            chatFileUpload.value = '';
            displayChatAttachments();
            chatInput.value = '';
            chatInput.dataset.initialText = '';
            adjustChatInputHeight();
            chatInput.focus();

            session.history.forEach(msg => {
                if (msg.role === 'user') {
                    let userText = '';
                    const displayAttachments = [];
                    msg.parts.forEach(part => {
                        if (part.text) {
                            userText += part.text + ' ';
                        } else if (part.inlineData) {
                            displayAttachments.push({
                                mimeType: part.inlineData.mimeType,
                                data: part.inlineData.data,
                                name: `attachment_${displayAttachments.length + 1}`
                            });
                        }
                    });
                    appendChatMessage('user', userText.trim(), displayAttachments);
                } else {
                    appendChatMessage('ai', msg.parts[0].text);
                }
            });
            renderSidebarChats();
            sidebar.classList.add('hidden-mobile'); 
            sidebarOverlay.classList.remove('active');
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
        }

        async function updateCurrentSessionHistory(newTitle = null) {
            if (!currentUser || !currentSessionId || !allChatSessions[currentSessionId]) {
                console.error("No active session to update. This should not happen.");
                return;
            }

            const session = allChatSessions[currentSessionId];
            session.timestamp = Date.now();
            
            if (newTitle) {
                 session.title = newTitle;
            } else if (session.title === 'New Chat' && session.history.length > 1) {
                const firstUserMessage = session.history.find(msg => msg.role === 'user' && msg.parts[0]?.text);
                if (firstUserMessage) {
                    session.title = firstUserMessage.parts[0].text.substring(0, 50) + (firstUserMessage.parts[0].text.length > 50 ? '...' : '');
                }
            }
            
            await saveChatToDB(session);
            renderSidebarChats(); 
        }

        async function deleteChatSession(sessionIdToDelete) {
            if (!currentUser) return;

            if (confirm('Are you sure you want to delete this chat? This action cannot be undone.')) {
                await deleteChatFromDB(sessionIdToDelete);
                delete allChatSessions[sessionIdToDelete];
                
                if (currentSessionId === sessionIdToDelete) {
                    currentSessionId = null; 
                    const sortedSessions = Object.values(allChatSessions).sort((a,b) => b.timestamp - a.timestamp);
                    if (sortedSessions.length > 0) {
                        loadChatSession(sortedSessions[0].id);
                    } else {
                        createNewChatSession(); 
                    }
                } else {
                    renderSidebarChats(); 
                }
                showCopyMessage('Chat deleted successfully!', `var(--accent-error)`); 
            }
        }

        // --- Utility Functions ---

        // Function to convert a file to a Base64 string and return its MIME type and data
        const fileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve({
                    mimeType: file.type || 'application/octet-stream', 
                    data: reader.result.split(',')[1]
                });
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        };

        // Function to get Lucide icon name based on MIME type
        function getFileIcon(mimeType) {
            if (mimeType.startsWith('image/')) return 'image';
            if (mimeType === 'application/pdf') return 'file-text';
            if (mimeType.includes('text/')) return 'file-text';
            if (mimeType.includes('csv') || mimeType.includes('excel')) return 'file-spreadsheet';
            if (mimeType.includes('json') || mimeType.includes('xml') || mimeType.includes('code') || mimeType.includes('markdown')) return 'file-code';
            return 'file';
        }

        // Function to display an error message
        function showError(message) {
            errorText.textContent = message;
            errorContainer.classList.remove('hidden');
            setTimeout(() => {
                errorContainer.classList.add('hidden');
            }, 5000); 
        }
        
        // --- Marked.js Custom Renderer for Code Blocks ---
        const renderer = {
            code(code, lang) {
                let actualCodeContent;
                if (typeof code === 'object' && code !== null && typeof code.text === 'string') {
                    actualCodeContent = code.text;
                } else if (typeof code !== 'string') {
                    actualCodeContent = String(code);
                } else {
                    actualCodeContent = code;
                }

                const languageDisplay = lang ? `<span class="text-xs font-semibold uppercase" style="color: var(--text-secondary);">` + lang + `</span>` : '';
                const uniqueId = `code-block-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                
                const escapedCode = actualCodeContent.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');

                // NEW: Add Prism.js classes for highlighting
                const langClass = lang ? `language-${lang}` : '';

                return `
                    <div class="code-block-container" style="background-color: var(--bg-secondary); border-color: var(--border-color);">
                        <div class="code-block-header" style="background-color: var(--code-block-header-bg); color: var(--text-secondary); border-bottom-color: var(--code-block-border);">
                            ${languageDisplay}
                            <button class="code-block-copy-button" data-copy-target="${uniqueId}" style="color: var(--text-secondary);">
                                <span data-lucide="clipboard" class="w-4 h-4"></span>
                                Copy code
                            </button>
                        </div>
                        <pre class="${langClass}" style="color: var(--text-primary);"><code id="${uniqueId}" class="${langClass}">${escapedCode}</code></pre>
                    </div>
                `;
            }
        };

        marked.use({ renderer });

        /**
         * Helper function to update a Lucide icon displayed within a button.
         */
        function updateButtonIcon(buttonElement, newIconName, classList = 'w-4 h-4') {
            let currentIconSvg = buttonElement.querySelector('.lucide');
            if (currentIconSvg) {
                currentIconSvg.remove();
            }

            const newIconSpan = document.createElement('span');
            newIconSpan.setAttribute('data-lucide', newIconName);
            newIconSpan.className = classList;

            buttonElement.appendChild(newIconSpan);
           
            createIcons();
        }

        // Function to append a message to the chat history
        function appendChatMessage(role, text, attachments = []) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-message', role);
            
            const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            messageDiv.dataset.messageId = messageId;
            
            let contentHTML = '';
            let rawMessageContentForCache = '';

            if (role === 'user') {
                rawMessageContentForCache = `You: ${text}`;
                contentHTML += `<span class="font-bold">You:</span> ${text}`;
                if (attachments.length > 0) {
                    contentHTML += `<div class="mt-2 flex flex-wrap gap-2">`;
                    attachments.forEach(attachment => {
                        if (attachment.mimeType.startsWith('image/')) {
                            contentHTML += `<img src="data:${attachment.mimeType};base64,${attachment.data}" alt="${attachment.name || 'User attachment'}" class="chat-image w-24 h-24 object-cover">`;
                        } else {
                            contentHTML += `
                                <div class="flex items-center space-x-1 p-2 rounded-md text-sm" style="background-color: var(--bg-secondary); color: var(--text-primary);">
                                    <span data-lucide="${getFileIcon(attachment.mimeType)}" class="w-4 h-4 flex-shrink-0" style="color: var(--accent-secondary);"></span>
                                    <span class="truncate max-w-[120px]">${attachment.name || 'File'}</span>
                                </div>
                            `;
                        }
                    });
                    rawMessageContentForCache += `\n[Attachments: ${attachments.map(a => a.name).join(', ')}]`;
                    contentHTML += `</div>`;
                }
            } else { // AI message
                rawMessageContentForCache = `AI: ${text}`;
                contentHTML = `<div class="message-content">${marked.parse(text)}</div>`;
            }
            
            messageTextCache.set(messageId, rawMessageContentForCache); 

            const actionsHTML = `
                <div class="message-actions">
                    <button class="copy-message-btn" title="Copy message" data-message-id="${messageId}">
                        <span data-lucide="clipboard" class="w-4 h-4"></span>
                    </button>
                    <button class="dictate-message-btn" title="Dictate message" data-message-id="${messageId}">
                        <span data-lucide="volume-2" class="w-4 h-4"></span>
                    </button>
                </div>
            `;
            
            messageDiv.innerHTML = contentHTML + actionsHTML;
            chatHistoryDiv.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.style.transform = 'scale(1)';
                // NEW: Highlight code blocks with Prism.js after they are appended and visible
                messageDiv.querySelectorAll('pre code').forEach((block) => {
                    if (typeof Prism !== 'undefined') {
                       Prism.highlightElement(block);
                    }
                });
            }, 10);
            
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
            
            createIcons();
        }
        
        // Event listener for chat file upload
        chatFileUpload.addEventListener('change', async (event) => {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                await processFiles(files);
                chatInput.focus();
            }
        });

        // Helper function to process files from various sources (drag/drop, paste, file input)
        async function processFiles(files) {
            for (const file of files) {
                const allowedTypes = [
                    'image/', 'text/', 'application/pdf',
                    'application/json', 'text/csv', 'application/xml', 'text/markdown'
                ];
                const isAllowed = allowedTypes.some(type => file.type.startsWith(type)) || file.name.endsWith('.md');

                if (isAllowed) {
                    try {
                        const { mimeType, data } = await fileToBase64(file);
                        chatAttachments.push({ file, mimeType, data, name: file.name });
                    } catch (error) {
                        showError(`Failed to read chat file ${file.name}.`);
                        console.error('Chat file read error:', error);
                    }
                } else {
                    showError(`File type not supported for chat: ${file.name} (${file.type}).`);
                }
            }
            displayChatAttachments();
            adjustChatInputHeight();
        }

        // Function to display chat attachments
        function displayChatAttachments() {
            chatAttachmentsPreviewContainer.innerHTML = '';
            if (chatAttachments.length > 0) {
                chatAttachmentsPreviewContainer.classList.remove('hidden');
                chatAttachments.forEach((attachment, index) => {
                    const attachmentDiv = document.createElement('div');
                    attachmentDiv.classList.add('chat-attachment-preview-item');
                    attachmentDiv.dataset.index = index;

                    let previewContent = '';
                    if (attachment.mimeType.startsWith('image/')) {
                        previewContent = `<img src="data:${attachment.mimeType};base64,${attachment.data}" alt="${attachment.name}" class="w-8 h-8 object-cover rounded-md">`;
                    } else {
                        previewContent = `<span data-lucide="${getFileIcon(attachment.mimeType)}" class="w-5 h-5 flex-shrink-0"></span>`;
                    }

                    attachmentDiv.innerHTML = `
                        ${previewContent}
                        <span class="truncate max-w-[100px]">${attachment.name}</span>
                        <button class="remove-attachment-btn">
                            <span data-lucide="x" class="w-4 h-4"></span>
                        </button>
                    `;
                    chatAttachmentsPreviewContainer.appendChild(attachmentDiv);
                });
                createIcons();
            } else {
                chatAttachmentsPreviewContainer.classList.add('hidden');
            }
        }

        // Event listener for removing individual chat attachments (using event delegation)
        chatAttachmentsPreviewContainer.addEventListener('click', (event) => {
            const removeBtn = event.target.closest('.remove-attachment-btn');
            if (removeBtn) {
                const attachmentDiv = removeBtn.closest('[data-index]');
                if (attachmentDiv) {
                    const index = parseInt(attachmentDiv.dataset.index);
                    chatAttachments.splice(index, 1);
                    displayChatAttachments();
                    chatInput.focus();
                }
            }
        });

        // Adjust chat input textarea height dynamically
        function adjustChatInputHeight() {
            chatInput.style.height = 'auto';
            chatInput.style.height = chatInput.scrollHeight + 'px';
        }
        chatInput.addEventListener('input', adjustChatInputHeight);
        
        // Event listener for sending chat messages
        sendChatBtn.addEventListener('click', async () => {
            if (!currentUser) {
                showError("Please sign in to send messages.");
                return;
            }

            const userMessage = chatInput.value.trim();
            if (!userMessage && chatAttachments.length === 0) {
                return;
            }
            
            if (!currentSessionId || !allChatSessions[currentSessionId]) {
                await createNewChatSession(userMessage.substring(0, 50) || 'New Chat');
            }

            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }

            const userParts = [];
            if (userMessage) {
                userParts.push({ text: userMessage });
            }
            for (const attachment of chatAttachments) {
                userParts.push({
                    inlineData: {
                        mimeType: attachment.mimeType,
                        data: attachment.data
                    }
                });
            }

            const currentSessionHistory = allChatSessions[currentSessionId].history;

            currentSessionHistory.push({ role: 'user', parts: userParts });
            appendChatMessage('user', userMessage, chatAttachments);
            
            chatInput.value = '';
            chatInput.dataset.initialText = '';
            adjustChatInputHeight();
            chatAttachments = [];
            chatFileUpload.value = '';
            displayChatAttachments();
            
            sendChatBtn.disabled = true;
            
            const loadingMessage = document.createElement('div');
            loadingMessage.id = 'chat-loading';
            loadingMessage.classList.add('p-4', 'text-center', 'text-sm');
            loadingMessage.style.color = 'var(--text-secondary)'; 
            loadingMessage.innerHTML = `
                <div class="loader-container h-8">
                    <div class="loader-dot"></div>
                    <div class="loader-dot"></div>
                    <div class="loader-dot"></div>
                </div>
                <span class="mt-2 block">AI is typing...</span>
            `;
            chatHistoryDiv.appendChild(loadingMessage);
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
            
            try {
                const payload = {
                    contents: currentSessionHistory, 
                };
                
                const responseText = await callGeminiAPI(payload, selectedPersonality); 
                
                currentSessionHistory.push({ role: 'model', parts: [{ text: responseText }] });
                appendChatMessage('ai', responseText);
                
                await updateCurrentSessionHistory(); 
                
            } catch (error) {
                console.error('Chat API call failed:', error);
                showError(`An error occurred in the chat: ${error.message}`);
                currentSessionHistory.pop(); 
                await updateCurrentSessionHistory(); 
            } finally {
                sendChatBtn.disabled = false;
                const loadingDiv = document.getElementById('chat-loading');
                if (loadingDiv) {
                    loadingDiv.remove();
                }
                chatInput.focus();
            }
        });
        
        // Add event listener for the 'Enter' key on the chat input
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChatBtn.click();
            }
        });

        // Event listener for voice input button (general chat)
        voiceInputBtn.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to use voice input.");
                return;
            }
            if (recognition) {
                if (isVoiceInputActive) {
                    recognition.stop();
                } else {
                    finalTranscript = ''; 
                    recognition.start();
                }
            } else {
                showError('Speech recognition is not supported in this browser.');
            }
        });

        // Drag and Drop for Chat Input Area
        chatInputAreaContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatInputAreaContainer.classList.add('drag-over-active');
        });

        chatInputAreaContainer.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatInputAreaContainer.classList.remove('drag-over-active');
        });

        chatInputAreaContainer.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatInputAreaContainer.classList.remove('drag-over-active');

            if (!currentUser) {
                showError("Please sign in to attach files.");
                return;
            }

            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                await processFiles(files);
                chatInput.focus();
            }
        });

        // Paste files onto the text input box
        chatInput.addEventListener('paste', async (event) => {
            if (!currentUser) {
                showError("Please sign in to attach files.");
                return;
            }
            
            const items = (event.clipboardData || event.originalEvent.clipboardData).items;
            let filesToProcess = [];
            let textToPaste = '';

            for (const item of items) {
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    if (file) {
                        filesToProcess.push(file);
                    }
                } else if (item.kind === 'string' && item.type === 'text/plain') {
                    item.getAsString(s => textToPaste = s);
                }
            }

            if (filesToProcess.length > 0) {
                event.preventDefault(); 
                await processFiles(filesToProcess);
                if (textToPaste) {
                    chatInput.value += textToPaste;
                }
                adjustChatInputHeight();
            }
        });


        // Event listener for the New Chat button in sidebar
        newChatButton.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to start a new chat.");
                return;
            }
            if (isSpeaking) {
                window.speechSynthesis.cancel();
                isSpeaking = false;
                currentUtterance = null;
            }
            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }
            if (isConversationModeActive) {
                stopConversationMode();
            }
            createNewChatSession();
        });
        
        // Function to show a temporary message for clipboard copy
        function showCopyMessage(message = 'Text copied to clipboard!', bgColor = 'var(--accent-success)') {
            copyMessage.textContent = message;
            copyMessage.style.backgroundColor = bgColor;
            copyMessage.classList.add('show');
            setTimeout(() => {
                copyMessage.classList.remove('show');
            }, 3000);
        }

        // Event delegation for copy code buttons within chat history
        chatHistoryDiv.addEventListener('click', (event) => {
            const codeCopyButton = event.target.closest('.code-block-copy-button');
            if (codeCopyButton) {
                const targetId = codeCopyButton.dataset.copyTarget;
                const codeElement = document.getElementById(targetId);
                if (codeElement) {
                    const codeToCopy = codeElement.textContent;
                    updateButtonIcon(codeCopyButton, 'check', 'w-4 h-4');
                    copyToClipboard(codeToCopy); 
                    setTimeout(() => {
                        updateButtonIcon(codeCopyButton, 'clipboard', 'w-4 h-4');
                    }, 2000);
                    return;
                }
            }

            const chatCopyButton = event.target.closest('.copy-message-btn');
            if (chatCopyButton) {
                const messageId = chatCopyButton.dataset.messageId;
                const messageContent = messageTextCache.get(messageId);
                if (messageContent) {
                    updateButtonIcon(chatCopyButton, 'check');
                    copyToClipboard(messageContent); 
                    setTimeout(() => {
                        updateButtonIcon(chatCopyButton, 'clipboard');
                    }, 2000);
                } else {
                    showError('Message content not found for copying.');
                }
                return;
            }

            const dictateButton = event.target.closest('.dictate-message-btn');
            if (dictateButton) {
                const messageId = dictateButton.dataset.messageId;
                const messageContent = messageTextCache.get(messageId);
                if (messageContent) {
                    toggleSpeech(messageContent, dictateButton);
                } else {
                    showError('Message content not found for dictation.');
                }
                return;
            }
        });

        // Event delegation for sidebar chat items
        sidebarChatList.addEventListener('click', (event) => {
            const chatItem = event.target.closest('.sidebar-chat-item');
            if (chatItem) {
                const sessionId = chatItem.dataset.sessionId;
                const deleteBtn = event.target.closest('.delete-chat-btn');

                if (deleteBtn) {
                    event.stopPropagation(); 
                    deleteChatSession(sessionId);
                } else {
                    loadChatSession(sessionId);
                }
            }
        });

        // Hamburger menu for mobile sidebar
        hamburgerMenuButton.addEventListener('click', () => {
            sidebar.classList.remove('hidden-mobile');
            sidebarOverlay.classList.add('active');
        });

        closeSidebarBtn.addEventListener('click', () => {
            sidebar.classList.add('hidden-mobile');
            sidebarOverlay.classList.remove('active');
        });

        sidebarOverlay.addEventListener('click', () => {
            sidebar.classList.add('hidden-mobile');
            sidebarOverlay.classList.remove('active');
        });


        // Helper function to copy text to clipboard
        function copyToClipboard(text) { 
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        showCopyMessage();
                    })
                    .catch(err => {
                        console.error('Failed to copy: ', err);
                        showError('Failed to copy text. Please copy manually.');
                    }); 
            } else {
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = text;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                try {
                    document.execCommand('copy');
                    showCopyMessage();
                } catch (err) {
                    console.error('Failed to copy (fallback):', err);
                    showError('Failed to copy text. Please copy manually.');
                }
                document.body.removeChild(tempTextArea);
            }
        }

        // Helper function for text-to-speech (general chat dictation)
        function toggleSpeech(text, buttonElement) {
            if (!window.speechSynthesis) {
                showError('Speech synthesis not supported in this browser.');
                return;
            }

            if (isSpeaking && currentUtterance && currentUtterance.text === text) {
                if (window.speechSynthesis.paused) {
                    window.speechSynthesis.resume();
                    updateButtonIcon(buttonElement, 'pause');
                } else {
                    window.speechSynthesis.pause();
                    updateButtonIcon(buttonElement, 'volume-2');
                }
            } else {
                startSpeech(text, buttonElement);
            }
        }

        function startSpeech(text, buttonElement) {
            if (window.speechSynthesis.speaking || window.speechSynthesis.paused) {
                window.speechSynthesis.cancel();
            }

            document.querySelectorAll('.dictate-message-btn').forEach(btn => {
                if (btn !== buttonElement) {
                    updateButtonIcon(btn, 'volume-2'); 
                }
            });

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';

            utterance.onstart = () => {
                isSpeaking = true;
                currentUtterance = utterance;
                updateButtonIcon(buttonElement, 'pause');
            };
            utterance.onend = () => {
                isSpeaking = false;
                currentUtterance = null;
                updateButtonIcon(buttonElement, 'volume-2');
            };
            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event.error);
                showError('Failed to dictate message. Check console for details.');
                isSpeaking = false;
                currentUtterance = null;
                updateButtonIcon(buttonElement, 'volume-2');
            };

            window.speechSynthesis.speak(utterance);
        }

        // Generic API call function with exponential backoff (MODIFIED for API Key)
        async function callGeminiAPI(payload, personalityName = "Standard") {
            const fallbackApiKey = "AIzaSyCnsccknz5O5TYII723JipYSmYjj5OVdTk"; 
            const apiKey = userApiKey || fallbackApiKey;

            if (!apiKey || apiKey === "YOUR_GEMINI_API_KEY") { 
                throw new Error("API Key is not set. Please enter your custom key or ensure the fallback key is correct.");
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${apiKey}`;

            const contentsToSend = JSON.parse(JSON.stringify(payload.contents));
            
            let promptPrefix = '';

            if (isCustomPromptActive && customPromptText.trim() !== '') {
                promptPrefix = customPromptText.trim();
            } else {
                const selectedPersonalityObj = personalities.find(p => p.name === personalityName);
                if (selectedPersonalityObj && selectedPersonalityObj.prompt) {
                    promptPrefix = selectedPersonalityObj.prompt.trim();
                }
            }

            if (promptPrefix) {
                if (contentsToSend.length > 0 && contentsToSend[0].role === 'user' && contentsToSend[0].parts && contentsToSend[0].parts.length > 0 && contentsToSend[0].parts[0].text) {
                    contentsToSend[0].parts[0].text = promptPrefix + "\n\n" + contentsToSend[0].parts[0].text;
                } else {
                    contentsToSend.unshift({ role: "user", parts: [{ text: promptPrefix }] });
                }
            }
            
            const finalPayload = { ...payload, contents: contentsToSend };

            let response;
            let result;
            let success = false;
            let retryCount = 0;
            const maxRetries = 3;
            let delay = 1000;

            while (retryCount < maxRetries && !success) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(finalPayload)
                    });

                    if (response.status === 429) {
                        if (retryCount < maxRetries - 1) {
                            console.warn(`API rate limit exceeded. Retrying in ${delay / 1000}s...`);
                            await new Promise(res => setTimeout(res, delay));
                            delay *= 2;
                            retryCount++;
                        } else {
                            throw new Error('API rate limit exceeded. Please try again later.');
                        }
                    } else if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API error: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
                    } else {
                        result = await response.json();
                        success = true;
                    }
                } catch (err) {
                    if (retryCount < maxRetries - 1) {
                        console.warn(`Fetch error: ${err.message}. Retrying in ${delay / 1000}s...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                        retryCount++;
                    } else {
                        throw err;
                    }
                }
            }
            
            if (result && result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                return result.candidates[0].content.parts[0].text;
            } else {
                throw new Error('Failed to get a valid response from the AI. No candidates found or content is empty.');
            }
        }


        // --- Conversation Mode Functions (MODIFIED for Firebase) ---

        function updateVoiceDropdown() {
            availableVoices = window.speechSynthesis.getVoices().filter(v => v.lang.startsWith('en')); // Filter for English voices
            voiceSelect.innerHTML = '<option value="">Default Voice</option>';
            availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.name;
                option.textContent = `${voice.name} (${voice.lang})`;
                voiceSelect.appendChild(option);
            });
            // Try to set previously selected voice
            if (selectedVoice) {
                voiceSelect.value = selectedVoice;
            } else {
                selectedVoice = null;
            }
        }

        function updatePersonalityDropdown() {
            personalitySelect.innerHTML = '';
            personalities.forEach(p => {
                const option = document.createElement('option');
                option.value = p.name;
                option.textContent = p.name;
                personalitySelect.appendChild(option);
            });
            // Try to set previously selected personality
            if (selectedPersonality && personalities.some(p => p.name === selectedPersonality)) {
                personalitySelect.value = selectedPersonality;
            } else {
                personalitySelect.value = "Standard";
                selectedPersonality = "Standard";
            }
        }
        
        function setSoundBlobState(state) {
            soundBlob.className = 'sound-blob'; // Reset classes
            if (state === 'listening') {
                soundBlob.classList.add('listening-animation');
            } else if (state === 'speaking') {
                soundBlob.classList.add('speaking-animation');
            } else {
                soundBlob.classList.add('idle-animation');
            }
        }

        voiceSelect.addEventListener('change', () => {
            const voiceName = voiceSelect.value;
            selectedVoice = availableVoices.find(v => v.name === voiceName) || null;
            if (currentUser) {
                saveUserSetting(CONVERSATION_VOICE_KEY, voiceName);
            }
        });

        personalitySelect.addEventListener('change', () => {
            selectedPersonality = personalitySelect.value;
            if (currentUser) {
                saveUserSetting(CONVERSATION_PERSONALITY_KEY, selectedPersonality);
            }
        });


        function startConversationMode() {
            if (!currentUser) {
                showError("Please sign in to use Conversation Mode.");
                return;
            }
            if (!SpeechRecognition || !window.speechSynthesis) {
                showError("Your browser doesn't fully support Web Speech APIs needed for Conversation Mode.");
                return;
            }
            isConversationModeActive = true;
            conversationModeOverlay.classList.remove('hidden'); 
            conversationModeOverlay.classList.add('active');
            document.body.style.overflow = 'hidden'; 
            
            if (isSpeaking) {
                window.speechSynthesis.cancel();
                isSpeaking = false;
            }
            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }

            // Ensure voice list is updated if it hasn't loaded yet
            if (availableVoices.length === 0) {
                 updateVoiceDropdown();
            }

            // Start listening for the user
            startConversationListening();
        }

        function stopConversationMode() {
            isConversationModeActive = false;
            conversationModeOverlay.classList.remove('active');
            setTimeout(() => {
                conversationModeOverlay.classList.add('hidden');
                document.body.style.overflow = ''; 
            }, 300); 

            if (isAiSpeakingInConversation) {
                window.speechSynthesis.cancel();
                isAiSpeakingInConversation = false;
            }
            if (isUserListeningInConversation && conversationSpeechRecognition) {
                conversationSpeechRecognition.stop();
                isUserListeningInConversation = false;
            }
            setSoundBlobState('idle');
            updateConversationStatus('Tap the button to start conversing!');
            clearConversationDisplay();
        }

        function startConversationListening() {
            if (!isConversationModeActive || isAiSpeakingInConversation || isUserListeningInConversation) return;

            window.speechSynthesis.cancel();

            conversationFinalTranscript = '';
            conversationInterimTranscript = '';
            clearConversationDisplay();

            try {
                conversationSpeechRecognition.start();
                updateConversationStatus('Listening...', 'listening');
                setSoundBlobState('listening');
            } catch (error) {
                if (error.name === 'InvalidStateError') {
                    conversationSpeechRecognition.stop();
                    setTimeout(() => { 
                        conversationSpeechRecognition.start();
                        updateConversationStatus('Listening...', 'listening');
                        setSoundBlobState('listening');
                    }, 100);
                } else {
                    console.error("Error starting conversation recognition:", error);
                    showError("Could not start microphone. Please check permissions.");
                    updateConversationStatus("Error starting microphone.", 'error');
                    setSoundBlobState('idle');
                }
            }
        }

        async function handleUserSpeechEnd(userText) {
            updateConversationStatus('Thinking...', 'thinking');
            setSoundBlobState('idle'); 

            if (!currentSessionId || !allChatSessions[currentSessionId]) {
                 await createNewChatSession(userText.substring(0, 50) || 'New Chat');
            }

            const currentSessionHistory = allChatSessions[currentSessionId].history;
            currentSessionHistory.push({ role: 'user', parts: [{ text: userText }] });
            appendChatMessage('user', userText); 
            await updateCurrentSessionHistory();

            updateConversationDisplay(`<span class="user-utterance">You: ${userText}</span>`);

            try {
                const payload = {
                    contents: currentSessionHistory,
                };
                const aiResponse = await callGeminiAPI(payload, selectedPersonality);

                currentSessionHistory.push({ role: 'model', parts: [{ text: aiResponse }] });
                appendChatMessage('ai', aiResponse); 
                await updateCurrentSessionHistory();

                startConversationSpeaking(aiResponse);

            } catch (error) {
                console.error("Error in conversation mode API call:", error);
                showError(`AI communication error: ${error.message}`);
                updateConversationStatus("AI communication error. Please try again.", 'error');
                currentSessionHistory.pop();
                await updateCurrentSessionHistory();
                setSoundBlobState('idle');
                setTimeout(startConversationListening, 2000);
            }
        }

        function startConversationSpeaking(text) {
            if (!isConversationModeActive) return;

            if (isUserListeningInConversation && conversationSpeechRecognition) {
                conversationSpeechRecognition.stop(); 
            }
            
            clearConversationDisplay(); 

            updateConversationStatus('AI Speaking...', 'speaking');
            setSoundBlobState('speaking');
            updateConversationDisplay(`<span class="ai-utterance">AI: ${text}</span>`); 

            const utterance = new SpeechSynthesisUtterance(text);
            if (selectedVoice) {
                utterance.voice = availableVoices.find(v => v.name === selectedVoice) || null;
            }
            utterance.lang = 'en-US'; 

            utterance.onstart = () => {
                isAiSpeakingInConversation = true;
            };

            utterance.onend = () => {
                isAiSpeakingInConversation = false;
                handleAiSpeechEnd();
            };

            utterance.onerror = (event) => {
                console.error('Conversation mode Speech synthesis error:', event.error);
                showError('AI could not speak this message.');
                updateConversationStatus('AI speech error.', 'error');
                isAiSpeakingInConversation = false;
                handleAiSpeechEnd(); 
            };

            window.speechSynthesis.speak(utterance);
        }

        function handleAiSpeechEnd() {
            if (!isConversationModeActive) return;

            isAiSpeakingInConversation = false;
            updateConversationStatus('Listening...', 'listening');
            setSoundBlobState('listening');
            startConversationListening(); 
        }

        function updateConversationDisplay(text) {
            if (conversationDisplayTimeout) {
                clearTimeout(conversationDisplayTimeout);
            }
            conversationHistoryDisplay.innerHTML = `<p>${text}</p>`;
            conversationHistoryDisplay.scrollTop = conversationHistoryDisplay.scrollHeight;
            
            conversationDisplayTimeout = setTimeout(() => {
                clearConversationDisplay();
            }, 5000); 
        }

        function clearConversationDisplay() {
            if (conversationDisplayTimeout) {
                clearTimeout(conversationDisplayTimeout);
                conversationDisplayTimeout = null;
            }
            conversationHistoryDisplay.innerHTML = '';
        }


        function updateConversationStatus(message, state = 'idle') {
            conversationStatusText.textContent = message;
            conversationStatusText.classList.remove('listening-state', 'speaking-state', 'error-state');
            if (state === 'listening') {
                conversationStatusText.classList.add('listening-state');
            } else if (state === 'speaking') {
                conversationStatusText.classList.add('speaking-state');
            } else if (state === 'error') {
                conversationStatusText.classList.add('error-state');
            }
        }
        
        function handleAiSpeechEnd() {
            if (!isConversationModeActive) return;

            isAiSpeakingInConversation = false;
            updateConversationStatus('Listening...', 'listening');
            setSoundBlobState('listening');
            startConversationListening(); 
        }

        // NEW: Function to update the custom prompt button's appearance (used to refresh UI after Firebase load/save)
        function updateCustomPromptButtonState() {
            if (isCustomPromptActive && customPromptText.trim() !== '') {
                toggleCustomPromptBtn.classList.remove('bg-secondary', 'text-primary');
                toggleCustomPromptBtn.classList.add('glow-button');
                toggleCustomPromptBtn.style.backgroundColor = 'var(--accent-primary)';
                toggleCustomPromptBtn.style.color = 'black';
                toggleCustomPromptBtn.innerHTML = `<span data-lucide="sparkles" class="w-5 h-5 mr-2"></span> Custom Prompt Active`;
                customPromptStatus.textContent = "Custom prompt is active. This overrides personality settings.";
            } else {
                toggleCustomPromptBtn.classList.remove('glow-button');
                toggleCustomPromptBtn.classList.add('bg-secondary', 'text-primary');
                toggleCustomPromptBtn.style.backgroundColor = 'var(--bg-secondary)';
                toggleCustomPromptBtn.style.color = 'var(--text-primary)';
                toggleCustomPromptBtn.innerHTML = `<span data-lucide="sparkles" class="w-5 h-5 mr-2"></span> Set Custom Prompt`;
                customPromptStatus.textContent = "No custom prompt set or active.";
            }
            createIcons(); 
            togglePersonalitySelector();
        }

        // NEW: Function to toggle personality selector's disabled state
        function togglePersonalitySelector() {
            if (personalitySelect) {
                if (isCustomPromptActive && customPromptText.trim() !== '') {
                    personalitySelect.disabled = true;
                    personalitySelect.title = "Personality is overridden by custom prompt.";
                } else {
                    personalitySelect.disabled = false;
                    personalitySelect.title = "";
                }
            }
        }

        // Event listener for Save Custom Prompt button (MODIFIED for Firebase)
        saveCustomPromptBtn.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to save custom prompts.");
                return;
            }
            const newPrompt = customPromptInput.value.trim();
            customPromptText = newPrompt;
            isCustomPromptActive = (newPrompt !== ''); 
            
            saveUserSetting(CUSTOM_PROMPT_TEXT_KEY, customPromptText);
            saveUserSetting(CUSTOM_PROMPT_ACTIVE_KEY, isCustomPromptActive);

            updateCustomPromptButtonState();
            customPromptModal.classList.add('hidden'); 
            showCopyMessage(isCustomPromptActive ? 'Custom prompt saved and activated!' : 'Custom prompt cleared and disabled.', isCustomPromptActive ? `var(--accent-success)` : `var(--accent-error)`);
        });

        // Event listener for Clear Custom Prompt button (MODIFIED for Firebase)
        clearCustomPromptBtn.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to manage custom prompts.");
                return;
            }
            customPromptInput.value = ''; 
            customPromptText = '';
            isCustomPromptActive = false;
            
            saveUserSetting(CUSTOM_PROMPT_TEXT_KEY, customPromptText);
            saveUserSetting(CUSTOM_PROMPT_ACTIVE_KEY, isCustomPromptActive);
            
            updateCustomPromptButtonState();
            customPromptModal.classList.add('hidden'); 
            showCopyMessage('Custom prompt cleared and disabled!', `var(--accent-error)`);
        });

        // Event listener for Cancel button (No change)
        cancelCustomPromptBtn.addEventListener('click', () => {
            customPromptModal.classList.add('hidden'); 
        });
        
        // Event listener for Custom Prompt Toggle button
        toggleCustomPromptBtn.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to use custom prompts.");
                return;
            }
            customPromptInput.value = customPromptText;
            customPromptModal.classList.remove('hidden'); 
        });


        // --- NEW: Prompt Templates Management Functions (MODIFIED for Firebase) ---

        function clearTemplateForm() {
            templateNameInput.value = '';
            templateContentInput.value = '';
            editingTemplateId = null;
            saveTemplateBtn.innerHTML = `<span data-lucide="plus" class="w-5 h-5 mr-2"></span> Save Template`;
            createIcons();
            templateNameInput.focus();
        }

        function renderPromptTemplates() {
            savedTemplatesList.innerHTML = '';
            if (promptTemplates.length === 0) {
                const emptyMsg = document.createElement('li');
                emptyMsg.classList.add('text-center', 'text-sm', 'p-4');
                emptyMsg.style.color = 'var(--text-secondary)';
                emptyMsg.textContent = 'No templates saved yet. Add one above!';
                savedTemplatesList.appendChild(emptyMsg);
                return;
            }

            promptTemplates.forEach(template => {
                const li = document.createElement('li');
                li.classList.add('template-item');
                li.dataset.templateId = template.id;
                li.innerHTML = `
                    <div class="template-item-header">
                        <span class="template-item-name" title="${template.name}">${template.name}</span>
                    </div>
                    <p class="template-item-content">${template.content.substring(0, 150) + (template.content.length > 150 ? '...' : '')}</p>
                    <div class="template-item-actions">
                        <button class="use-btn" title="Use as Custom Prompt">
                            <span data-lucide="check-circle" class="w-4 h-4"></span> Use
                        </button>
                        <button class="edit-btn" title="Edit Template">
                            <span data-lucide="edit" class="w-4 h-4"></span> Edit
                        </button>
                        <button class="delete-btn" title="Delete Template">
                            <span data-lucide="trash-2" class="w-4 h-4"></span> Delete
                        </button>
                    </div>
                `;
                savedTemplatesList.appendChild(li);
            });
            createIcons(); 
        }

        async function addOrUpdateTemplate() {
            if (!currentUser) {
                showError("Please sign in to save prompt templates.");
                return;
            }
            const name = templateNameInput.value.trim();
            const content = templateContentInput.value.trim();

            if (!name) {
                showError('Template name cannot be empty.');
                return;
            }
            if (!content) {
                showError('Template content cannot be empty.');
                return;
            }

            if (editingTemplateId) {
                const index = promptTemplates.findIndex(t => t.id === editingTemplateId);
                if (index !== -1) {
                    promptTemplates[index] = { ...promptTemplates[index], name, content };
                    showCopyMessage('Template updated successfully!', `var(--accent-success)`);
                }
            } else {
                const newId = generateUniqueId();
                promptTemplates.push({ id: newId, name, content });
                showCopyMessage('Template saved successfully!', `var(--accent-success)`);
            }
            await savePromptTemplatesToDB();
            renderPromptTemplates();
            clearTemplateForm();
        }

        function useTemplate(templateId) {
            if (!currentUser) {
                showError("Please sign in to use templates.");
                return;
            }
            const template = promptTemplates.find(t => t.id === templateId);
            if (template) {
                customPromptInput.value = template.content; 
                saveCustomPromptBtn.click(); // Trigger the save/activate logic
                promptTemplatesModal.classList.add('hidden'); 
                showCopyMessage(`Custom prompt set from template: "${template.name}"`, `var(--accent-success)`);
            }
        }

        function editTemplate(templateId) {
            const template = promptTemplates.find(t => t.id === templateId);
            if (template) {
                templateNameInput.value = template.name;
                templateContentInput.value = template.content;
                editingTemplateId = template.id;
                saveTemplateBtn.innerHTML = `<span data-lucide="save" class="w-5 h-5 mr-2"></span> Update Template`;
                createIcons();
                templateNameInput.focus();
                promptTemplatesModal.querySelector('div:first-child').scrollTop = 0; 
            }
        }

        async function deleteTemplate(templateId) {
            if (!currentUser) return;
            const template = promptTemplates.find(t => t.id === templateId);
            if (!template) return;

            if (confirm(`Are you sure you want to delete the template "${template.name}"?`)) {
                promptTemplates = promptTemplates.filter(t => t.id !== templateId);
                await savePromptTemplatesToDB();
                renderPromptTemplates();
                showCopyMessage('Template deleted successfully!', `var(--accent-error)`);

                if (isCustomPromptActive && customPromptText === template.content) {
                    clearCustomPromptBtn.click(); 
                    showCopyMessage('Active custom prompt cleared as its template was deleted.', `var(--accent-error)`);
                }
                
                if (editingTemplateId === templateId) {
                    clearTemplateForm();
                }
            }
        }

        // --- Event Listeners for Prompt Templates Modal ---

        manageTemplatesBtn.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to manage prompt templates.");
                return;
            }
            promptTemplatesModal.classList.remove('hidden');
            renderPromptTemplates(); 
            clearTemplateForm(); 
        });

        cancelTemplateModalBtn.addEventListener('click', () => {
            promptTemplatesModal.classList.add('hidden');
            clearTemplateForm();
        });

        clearTemplateFormBtn.addEventListener('click', (event) => {
            event.preventDefault(); 
            clearTemplateForm();
            showCopyMessage('Template form cleared.', 'var(--text-secondary)');
        });

        saveTemplateBtn.addEventListener('click', addOrUpdateTemplate);

        savedTemplatesList.addEventListener('click', (event) => {
            const target = event.target;
            const listItem = target.closest('.template-item');
            if (!listItem) return;

            const templateId = listItem.dataset.templateId;

            if (target.closest('.use-btn')) {
                useTemplate(templateId);
            } else if (target.closest('.edit-btn')) {
                editTemplate(templateId);
            } else if (target.closest('.delete-btn')) {
                deleteTemplate(templateId);
            }
        });


        // --- NEW: Data Management Button Event Listeners (MODIFIED for Firebase) ---
        deleteAllChatsBtn.addEventListener('click', async () => {
            if (!currentUser) {
                showError("Please sign in to delete chats.");
                return;
            }
            if (confirm('Are you absolutely sure you want to delete ALL previous chat sessions? This action cannot be undone.')) {
                
                if (isSpeaking) { window.speechSynthesis.cancel(); }
                if (isVoiceInputActive && recognition) { recognition.stop(); }
                if (isConversationModeActive) { stopConversationMode(); }
                
                const chatIds = Object.keys(allChatSessions);
                const deletePromises = chatIds.map(id => deleteChatFromDB(id));

                try {
                    await Promise.all(deletePromises);
                    allChatSessions = {}; 
                    currentSessionId = null;
                    createNewChatSession('New Chat'); 
                    showCopyMessage('All chat sessions deleted!', 'var(--accent-error)');
                } catch (e) {
                    showError("Error deleting all chats. Check console.");
                    console.error(e);
                }
            }
        });

        clearLocalStorageBtn.addEventListener('click', () => {
            if (confirm('WARNING: Are you absolutely sure you want to clear ALL browser local cache (themes, local state, settings)? Your chat history (saved in the cloud) will NOT be affected, but you may need to re-login and re-select your preferred theme.')) {
                
                if (isSpeaking) { window.speechSynthesis.cancel(); }
                if (isVoiceInputActive && recognition) { recognition.stop(); }
                if (isConversationModeActive) { stopConversationMode(); }
                
                localStorage.clear(); 
                location.reload(); 
            }
        });
        
        function setChatUIEnabled(enabled) {
            sendChatBtn.disabled = !enabled;
            chatInput.disabled = !enabled;
            chatInput.placeholder = enabled ? "Type your message or ask a question..." : "Please sign in to start chatting.";
            newChatButton.disabled = !enabled;
            toggleCustomPromptBtn.disabled = !enabled;
            manageTemplatesBtn.disabled = !enabled;
            conversationModeToggleBtn.disabled = !enabled;
            
            if (!enabled) {
                 updateButtonIcon(voiceInputBtn, 'mic-off', 'w-5 h-5');
                 voiceInputBtn.disabled = true;
            } else {
                 updateButtonIcon(voiceInputBtn, 'mic', 'w-5 h-5');
                 voiceInputBtn.disabled = false;
            }
        }
        
        async function initializeAuthenticatedApp() {
            if (!currentUser) return;

            setChatUIEnabled(true);
            isAuthSetupComplete = true;

            // 1. Load user settings (themes, model, custom prompt, API key)
            await loadUserSettings();

            // 2. Load chat sessions
            await loadAllChatsFromDB();
            
            // 3. Ensure voice list is updated (it relies on settings being loaded)
            updateVoiceDropdown();
            updatePersonalityDropdown(); // Ensure personalities are loaded

            // 4. Fallback to new chat if needed (already handled in loadAllChatsFromDB but double-check)
            if (Object.keys(allChatSessions).length === 0) {
                createNewChatSession('Welcome Chat');
            }
            
            chatInput.focus();
            
            showCopyMessage(`Welcome, ${currentUser.email || 'user'}! Data loaded from cloud.`, 'var(--accent-primary)');
        }

        // --- Settings Toggle Event Listener (For Sidebar Redesign) ---
        if (toggleSettingsBtn) {
            toggleSettingsBtn.addEventListener('click', () => {
                const isHidden = settingsContent.classList.toggle('hidden');
                if (isHidden) {
                    settingsChevron.style.transform = 'rotate(0deg)';
                } else {
                    settingsChevron.style.transform = 'rotate(180deg)';
                }
                createIcons();
            });
            
            // Initial State Check (Important for the chevron icon)
            if (settingsContent.classList.contains('hidden')) {
                settingsChevron.style.transform = 'rotate(0deg)';
            } else {
                settingsChevron.style.transform = 'rotate(180deg)';
            }
        }

        // --- Final Initializations & Event Hooks ---

        // AUTH Event Listeners
        if (authActionBtn) authActionBtn.addEventListener('click', handleAuthAction);
        if (googleSignInBtn) googleSignInBtn.addEventListener('click', handleGoogleSignIn);
        if (authToggleLink) authToggleLink.addEventListener('click', handleAuthToggle);
        if (signOutButton) signOutButton.addEventListener('click', handleSignOut);

        // Conversation Mode Event Listeners
        if (conversationModeToggleBtn) conversationModeToggleBtn.addEventListener('click', startConversationMode);
        if (conversationModeCloseBtn) conversationModeCloseBtn.addEventListener('click', stopConversationMode);
        if (conversationMicBtn) conversationMicBtn.addEventListener('click', () => {
            if (isUserListeningInConversation && conversationSpeechRecognition) {
                conversationSpeechRecognition.stop();
            } else {
                startConversationListening();
            }
        });
        
        // Listen for enter press on auth form
        authPassword.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleAuthAction();
            }
        });
        
        // Core Firebase Authentication Listener
        auth.onAuthStateChanged(user => {
            handleAuthStateChange(user);
        });

        window.addEventListener('load', () => {
            createIcons();
            
            // Initialize model dropdown early, even before auth, so the settings modal works
            updateModelDropdown(); 
            updatePersonalityDropdown();
            
            // Initially disable UI until auth state is confirmed
            setChatUIEnabled(false); 
            
            // This is needed for the onvoiceschanged event to fire, populating the dropdowns
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                 window.speechSynthesis.onvoiceschanged = updateVoiceDropdown;
            }
            
            adjustChatInputHeight(); 
        });
    </script>
</body>
</html>

--------------------------------------------------------------------

part 1 is my current website where i want to make changes and part 2 is the reference code.

need a horizontal scroll because in case of a long codes within codebocks it's expanding endlessly, overflowing. learn from part 2 and implement.
i want the exact themes from part 2 in part 1 . theme implementation and dark mode toggle are not functioning fix that.
each previous chat must have a delete button for deleting a specific chat. 
voice input is not working and conversation mode is also not working so fix them.
work more on the branding make it more attractive.
fix prism js so it works correctly. because the prism js is not working properly and it has a wooden/brown background i don't want that in code blocks. i want it to be relevant to the current theme just like in part 1.
copy button icon on code blocks looks cut off, so fix that so it looks good and fits well.
i want copy and dictate button under every message just like part 2.

after everything is done, send me the ready to go codes.